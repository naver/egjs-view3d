/*
Copyright (c) 2020-present NAVER Corp.
name: @egjs/view3d
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-view3d
version: 2.1.0
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.View3D = factory());
}(this, (function () { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  /**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   */var REVISION='134';var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var PCFShadowMap=1;var PCFSoftShadowMap=2;var VSMShadowMap=3;var FrontSide=0;var BackSide=1;var DoubleSide=2;var FlatShading=1;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var CineonToneMapping=3;var ACESFilmicToneMapping=4;var CustomToneMapping=5;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var CubeUVReflectionMapping=306;var CubeUVRefractionMapping=307;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipmapNearestFilter=1004;var NearestMipmapLinearFilter=1005;var LinearFilter=1006;var LinearMipmapNearestFilter=1007;var LinearMipmapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedShort565Type=1019;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var RGBEFormat=RGBAFormat;var DepthFormat=1026;var DepthStencilFormat=1027;var RedFormat=1028;var RedIntegerFormat=1029;var RGFormat=1030;var RGIntegerFormat=1031;var RGBIntegerFormat=1032;var RGBAIntegerFormat=1033;var RGB_S3TC_DXT1_Format=33776;var RGBA_S3TC_DXT1_Format=33777;var RGBA_S3TC_DXT3_Format=33778;var RGBA_S3TC_DXT5_Format=33779;var RGB_PVRTC_4BPPV1_Format=35840;var RGB_PVRTC_2BPPV1_Format=35841;var RGBA_PVRTC_4BPPV1_Format=35842;var RGBA_PVRTC_2BPPV1_Format=35843;var RGB_ETC1_Format=36196;var RGB_ETC2_Format=37492;var RGBA_ETC2_EAC_Format=37496;var RGBA_ASTC_4x4_Format=37808;var RGBA_ASTC_5x4_Format=37809;var RGBA_ASTC_5x5_Format=37810;var RGBA_ASTC_6x5_Format=37811;var RGBA_ASTC_6x6_Format=37812;var RGBA_ASTC_8x5_Format=37813;var RGBA_ASTC_8x6_Format=37814;var RGBA_ASTC_8x8_Format=37815;var RGBA_ASTC_10x5_Format=37816;var RGBA_ASTC_10x6_Format=37817;var RGBA_ASTC_10x8_Format=37818;var RGBA_ASTC_10x10_Format=37819;var RGBA_ASTC_12x10_Format=37820;var RGBA_ASTC_12x12_Format=37821;var RGBA_BPTC_Format=36492;var SRGB8_ALPHA8_ASTC_4x4_Format=37840;var SRGB8_ALPHA8_ASTC_5x4_Format=37841;var SRGB8_ALPHA8_ASTC_5x5_Format=37842;var SRGB8_ALPHA8_ASTC_6x5_Format=37843;var SRGB8_ALPHA8_ASTC_6x6_Format=37844;var SRGB8_ALPHA8_ASTC_8x5_Format=37845;var SRGB8_ALPHA8_ASTC_8x6_Format=37846;var SRGB8_ALPHA8_ASTC_8x8_Format=37847;var SRGB8_ALPHA8_ASTC_10x5_Format=37848;var SRGB8_ALPHA8_ASTC_10x6_Format=37849;var SRGB8_ALPHA8_ASTC_10x8_Format=37850;var SRGB8_ALPHA8_ASTC_10x10_Format=37851;var SRGB8_ALPHA8_ASTC_12x10_Format=37852;var SRGB8_ALPHA8_ASTC_12x12_Format=37853;var LoopOnce=2200;var LoopRepeat=2201;var LoopPingPong=2202;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var NormalAnimationBlendMode=2500;var AdditiveAnimationBlendMode=2501;var TrianglesDrawMode=0;var TriangleStripDrawMode=1;var TriangleFanDrawMode=2;var LinearEncoding=3000;var sRGBEncoding=3001;var GammaEncoding=3007;var RGBEEncoding=3002;var LogLuvEncoding=3003;var RGBM7Encoding=3004;var RGBM16Encoding=3005;var RGBDEncoding=3006;var BasicDepthPacking=3200;var RGBADepthPacking=3201;var TangentSpaceNormalMap=0;var ObjectSpaceNormalMap=1;var KeepStencilOp=7680;var AlwaysStencilFunc=519;var StaticDrawUsage=35044;var DynamicDrawUsage=35048;var GLSL3='300 es';/**
   * https://github.com/mrdoob/eventdispatcher.js/
   */class EventDispatcher{addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}}hasEventListener(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;}removeEventListener(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}}dispatchEvent(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;// Make a copy, in case listeners are removed while iterating.
  var array=listenerArray.slice(0);for(var i=0,l=array.length;i<l;i++){array[i].call(this,event);}event.target=null;}}}var _seed=1234567;var DEG2RAD=Math.PI/180;var RAD2DEG=180/Math.PI;//
  var _lut=[];for(var i=0;i<256;i++){_lut[i]=(i<16?'0':'')+i.toString(16);}var hasRandomUUID=typeof crypto!=='undefined'&&'randomUUID'in crypto;function generateUUID(){if(hasRandomUUID){return crypto.randomUUID().toUpperCase();}// TODO Remove this code when crypto.randomUUID() is available everywhere
  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  var d0=Math.random()*0xffffffff|0;var d1=Math.random()*0xffffffff|0;var d2=Math.random()*0xffffffff|0;var d3=Math.random()*0xffffffff|0;var uuid=_lut[d0&0xff]+_lut[d0>>8&0xff]+_lut[d0>>16&0xff]+_lut[d0>>24&0xff]+'-'+_lut[d1&0xff]+_lut[d1>>8&0xff]+'-'+_lut[d1>>16&0x0f|0x40]+_lut[d1>>24&0xff]+'-'+_lut[d2&0x3f|0x80]+_lut[d2>>8&0xff]+'-'+_lut[d2>>16&0xff]+_lut[d2>>24&0xff]+_lut[d3&0xff]+_lut[d3>>8&0xff]+_lut[d3>>16&0xff]+_lut[d3>>24&0xff];// .toUpperCase() here flattens concatenated strings to save heap memory space.
  return uuid.toUpperCase();}function clamp(value,min,max){return Math.max(min,Math.min(max,value));}// compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  function euclideanModulo(n,m){return (n%m+m)%m;}// Linear mapping from range <a1, a2> to range <b1, b2>
  function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);}// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
  function inverseLerp(x,y,value){if(x!==y){return (value-x)/(y-x);}else {return 0;}}// https://en.wikipedia.org/wiki/Linear_interpolation
  function lerp(x,y,t){return (1-t)*x+t*y;}// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
  function damp(x,y,lambda,dt){return lerp(x,y,1-Math.exp(-lambda*dt));}// https://www.desmos.com/calculator/vcsjnyz7x4
  function pingpong(x){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;return length-Math.abs(euclideanModulo(x,length*2)-length);}// http://en.wikipedia.org/wiki/Smoothstep
  function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);}function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);}// Random integer from <low, high> interval
  function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));}// Random float from <low, high> interval
  function randFloat(low,high){return low+Math.random()*(high-low);}// Random float from <-range/2, range/2> interval
  function randFloatSpread(range){return range*(0.5-Math.random());}// Deterministic pseudo-random float in the interval [ 0, 1 ]
  function seededRandom(s){if(s!==undefined)_seed=s%2147483647;// Park-Miller algorithm
  _seed=_seed*16807%2147483647;return (_seed-1)/2147483646;}function degToRad(degrees){return degrees*DEG2RAD;}function radToDeg(radians){return radians*RAD2DEG;}function isPowerOfTwo(value){return (value&value-1)===0&&value!==0;}function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));}function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));}function setQuaternionFromProperEuler(q,a,b,c,order){// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  var cos=Math.cos;var sin=Math.sin;var c2=cos(b/2);var s2=sin(b/2);var c13=cos((a+c)/2);var s13=sin((a+c)/2);var c1_3=cos((a-c)/2);var s1_3=sin((a-c)/2);var c3_1=cos((c-a)/2);var s3_1=sin((c-a)/2);switch(order){case'XYX':q.set(c2*s13,s2*c1_3,s2*s1_3,c2*c13);break;case'YZY':q.set(s2*s1_3,c2*s13,s2*c1_3,c2*c13);break;case'ZXZ':q.set(s2*c1_3,s2*s1_3,c2*s13,c2*c13);break;case'XZX':q.set(c2*s13,s2*s3_1,s2*c3_1,c2*c13);break;case'YXY':q.set(s2*c3_1,c2*s13,s2*s3_1,c2*c13);break;case'ZYZ':q.set(s2*s3_1,s2*c3_1,c2*s13,c2*c13);break;default:console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: '+order);}}var MathUtils=/*#__PURE__*/Object.freeze({__proto__:null,DEG2RAD:DEG2RAD,RAD2DEG:RAD2DEG,generateUUID:generateUUID,clamp:clamp,euclideanModulo:euclideanModulo,mapLinear:mapLinear,inverseLerp:inverseLerp,lerp:lerp,damp:damp,pingpong:pingpong,smoothstep:smoothstep,smootherstep:smootherstep,randInt:randInt,randFloat:randFloat,randFloatSpread:randFloatSpread,seededRandom:seededRandom,degToRad:degToRad,radToDeg:radToDeg,isPowerOfTwo:isPowerOfTwo,ceilPowerOfTwo:ceilPowerOfTwo,floorPowerOfTwo:floorPowerOfTwo,setQuaternionFromProperEuler:setQuaternionFromProperEuler});class Vector2{constructor(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=x;this.y=y;}get width(){return this.x;}set width(value){this.x=value;}get height(){return this.y;}set height(value){this.y=value;}set(x,y){this.x=x;this.y=y;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y);}copy(v){this.x=v.x;this.y=v.y;return this;}add(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;}addScalar(s){this.x+=s;this.y+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;}sub(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;}subScalar(s){this.x-=s;this.y-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;}multiply(v){this.x*=v.x;this.y*=v.y;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;}divide(v){this.x/=v.x;this.y/=v.y;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}applyMatrix3(m){var x=this.x,y=this.y;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;}clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));return this;}clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;}negate(){this.x=-this.x;this.y=-this.y;return this;}dot(v){return this.x*v.x+this.y*v.y;}cross(v){return this.x*v.y-this.y*v.x;}lengthSq(){return this.x*this.x+this.y*this.y;}length(){return Math.sqrt(this.x*this.x+this.y*this.y);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);}normalize(){return this.divideScalar(this.length()||1);}angle(){// computes the angle in radians with respect to the positive x-axis
  var angle=Math.atan2(-this.y,-this.x)+Math.PI;return angle;}distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;return this;}equals(v){return v.x===this.x&&v.y===this.y;}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;return array;}fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;}rotateAround(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}random(){this.x=Math.random();this.y=Math.random();return this;}*[Symbol.iterator](){yield this.x;yield this.y;}}Vector2.prototype.isVector2=true;class Matrix3{constructor(){this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;}identity(){this.set(1,0,0,0,1,0,0,0,1);return this;}copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,1);zAxis.setFromMatrix3Column(this,2);return this;}setFromMatrix4(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;}multiply(m){return this.multiplyMatrices(this,m);}premultiply(m){return this.multiplyMatrices(m,this);}multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;}multiplyScalar(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;}determinant(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;}invert(){var te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;}transpose(){var tmp;var m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;}getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose();}transposeIntoArray(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;}setUvTransform(tx,ty,sx,sy,rotation,cx,cy){var c=Math.cos(rotation);var s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);return this;}scale(sx,sy){var te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this;}rotate(theta){var c=Math.cos(theta);var s=Math.sin(theta);var te=this.elements;var a11=te[0],a12=te[3],a13=te[6];var a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+s*a21;te[3]=c*a12+s*a22;te[6]=c*a13+s*a23;te[1]=-s*a11+c*a21;te[4]=-s*a12+c*a22;te[7]=-s*a13+c*a23;return this;}translate(tx,ty){var te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this;}equals(matrix){var te=this.elements;var me=matrix.elements;for(var _i=0;_i<9;_i++){if(te[_i]!==me[_i])return false;}return true;}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;for(var _i2=0;_i2<9;_i2++){this.elements[_i2]=array[_i2+offset];}return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}clone(){return new this.constructor().fromArray(this.elements);}}Matrix3.prototype.isMatrix3=true;function arrayMax(array){if(array.length===0)return -Infinity;var max=array[0];for(var _i3=1,l=array.length;_i3<l;++_i3){if(array[_i3]>max)max=array[_i3];}return max;}function createElementNS(name){return document.createElementNS('http://www.w3.org/1999/xhtml',name);}/**
    * cyrb53 hash for string from: https://stackoverflow.com/a/52171480
    *
    * Public Domain, @bryc - https://stackoverflow.com/users/815680/bryc
    *
    * It is roughly similar to the well-known MurmurHash/xxHash algorithms. It uses a combination
    * of multiplication and Xorshift to generate the hash, but not as thorough. As a result it's
    * faster than either would be in JavaScript and significantly simpler to implement. Keep in
    * mind this is not a secure algorithm, if privacy/security is a concern, this is not for you.
    *
    * @param {string} str
    * @param {number} seed, default 0
    * @returns number
    */function hashString(str){var seed=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var h1=0xdeadbeef^seed,h2=0x41c6ce57^seed;for(var _i4=0,ch;_i4<str.length;_i4++){ch=str.charCodeAt(_i4);h1=Math.imul(h1^ch,2654435761);h2=Math.imul(h2^ch,1597334677);}h1=Math.imul(h1^h1>>>16,2246822507)^Math.imul(h2^h2>>>13,3266489909);h2=Math.imul(h2^h2>>>16,2246822507)^Math.imul(h1^h1>>>13,3266489909);return 4294967296*(2097151&h2)+(h1>>>0);}var _canvas;class ImageUtils{static getDataURL(image){if(/^data:/i.test(image.src)){return image.src;}if(typeof HTMLCanvasElement=='undefined'){return image.src;}var canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else {if(_canvas===undefined)_canvas=createElementNS('canvas');_canvas.width=image.width;_canvas.height=image.height;var context=_canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else {context.drawImage(image,0,0,image.width,image.height);}canvas=_canvas;}if(canvas.width>2048||canvas.height>2048){console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',image);return canvas.toDataURL('image/jpeg',0.6);}else {return canvas.toDataURL('image/png');}}}var textureId=0;class Texture extends EventDispatcher{constructor(){var image=arguments.length>0&&arguments[0]!==undefined?arguments[0]:Texture.DEFAULT_IMAGE;var mapping=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Texture.DEFAULT_MAPPING;var wrapS=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ClampToEdgeWrapping;var wrapT=arguments.length>3&&arguments[3]!==undefined?arguments[3]:ClampToEdgeWrapping;var magFilter=arguments.length>4&&arguments[4]!==undefined?arguments[4]:LinearFilter;var minFilter=arguments.length>5&&arguments[5]!==undefined?arguments[5]:LinearMipmapLinearFilter;var format=arguments.length>6&&arguments[6]!==undefined?arguments[6]:RGBAFormat;var type=arguments.length>7&&arguments[7]!==undefined?arguments[7]:UnsignedByteType;var anisotropy=arguments.length>8&&arguments[8]!==undefined?arguments[8]:1;var encoding=arguments.length>9&&arguments[9]!==undefined?arguments[9]:LinearEncoding;super();Object.defineProperty(this,'id',{value:textureId++});this.uuid=generateUUID();this.name='';this.image=image;this.mipmaps=[];this.mapping=mapping;this.wrapS=wrapS;this.wrapT=wrapT;this.magFilter=magFilter;this.minFilter=minFilter;this.anisotropy=anisotropy;this.format=format;this.internalFormat=null;this.type=type;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.center=new Vector2(0,0);this.rotation=0;this.matrixAutoUpdate=true;this.matrix=new Matrix3();this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
  this.encoding=encoding;this.userData={};this.version=0;this.onUpdate=null;this.isRenderTargetTexture=false;}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);}clone(){return new this.constructor().copy(this);}copy(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;this.userData=JSON.parse(JSON.stringify(source.userData));return this;}toJSON(meta){var isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==undefined){// TODO: Move to THREE.Image
  var image=this.image;if(image.uuid===undefined){image.uuid=generateUUID();// UGH
  }if(!isRootObject&&meta.images[image.uuid]===undefined){var url;if(Array.isArray(image)){// process array of images e.g. CubeTexture
  url=[];for(var _i5=0,l=image.length;_i5<l;_i5++){// check cube texture with data textures
  if(image[_i5].isDataTexture){url.push(serializeImage(image[_i5].image));}else {url.push(serializeImage(image[_i5]));}}}else {// process single image
  url=serializeImage(image);}meta.images[image.uuid]={uuid:image.uuid,url:url};}output.image=image.uuid;}if(JSON.stringify(this.userData)!=='{}')output.userData=this.userData;if(!isRootObject){meta.textures[this.uuid]=output;}return output;}dispose(){this.dispatchEvent({type:'dispose'});}transformUv(uv){if(this.mapping!==UVMapping)return uv;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else {uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else {uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}return uv;}set needsUpdate(value){if(value===true)this.version++;}}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Texture.prototype.isTexture=true;function serializeImage(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){// default images
  return ImageUtils.getDataURL(image);}else {if(image.data){// images of DataTexture
  return {data:Array.prototype.slice.call(image.data),width:image.width,height:image.height,type:image.data.constructor.name};}else {console.warn('THREE.Texture: Unable to serialize Texture.');return {};}}}class Vector4{constructor(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;this.x=x;this.y=y;this.z=z;this.w=w;}get width(){return this.z;}set width(value){this.z=value;}get height(){return this.w;}set height(value){this.w=value;}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setZ(z){this.z=z;return this;}setW(w){this.w=w;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y,this.z,this.w);}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;}add(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;}addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;}sub(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;}subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;this.w*=v.w;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;}applyMatrix4(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
  // q is assumed to be normalized
  this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else {this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;}setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var angle,x,y,z;// variables for result
  var epsilon=0.01,// margin to allow for rounding errors
  epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
  te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
  // first check for identity matrix which must have +1 for all terms
  // in leading diagonal and zero in other terms
  if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
  this.set(1,0,0,0);return this;// zero angle, arbitrary axis
  }// otherwise this singularity is angle = 180
  angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
  if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else {x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
  if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else {y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else {// m33 is the largest diagonal term so base result on this
  if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else {z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
  }// as we have reached here there are no singularities so we can handle normally
  var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
  if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
  // caught by singularity test above, but I've left it in just in case
  this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;}clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));this.w=Math.max(minVal,Math.min(maxVal,this.w));return this;}clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);}normalize(){return this.divideScalar(this.length()||1);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;this.w=v1.w+(v2.w-v1.w)*alpha;return this;}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;}fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();this.w=Math.random();return this;}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;yield this.w;}}Vector4.prototype.isVector4=true;/*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */class WebGLRenderTarget extends EventDispatcher{constructor(width,height){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};super();this.width=width;this.height=height;this.depth=1;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);this.texture=new Texture(undefined,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.isRenderTargetTexture=true;this.texture.image={width:width,height:height,depth:1};this.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;this.texture.internalFormat=options.internalFormat!==undefined?options.internalFormat:null;this.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:false;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;}setTexture(texture){texture.image={width:this.width,height:this.height,depth:this.depth};this.texture=texture;}setSize(width,height){var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;this.texture.image.width=width;this.texture.image.height=height;this.texture.image.depth=depth;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);}clone(){return new this.constructor().copy(this);}copy(source){this.width=source.width;this.height=source.height;this.depth=source.depth;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.texture.image=_objectSpread2({},this.texture.image);// See #20328.
  this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;}dispose(){this.dispatchEvent({type:'dispose'});}}WebGLRenderTarget.prototype.isWebGLRenderTarget=true;class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(width,height,count){super(width,height);var texture=this.texture;this.texture=[];for(var _i6=0;_i6<count;_i6++){this.texture[_i6]=texture.clone();}}setSize(width,height){var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;for(var _i7=0,il=this.texture.length;_i7<il;_i7++){this.texture[_i7].image.width=width;this.texture[_i7].image.height=height;this.texture[_i7].image.depth=depth;}this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);return this;}copy(source){this.dispose();this.width=source.width;this.height=source.height;this.depth=source.depth;this.viewport.set(0,0,this.width,this.height);this.scissor.set(0,0,this.width,this.height);this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;this.texture.length=0;for(var _i8=0,il=source.texture.length;_i8<il;_i8++){this.texture[_i8]=source.texture[_i8].clone();}return this;}}WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets=true;class WebGLMultisampleRenderTarget extends WebGLRenderTarget{constructor(width,height,options){super(width,height,options);this.samples=4;}copy(source){super.copy.call(this,source);this.samples=source.samples;return this;}}WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget=true;class Quaternion{constructor(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;this._x=x;this._y=y;this._z=z;this._w=w;}static slerp(qa,qb,qm,t){console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');return qm.slerpQuaternions(qa,qb,t);}static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
  var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3];var x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(t===0){dst[dstOffset+0]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;return;}if(t===1){dst[dstOffset+0]=x1;dst[dstOffset+1]=y1;dst[dstOffset+2]=z1;dst[dstOffset+3]=w1;return;}if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t;var cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
  if(sqrSin>Number.EPSILON){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
  if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}static multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){var x0=src0[srcOffset0];var y0=src0[srcOffset0+1];var z0=src0[srcOffset0+2];var w0=src0[srcOffset0+3];var x1=src1[srcOffset1];var y1=src1[srcOffset1+1];var z1=src1[srcOffset1+2];var w1=src1[srcOffset1+3];dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1;dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1;dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1;dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1;return dst;}get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}get w(){return this._w;}set w(value){this._w=value;this._onChangeCallback();}set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this;}clone(){return new this.constructor(this._x,this._y,this._z,this._w);}copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this;}setFromEuler(euler,update){if(!(euler&&euler.isEuler)){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}var x=euler._x,y=euler._y,z=euler._z,order=euler._order;// http://www.mathworks.com/matlabcentral/fileexchange/
  // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  //	content/SpinCalc.m
  var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);switch(order){case'XYZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'YXZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'ZXY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'ZYX':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'YZX':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'XZY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;default:console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: '+order);}if(update!==false)this._onChangeCallback();return this;}setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
  // assumes axis is normalized
  var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this._onChangeCallback();return this;}setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){var s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){var _s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/_s;this._x=0.25*_s;this._y=(m12+m21)/_s;this._z=(m13+m31)/_s;}else if(m22>m33){var _s2=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/_s2;this._x=(m12+m21)/_s2;this._y=0.25*_s2;this._z=(m23+m32)/_s2;}else {var _s3=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/_s3;this._x=(m13+m31)/_s3;this._y=(m23+m32)/_s3;this._z=0.25*_s3;}this._onChangeCallback();return this;}setFromUnitVectors(vFrom,vTo){// assumes direction vectors vFrom and vTo are normalized
  var r=vFrom.dot(vTo)+1;if(r<Number.EPSILON){// vFrom and vTo point in opposite directions
  r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){this._x=-vFrom.y;this._y=vFrom.x;this._z=0;this._w=r;}else {this._x=0;this._y=-vFrom.z;this._z=vFrom.y;this._w=r;}}else {// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
  this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;this._w=r;}return this.normalize();}angleTo(q){return 2*Math.acos(Math.abs(clamp(this.dot(q),-1,1)));}rotateTowards(q,step){var angle=this.angleTo(q);if(angle===0)return this;var t=Math.min(1,step/angle);this.slerp(q,t);return this;}identity(){return this.set(0,0,0,1);}invert(){// quaternion is assumed to have unit length
  return this.conjugate();}conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this;}dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);}normalize(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else {l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this._onChangeCallback();return this;}multiply(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);}premultiply(q){return this.multiplyQuaternions(q,this);}multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
  var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this;}slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
  var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else {this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sqrSinHalfTheta=1.0-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=Number.EPSILON){var s=1-t;this._w=s*w+t*this._w;this._x=s*x+t*this._x;this._y=s*y+t*this._y;this._z=s*z+t*this._z;this.normalize();this._onChangeCallback();return this;}var sinHalfTheta=Math.sqrt(sqrSinHalfTheta);var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this._onChangeCallback();return this;}slerpQuaternions(qa,qb,t){this.copy(qa).slerp(qb,t);}random(){// Derived from http://planning.cs.uiuc.edu/node198.html
  // Note, this source uses w, x, y, z ordering,
  // so we swap the order below.
  var u1=Math.random();var sqrt1u1=Math.sqrt(1-u1);var sqrtu1=Math.sqrt(u1);var u2=2*Math.PI*Math.random();var u3=2*Math.PI*Math.random();return this.set(sqrt1u1*Math.cos(u2),sqrtu1*Math.sin(u3),sqrtu1*Math.cos(u3),sqrt1u1*Math.sin(u2));}equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;}fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);return this;}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}}Quaternion.prototype.isQuaternion=true;class Vector3{constructor(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;this.x=x;this.y=y;this.z=z;}set(x,y,z){if(z===undefined)z=this.z;// sprite.scale.set(x,y)
  this.x=x;this.y=y;this.z=z;return this;}setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;}setX(x){this.x=x;return this;}setY(y){this.y=y;return this;}setZ(z){this.z=z;return this;}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}}clone(){return new this.constructor(this.x,this.y,this.z);}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;}add(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;}sub(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;}multiply(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;}multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;}applyEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(_quaternion$4.setFromEuler(euler));}applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle));}applyMatrix3(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;}applyNormalMatrix(m){return this.applyMatrix3(m).normalize();}applyMatrix4(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;var w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;}applyQuaternion(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
  var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
  this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;}project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);}unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);}transformDirection(m){// input: THREE.Matrix4 affine matrix
  // vector interpreted as a direction
  var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();}divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;}divideScalar(scalar){return this.multiplyScalar(1/scalar);}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;}clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));return this;}clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}// TODO lengthSquared?
  lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);}normalize(){return this.divideScalar(this.length()||1);}setLength(length){return this.normalize().multiplyScalar(length);}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;return this;}cross(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}return this.crossVectors(this,v);}crossVectors(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;}projectOnVector(v){var denominator=v.lengthSq();if(denominator===0)return this.set(0,0,0);var scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar);}projectOnPlane(planeNormal){_vector$c.copy(this).projectOnVector(planeNormal);return this.sub(_vector$c);}reflect(normal){// reflect incident vector off plane orthogonal to normal
  // normal is assumed to have unit length
  return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)));}angleTo(v){var denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;var theta=this.dot(v)/denominator;// clamp, to handle numerical problems
  return Math.acos(clamp(theta,-1,1));}distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);}setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta);}setFromSphericalCoords(radius,phi,theta){var sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this;}setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y);}setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this;}setFromMatrixPosition(m){var e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;}setFromMatrixScale(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;}setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);}setFromMatrix3Column(m,index){return this.fromArray(m.elements,index*3);}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;}fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this;}randomDirection(){// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
  var u=(Math.random()-0.5)*2;var t=Math.random()*Math.PI*2;var f=Math.sqrt(1-Math.pow(u,2));this.x=f*Math.cos(t);this.y=f*Math.sin(t);this.z=u;return this;}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;}}Vector3.prototype.isVector3=true;var _vector$c=/*@__PURE__*/new Vector3();var _quaternion$4=/*@__PURE__*/new Quaternion();class Box3{constructor(){var min=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3(+Infinity,+Infinity,+Infinity);var max=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3(-Infinity,-Infinity,-Infinity);this.min=min;this.max=max;}set(min,max){this.min.copy(min);this.max.copy(max);return this;}setFromArray(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var _i9=0,l=array.length;_i9<l;_i9+=3){var x=array[_i9];var y=array[_i9+1];var z=array[_i9+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}setFromBufferAttribute(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var _i10=0,l=attribute.count;_i10<l;_i10++){var x=attribute.getX(_i10);var y=attribute.getY(_i10);var z=attribute.getZ(_i10);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}setFromPoints(points){this.makeEmpty();for(var _i11=0,il=points.length;_i11<il;_i11++){this.expandByPoint(points[_i11]);}return this;}setFromCenterAndSize(center,size){var halfSize=_vector$b.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}setFromObject(object){this.makeEmpty();return this.expandByObject(object);}clone(){return new this.constructor().copy(this);}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
  return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;}getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);}expandByPoint(point){this.min.min(point);this.max.max(point);return this;}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}expandByObject(object){// Computes the world-axis-aligned bounding box of an object (including its children),
  // accounting for both the object's, and children's, world transforms
  object.updateWorldMatrix(false,false);var geometry=object.geometry;if(geometry!==undefined){if(geometry.boundingBox===null){geometry.computeBoundingBox();}_box$3.copy(geometry.boundingBox);_box$3.applyMatrix4(object.matrixWorld);this.union(_box$3);}var children=object.children;for(var _i12=0,l=children.length;_i12<l;_i12++){this.expandByObject(children[_i12]);}return this;}containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;}getParameter(point,target){// This can potentially have a divide by zero if the box
  // has a size dimension of 0.
  return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));}intersectsBox(box){// using 6 splitting planes to rule out intersections.
  return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;}intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
  this.clampPoint(sphere.center,_vector$b);// If that point is inside the sphere, the AABB and sphere intersect.
  return _vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;}intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
  // are on the same side (back or front) of the plane, then there is no intersection.
  var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else {min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else {min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else {min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;}intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
  this.getCenter(_center);_extents.subVectors(this.max,_center);// translate triangle to aabb origin
  _v0$2.subVectors(triangle.a,_center);_v1$7.subVectors(triangle.b,_center);_v2$3.subVectors(triangle.c,_center);// compute edge vectors for triangle
  _f0.subVectors(_v1$7,_v0$2);_f1.subVectors(_v2$3,_v1$7);_f2.subVectors(_v0$2,_v2$3);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  var axes=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// test 3 face normals from the aabb
  axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// finally testing the face normal of the triangle
  // use already existing triangle edge vectors here
  _triangleNormal.crossVectors(_f0,_f1);axes=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z];return satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents);}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}distanceToPoint(point){var clampedPoint=_vector$b.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();}getBoundingSphere(target){this.getCenter(target.center);target.radius=this.getSize(_vector$b).length()*0.5;return target;}intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  if(this.isEmpty())this.makeEmpty();return this;}union(box){this.min.min(box.min);this.max.max(box.max);return this;}applyMatrix4(matrix){// transform of empty box is an empty box.
  if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  _points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
  _points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
  _points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
  _points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
  _points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
  _points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
  _points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
  _points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
  this.setFromPoints(_points);return this;}translate(offset){this.min.add(offset);this.max.add(offset);return this;}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}}Box3.prototype.isBox3=true;var _points=[/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3()];var _vector$b=/*@__PURE__*/new Vector3();var _box$3=/*@__PURE__*/new Box3();// triangle centered vertices
  var _v0$2=/*@__PURE__*/new Vector3();var _v1$7=/*@__PURE__*/new Vector3();var _v2$3=/*@__PURE__*/new Vector3();// triangle edge vectors
  var _f0=/*@__PURE__*/new Vector3();var _f1=/*@__PURE__*/new Vector3();var _f2=/*@__PURE__*/new Vector3();var _center=/*@__PURE__*/new Vector3();var _extents=/*@__PURE__*/new Vector3();var _triangleNormal=/*@__PURE__*/new Vector3();var _testAxis=/*@__PURE__*/new Vector3();function satForAxes(axes,v0,v1,v2,extents){for(var _i13=0,j=axes.length-3;_i13<=j;_i13+=3){_testAxis.fromArray(axes,_i13);// project the aabb onto the seperating axis
  var r=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z);// project all 3 vertices of the triangle onto the seperating axis
  var p0=v0.dot(_testAxis);var p1=v1.dot(_testAxis);var p2=v2.dot(_testAxis);// actual test, basically see if either of the most extreme of the triangle points intersects r
  if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
  // the axis is seperating and we can exit
  return false;}}return true;}var _box$2=/*@__PURE__*/new Box3();var _v1$6=/*@__PURE__*/new Vector3();var _toFarthestPoint=/*@__PURE__*/new Vector3();var _toPoint=/*@__PURE__*/new Vector3();class Sphere{constructor(){var center=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var radius=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-1;this.center=center;this.radius=radius;}set(center,radius){this.center.copy(center);this.radius=radius;return this;}setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else {_box$2.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var _i14=0,il=points.length;_i14<il;_i14++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[_i14]));}this.radius=Math.sqrt(maxRadiusSq);return this;}copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;}isEmpty(){return this.radius<0;}makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this;}containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;}distanceToPoint(point){return point.distanceTo(this.center)-this.radius;}intersectsSphere(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;}intersectsBox(box){return box.intersectsSphere(this);}intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;}clampPoint(point,target){var deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;}getBoundingBox(target){if(this.isEmpty()){// Empty sphere produces empty bounding box
  target.makeEmpty();return target;}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;}applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;}translate(offset){this.center.add(offset);return this;}expandByPoint(point){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
  _toPoint.subVectors(point,this.center);var lengthSq=_toPoint.lengthSq();if(lengthSq>this.radius*this.radius){var length=Math.sqrt(lengthSq);var missingRadiusHalf=(length-this.radius)*0.5;// Nudge this sphere towards the target point. Add half the missing distance to radius,
  // and the other half to position. This gives a tighter enclosure, instead of if
  // the whole missing distance were just added to radius.
  this.center.add(_toPoint.multiplyScalar(missingRadiusHalf/length));this.radius+=missingRadiusHalf;}return this;}union(sphere){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
  // To enclose another sphere into this sphere, we only need to enclose two points:
  // 1) Enclose the farthest point on the other sphere into this sphere.
  // 2) Enclose the opposite point of the farthest point into this sphere.
  _toFarthestPoint.subVectors(sphere.center,this.center).normalize().multiplyScalar(sphere.radius);this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));return this;}equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}clone(){return new this.constructor().copy(this);}}var _vector$a=/*@__PURE__*/new Vector3();var _segCenter=/*@__PURE__*/new Vector3();var _segDir=/*@__PURE__*/new Vector3();var _diff=/*@__PURE__*/new Vector3();var _edge1=/*@__PURE__*/new Vector3();var _edge2=/*@__PURE__*/new Vector3();var _normal$1=/*@__PURE__*/new Vector3();class Ray{constructor(){var origin=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var direction=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3(0,0,-1);this.origin=origin;this.direction=direction;}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;}copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;}at(t,target){return target.copy(this.direction).multiplyScalar(t).add(this.origin);}lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;}recast(t){this.origin.copy(this.at(t,_vector$a));return this;}closestPointToPoint(point,target){target.subVectors(point,this.origin);var directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);}distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));}distanceSqToPoint(point){var directionDistance=_vector$a.subVectors(point,this.origin).dot(this.direction);// point behind the ray
  if(directionDistance<0){return this.origin.distanceToSquared(point);}_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return _vector$a.distanceToSquared(point);}distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  // It returns the min distance between the ray and the segment
  // defined by v0 and v1
  // It can also set two optional targets :
  // - The closest point on the ray
  // - The closest point on the segment
  _segCenter.copy(v0).add(v1).multiplyScalar(0.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(_segDir);var b0=_diff.dot(this.direction);var b1=-_diff.dot(_segDir);var c=_diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
  s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
  // Minimum at interior points of ray and segment.
  var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else {// region 1
  s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {// region 5
  s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {if(s1<=-extDet){// region 4
  s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
  s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else {// region 2
  s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else {// Ray and segment are parallel.
  s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);}return sqrDist;}intersectSphere(sphere,target){_vector$a.subVectors(sphere.center,this.origin);var tca=_vector$a.dot(this.direction);var d2=_vector$a.dot(_vector$a)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
  var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
  var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
  if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
  // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  // in order to always return an intersect point that is in front of the ray.
  if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
  return this.at(t0,target);}intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;}distanceToPlane(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
  if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
  return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
  return t>=0?t:null;}intersectPlane(plane,target){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);}intersectsPlane(plane){// check if the ray lies on the plane first
  var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
  return false;}intersectBox(box,target){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else {tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else {tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
  // (result of 0 * Infinity). x !== x returns true if x is NaN
  if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else {tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
  if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);}intersectsBox(box){return this.intersectBox(box,_vector$a)!==null;}intersectTriangle(a,b,c,backfaceCulling,target){// Compute the offset origin, edges, and normal.
  // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
  _edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal$1.crossVectors(_edge1,_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  var DdN=this.direction.dot(_normal$1);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else {return null;}_diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));// b1 < 0, no intersection
  if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));// b2 < 0, no intersection
  if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
  if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
  var QdN=-sign*_diff.dot(_normal$1);// t < 0, no intersection
  if(QdN<0){return null;}// Ray intersects triangle.
  return this.at(QdN/DdN,target);}applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}clone(){return new this.constructor().copy(this);}}class Matrix4{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;}identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;}clone(){return new Matrix4().fromArray(this.elements);}copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;}copyPosition(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;}setFromMatrix3(m){var me=m.elements;this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1);return this;}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;}makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;}extractRotation(m){// this method does not support reflection matrices
  var te=this.elements;var me=m.elements;var scaleX=1/_v1$5.setFromMatrixColumn(m,0).length();var scaleY=1/_v1$5.setFromMatrixColumn(m,1).length();var scaleZ=1/_v1$5.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}makeRotationFromEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var _ce=c*e,_cf=c*f,_de=d*e,_df=d*f;te[0]=_ce-_df*b;te[4]=-a*f;te[8]=_de+_cf*b;te[1]=_cf+_de*b;te[5]=a*e;te[9]=_df-_ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var _ae=a*e,_af=a*f,_be=b*e,_bf=b*f;te[0]=c*e;te[4]=_be*d-_af;te[8]=_ae*d+_bf;te[1]=c*f;te[5]=_bf*d+_ae;te[9]=_af*d-_be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var _ac=a*c,_ad=a*d,_bc=b*c,_bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=_ac*f+_bd;te[5]=a*e;te[9]=_ad*f-_bc;te[2]=_bc*f-_ad;te[6]=b*e;te[10]=_bd*f+_ac;}// bottom row
  te[3]=0;te[7]=0;te[11]=0;// last column
  te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}makeRotationFromQuaternion(q){return this.compose(_zero,q,_one);}lookAt(eye,target,up){var te=this.elements;_z.subVectors(eye,target);if(_z.lengthSq()===0){// eye and target are in the same position
  _z.z=1;}_z.normalize();_x.crossVectors(up,_z);if(_x.lengthSq()===0){// up and z are parallel
  if(Math.abs(up.z)===1){_z.x+=0.0001;}else {_z.z+=0.0001;}_z.normalize();_x.crossVectors(up,_z);}_x.normalize();_y.crossVectors(_z,_x);te[0]=_x.x;te[4]=_y.x;te[8]=_z.x;te[1]=_x.y;te[5]=_y.y;te[9]=_z.y;te[2]=_x.z;te[6]=_y.z;te[10]=_z.z;return this;}multiply(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);}premultiply(m){return this.multiplyMatrices(m,this);}multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;}multiplyScalar(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;}determinant(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
  //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
  return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);}transpose(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;}setPosition(x,y,z){var te=this.elements;if(x.isVector3){te[12]=x.x;te[13]=x.y;te[14]=x.z;}else {te[12]=x;te[13]=y;te[14]=z;}return this;}invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  var te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;}scale(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;}getMaxScaleOnAxis(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));}makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;}makeRotationX(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;}makeRotationY(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;}makeRotationZ(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;}makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
  var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;}makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;}makeShear(xy,xz,yx,yz,zx,zy){this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1);return this;}compose(position,quaternion,scale){var te=this.elements;var x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;var sx=scale.x,sy=scale.y,sz=scale.z;te[0]=(1-(yy+zz))*sx;te[1]=(xy+wz)*sx;te[2]=(xz-wy)*sx;te[3]=0;te[4]=(xy-wz)*sy;te[5]=(1-(xx+zz))*sy;te[6]=(yz+wx)*sy;te[7]=0;te[8]=(xz+wy)*sz;te[9]=(yz-wx)*sz;te[10]=(1-(xx+yy))*sz;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;te[15]=1;return this;}decompose(position,quaternion,scale){var te=this.elements;var sx=_v1$5.set(te[0],te[1],te[2]).length();var sy=_v1$5.set(te[4],te[5],te[6]).length();var sz=_v1$5.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
  var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
  _m1$2.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;_m1$2.elements[0]*=invSX;_m1$2.elements[1]*=invSX;_m1$2.elements[2]*=invSX;_m1$2.elements[4]*=invSY;_m1$2.elements[5]*=invSY;_m1$2.elements[6]*=invSY;_m1$2.elements[8]*=invSZ;_m1$2.elements[9]*=invSZ;_m1$2.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1$2);scale.x=sx;scale.y=sy;scale.z=sz;return this;}makePerspective(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;}makeOrthographic(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;}equals(matrix){var te=this.elements;var me=matrix.elements;for(var _i15=0;_i15<16;_i15++){if(te[_i15]!==me[_i15])return false;}return true;}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;for(var _i16=0;_i16<16;_i16++){this.elements[_i16]=array[_i16+offset];}return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}}Matrix4.prototype.isMatrix4=true;var _v1$5=/*@__PURE__*/new Vector3();var _m1$2=/*@__PURE__*/new Matrix4();var _zero=/*@__PURE__*/new Vector3(0,0,0);var _one=/*@__PURE__*/new Vector3(1,1,1);var _x=/*@__PURE__*/new Vector3();var _y=/*@__PURE__*/new Vector3();var _z=/*@__PURE__*/new Vector3();var _matrix$1=/*@__PURE__*/new Matrix4();var _quaternion$3=/*@__PURE__*/new Quaternion();class Euler{constructor(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var order=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Euler.DefaultOrder;this._x=x;this._y=y;this._z=z;this._order=order;}get x(){return this._x;}set x(value){this._x=value;this._onChangeCallback();}get y(){return this._y;}set y(value){this._y=value;this._onChangeCallback();}get z(){return this._z;}set z(value){this._z=value;this._onChangeCallback();}get order(){return this._order;}set order(value){this._order=value;this._onChangeCallback();}set(x,y,z){var order=arguments.length>3&&arguments[3]!==undefined?arguments[3]:this._order;this._x=x;this._y=y;this._z=z;this._order=order;this._onChangeCallback();return this;}clone(){return new this.constructor(this._x,this._y,this._z,this._order);}copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this;}setFromRotationMatrix(m){var order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._order;var update=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];switch(order){case'XYZ':this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.9999999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else {this._x=Math.atan2(m32,m22);this._z=0;}break;case'YXZ':this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.9999999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else {this._y=Math.atan2(-m31,m11);this._z=0;}break;case'ZXY':this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.9999999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else {this._y=0;this._z=Math.atan2(m21,m11);}break;case'ZYX':this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.9999999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else {this._x=0;this._z=Math.atan2(-m12,m22);}break;case'YZX':this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.9999999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else {this._x=0;this._y=Math.atan2(m13,m33);}break;case'XZY':this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.9999999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else {this._x=Math.atan2(-m23,m33);this._y=0;}break;default:console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: '+order);}this._order=order;if(update===true)this._onChangeCallback();return this;}setFromQuaternion(q,order,update){_matrix$1.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix$1,order,update);}setFromVector3(v){var order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._order;return this.set(v.x,v.y,v.z,order);}reorder(newOrder){// WARNING: this discards revolution information -bhouston
  _quaternion$3.setFromEuler(this);return this.setFromQuaternion(_quaternion$3,newOrder);}equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;}fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this._onChangeCallback();return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;}toVector3(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else {return new Vector3(this._x,this._y,this._z);}}_onChange(callback){this._onChangeCallback=callback;return this;}_onChangeCallback(){}}Euler.prototype.isEuler=true;Euler.DefaultOrder='XYZ';Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];class Layers{constructor(){this.mask=1|0;}set(channel){this.mask=1<<channel|0;}enable(channel){this.mask|=1<<channel|0;}enableAll(){this.mask=0xffffffff|0;}toggle(channel){this.mask^=1<<channel|0;}disable(channel){this.mask&=~(1<<channel|0);}disableAll(){this.mask=0;}test(layers){return (this.mask&layers.mask)!==0;}}var _object3DId=0;var _v1$4=/*@__PURE__*/new Vector3();var _q1=/*@__PURE__*/new Quaternion();var _m1$1=/*@__PURE__*/new Matrix4();var _target=/*@__PURE__*/new Vector3();var _position$3=/*@__PURE__*/new Vector3();var _scale$2=/*@__PURE__*/new Vector3();var _quaternion$2=/*@__PURE__*/new Quaternion();var _xAxis=/*@__PURE__*/new Vector3(1,0,0);var _yAxis=/*@__PURE__*/new Vector3(0,1,0);var _zAxis=/*@__PURE__*/new Vector3(0,0,1);var _addedEvent={type:'added'};var _removedEvent={type:'removed'};class Object3D extends EventDispatcher{constructor(){super();Object.defineProperty(this,'id',{value:_object3DId++});this.uuid=generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation._onChange(onRotationChange);quaternion._onChange(onQuaternionChange);Object.defineProperties(this,{position:{configurable:true,enumerable:true,value:position},rotation:{configurable:true,enumerable:true,value:rotation},quaternion:{configurable:true,enumerable:true,value:quaternion},scale:{configurable:true,enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.animations=[];this.userData={};}onBeforeRender(){}onAfterRender(){}applyMatrix4(matrix){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);}applyQuaternion(q){this.quaternion.premultiply(q);return this;}setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
  this.quaternion.setFromAxisAngle(axis,angle);}setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);}setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  this.quaternion.setFromRotationMatrix(m);}setRotationFromQuaternion(q){// assumes q is normalized
  this.quaternion.copy(q);}rotateOnAxis(axis,angle){// rotate object on axis in object space
  // axis is assumed to be normalized
  _q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1);return this;}rotateOnWorldAxis(axis,angle){// rotate object on axis in world space
  // axis is assumed to be normalized
  // method assumes no rotated parent
  _q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1);return this;}rotateX(angle){return this.rotateOnAxis(_xAxis,angle);}rotateY(angle){return this.rotateOnAxis(_yAxis,angle);}rotateZ(angle){return this.rotateOnAxis(_zAxis,angle);}translateOnAxis(axis,distance){// translate object by distance along axis in object space
  // axis is assumed to be normalized
  _v1$4.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$4.multiplyScalar(distance));return this;}translateX(distance){return this.translateOnAxis(_xAxis,distance);}translateY(distance){return this.translateOnAxis(_yAxis,distance);}translateZ(distance){return this.translateOnAxis(_zAxis,distance);}localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);}worldToLocal(vector){return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());}lookAt(x,y,z){// This method does not support objects having non-uniformly-scaled parent(s)
  if(x.isVector3){_target.copy(x);}else {_target.set(x,y,z);}var parent=this.parent;this.updateWorldMatrix(true,false);_position$3.setFromMatrixPosition(this.matrixWorld);if(this.isCamera||this.isLight){_m1$1.lookAt(_position$3,_target,this.up);}else {_m1$1.lookAt(_target,_position$3,this.up);}this.quaternion.setFromRotationMatrix(_m1$1);if(parent){_m1$1.extractRotation(parent.matrixWorld);_q1.setFromRotationMatrix(_m1$1);this.quaternion.premultiply(_q1.invert());}}add(object){if(arguments.length>1){for(var _i17=0;_i17<arguments.length;_i17++){this.add(arguments[_i17]);}return this;}if(object===this){console.error('THREE.Object3D.add: object can\'t be added as a child of itself.',object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;this.children.push(object);object.dispatchEvent(_addedEvent);}else {console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.',object);}return this;}remove(object){if(arguments.length>1){for(var _i18=0;_i18<arguments.length;_i18++){this.remove(arguments[_i18]);}return this;}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;this.children.splice(index,1);object.dispatchEvent(_removedEvent);}return this;}removeFromParent(){var parent=this.parent;if(parent!==null){parent.remove(this);}return this;}clear(){for(var _i19=0;_i19<this.children.length;_i19++){var object=this.children[_i19];object.parent=null;object.dispatchEvent(_removedEvent);}this.children.length=0;return this;}attach(object){// adds object as a child of this, while maintaining the object's world transform
  this.updateWorldMatrix(true,false);_m1$1.copy(this.matrixWorld).invert();if(object.parent!==null){object.parent.updateWorldMatrix(true,false);_m1$1.multiply(object.parent.matrixWorld);}object.applyMatrix4(_m1$1);this.add(object);object.updateWorldMatrix(false,true);return this;}getObjectById(id){return this.getObjectByProperty('id',id);}getObjectByName(name){return this.getObjectByProperty('name',name);}getObjectByProperty(name,value){if(this[name]===value)return this;for(var _i20=0,l=this.children.length;_i20<l;_i20++){var child=this.children[_i20];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;}getWorldPosition(target){this.updateWorldMatrix(true,false);return target.setFromMatrixPosition(this.matrixWorld);}getWorldQuaternion(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,target,_scale$2);return target;}getWorldScale(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,_quaternion$2,target);return target;}getWorldDirection(target){this.updateWorldMatrix(true,false);var e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize();}raycast(){}traverse(callback){callback(this);var children=this.children;for(var _i21=0,l=children.length;_i21<l;_i21++){children[_i21].traverse(callback);}}traverseVisible(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var _i22=0,l=children.length;_i22<l;_i22++){children[_i22].traverseVisible(callback);}}traverseAncestors(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;}updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
  var children=this.children;for(var _i23=0,l=children.length;_i23<l;_i23++){children[_i23].updateMatrixWorld(force);}}updateWorldMatrix(updateParents,updateChildren){var parent=this.parent;if(updateParents===true&&parent!==null){parent.updateWorldMatrix(true,false);}if(this.matrixAutoUpdate)this.updateMatrix();if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}// update children
  if(updateChildren===true){var children=this.children;for(var _i24=0,l=children.length;_i24<l;_i24++){children[_i24].updateWorldMatrix(false,true);}}}toJSON(meta){// meta is a string when called from JSON.stringify
  var isRootObject=meta===undefined||typeof meta==='string';var output={};// meta is a hash used to collect geometries, materials.
  // not providing it implies that this is the root object
  // being serialized.
  if(isRootObject){// initialize meta obj
  meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
  var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;object.layers=this.layers.mask;object.matrix=this.matrix.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;// object specific properties
  if(this.isInstancedMesh){object.type='InstancedMesh';object.count=this.count;object.instanceMatrix=this.instanceMatrix.toJSON();if(this.instanceColor!==null)object.instanceColor=this.instanceColor.toJSON();}//
  function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.isScene){if(this.background){if(this.background.isColor){object.background=this.background.toJSON();}else if(this.background.isTexture){object.background=this.background.toJSON(meta).uuid;}}if(this.environment&&this.environment.isTexture){object.environment=this.environment.toJSON(meta).uuid;}}else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);var parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){var shapes=parameters.shapes;if(Array.isArray(shapes)){for(var _i25=0,l=shapes.length;_i25<l;_i25++){var shape=shapes[_i25];serialize(meta.shapes,shape);}}else {serialize(meta.shapes,shapes);}}}if(this.isSkinnedMesh){object.bindMode=this.bindMode;object.bindMatrix=this.bindMatrix.toArray();if(this.skeleton!==undefined){serialize(meta.skeletons,this.skeleton);object.skeleton=this.skeleton.uuid;}}if(this.material!==undefined){if(Array.isArray(this.material)){var uuids=[];for(var _i26=0,_l=this.material.length;_i26<_l;_i26++){uuids.push(serialize(meta.materials,this.material[_i26]));}object.material=uuids;}else {object.material=serialize(meta.materials,this.material);}}//
  if(this.children.length>0){object.children=[];for(var _i27=0;_i27<this.children.length;_i27++){object.children.push(this.children[_i27].toJSON(meta).object);}}//
  if(this.animations.length>0){object.animations=[];for(var _i28=0;_i28<this.animations.length;_i28++){var animation=this.animations[_i28];object.animations.push(serialize(meta.animations,animation));}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);var _shapes=extractFromCache(meta.shapes);var skeletons=extractFromCache(meta.skeletons);var animations=extractFromCache(meta.animations);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(_shapes.length>0)output.shapes=_shapes;if(skeletons.length>0)output.skeletons=skeletons;if(animations.length>0)output.animations=animations;}output.object=object;return output;// extract data from the cache hash
  // remove metadata on each item
  // and return as array
  function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}}clone(recursive){return new this.constructor().copy(this,recursive);}copy(source){var recursive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.rotation.order=source.rotation.order;this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(var _i29=0;_i29<source.children.length;_i29++){var child=source.children[_i29];this.add(child.clone());}}return this;}}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object3D.prototype.isObject3D=true;var _v0$1=/*@__PURE__*/new Vector3();var _v1$3=/*@__PURE__*/new Vector3();var _v2$2=/*@__PURE__*/new Vector3();var _v3$1=/*@__PURE__*/new Vector3();var _vab=/*@__PURE__*/new Vector3();var _vac=/*@__PURE__*/new Vector3();var _vbc=/*@__PURE__*/new Vector3();var _vap=/*@__PURE__*/new Vector3();var _vbp=/*@__PURE__*/new Vector3();var _vcp=/*@__PURE__*/new Vector3();class Triangle{constructor(){var a=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var b=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var c=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector3();this.a=a;this.b=b;this.c=c;}static getNormal(a,b,c,target){target.subVectors(c,b);_v0$1.subVectors(a,b);target.cross(_v0$1);var targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);}// static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point,a,b,c,target){_v0$1.subVectors(c,a);_v1$3.subVectors(b,a);_v2$2.subVectors(point,a);var dot00=_v0$1.dot(_v0$1);var dot01=_v0$1.dot(_v1$3);var dot02=_v0$1.dot(_v2$2);var dot11=_v1$3.dot(_v1$3);var dot12=_v1$3.dot(_v2$2);var denom=dot00*dot11-dot01*dot01;// collinear or singular triangle
  if(denom===0){// arbitrary location outside of triangle?
  // not sure if this is the best idea, maybe should be returning undefined
  return target.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
  return target.set(1-u-v,v,u);}static containsPoint(point,a,b,c){this.getBarycoord(point,a,b,c,_v3$1);return _v3$1.x>=0&&_v3$1.y>=0&&_v3$1.x+_v3$1.y<=1;}static getUV(point,p1,p2,p3,uv1,uv2,uv3,target){this.getBarycoord(point,p1,p2,p3,_v3$1);target.set(0,0);target.addScaledVector(uv1,_v3$1.x);target.addScaledVector(uv2,_v3$1.y);target.addScaledVector(uv3,_v3$1.z);return target;}static isFrontFacing(a,b,c,direction){_v0$1.subVectors(c,b);_v1$3.subVectors(a,b);// strictly front facing
  return _v0$1.cross(_v1$3).dot(direction)<0?true:false;}set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;}setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;}setFromAttributeAndIndices(attribute,i0,i1,i2){this.a.fromBufferAttribute(attribute,i0);this.b.fromBufferAttribute(attribute,i1);this.c.fromBufferAttribute(attribute,i2);return this;}clone(){return new this.constructor().copy(this);}copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;}getArea(){_v0$1.subVectors(this.c,this.b);_v1$3.subVectors(this.a,this.b);return _v0$1.cross(_v1$3).length()*0.5;}getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);}getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target);}getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c);}getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);}getUV(point,uv1,uv2,uv3,target){return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target);}containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);}isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction);}intersectsBox(box){return box.intersectsTriangle(this);}closestPointToPoint(p,target){var a=this.a,b=this.b,c=this.c;var v,w;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  // under the accompanying license; see chapter 5.1.5 for detailed explanation.
  // basically, we're distinguishing which of the voronoi regions of the triangle
  // the point lies in with the minimum amount of redundant computation.
  _vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);var d1=_vab.dot(_vap);var d2=_vac.dot(_vap);if(d1<=0&&d2<=0){// vertex region of A; barycentric coords (1, 0, 0)
  return target.copy(a);}_vbp.subVectors(p,b);var d3=_vab.dot(_vbp);var d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3){// vertex region of B; barycentric coords (0, 1, 0)
  return target.copy(b);}var vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0){v=d1/(d1-d3);// edge region of AB; barycentric coords (1-v, v, 0)
  return target.copy(a).addScaledVector(_vab,v);}_vcp.subVectors(p,c);var d5=_vab.dot(_vcp);var d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6){// vertex region of C; barycentric coords (0, 0, 1)
  return target.copy(c);}var vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0){w=d2/(d2-d6);// edge region of AC; barycentric coords (1-w, 0, w)
  return target.copy(a).addScaledVector(_vac,w);}var va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0){_vbc.subVectors(c,b);w=(d4-d3)/(d4-d3+(d5-d6));// edge region of BC; barycentric coords (0, 1-w, w)
  return target.copy(b).addScaledVector(_vbc,w);// edge region of BC
  }// face region
  var denom=1/(va+vb+vc);// u = va * denom
  v=vb*denom;w=vc*denom;return target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w);}equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}}var materialId=0;class Material extends EventDispatcher{constructor(){super();Object.defineProperty(this,'id',{value:materialId++});this.uuid=generateUUID();this.name='';this.type='Material';this.fog=true;this.blending=NormalBlending;this.side=FrontSide;this.vertexColors=false;this.opacity=1;this.format=RGBAFormat;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.stencilWriteMask=0xff;this.stencilFunc=AlwaysStencilFunc;this.stencilRef=0;this.stencilFuncMask=0xff;this.stencilFail=KeepStencilOp;this.stencilZFail=KeepStencilOp;this.stencilZPass=KeepStencilOp;this.stencilWrite=false;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.shadowSide=null;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
  this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaToCoverage=false;this.premultipliedAlpha=false;this.visible=true;this.toneMapped=true;this.userData={};this.version=0;this._alphaTest=0;}get alphaTest(){return this._alphaTest;}set alphaTest(value){if(this._alphaTest>0!==value>0){this.version++;}this._alphaTest=value;}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString();}setValues(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn('THREE.Material: \''+key+'\' parameter is undefined.');continue;}// for backward compatability if shading is set in the constructor
  if(key==='shading'){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=newValue===FlatShading?true:false;continue;}var currentValue=this[key];if(currentValue===undefined){console.warn('THREE.'+this.type+': \''+key+'\' is not a property of this material.');continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else {this[key]=newValue;}}}toJSON(meta){var isRoot=meta===undefined||typeof meta==='string';if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.sheen!==undefined)data.sheen=this.sheen;if(this.sheenColor&&this.sheenColor.isColor)data.sheenColor=this.sheenColor.getHex();if(this.sheenRoughness!==undefined)data.sheenRoughness=this.sheenRoughness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity&&this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.specularIntensity!==undefined)data.specularIntensity=this.specularIntensity;if(this.specularColor&&this.specularColor.isColor)data.specularColor=this.specularColor.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearcoat!==undefined)data.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==undefined)data.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture){data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid;}if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture){data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid;}if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid;data.clearcoatNormalScale=this.clearcoatNormalScale.toArray();}if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture){data.lightMap=this.lightMap.toJSON(meta).uuid;data.lightMapIntensity=this.lightMapIntensity;}if(this.aoMap&&this.aoMap.isTexture){data.aoMap=this.aoMap.toJSON(meta).uuid;data.aoMapIntensity=this.aoMapIntensity;}if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalMapType=this.normalMapType;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.specularIntensityMap&&this.specularIntensityMap.isTexture)data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid;if(this.specularColorMap&&this.specularColorMap.isTexture)data.specularColorMap=this.specularColorMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;if(this.combine!==undefined)data.combine=this.combine;}if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;if(this.reflectivity!==undefined)data.reflectivity=this.reflectivity;if(this.refractionRatio!==undefined)data.refractionRatio=this.refractionRatio;if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.transmission!==undefined)data.transmission=this.transmission;if(this.transmissionMap&&this.transmissionMap.isTexture)data.transmissionMap=this.transmissionMap.toJSON(meta).uuid;if(this.thickness!==undefined)data.thickness=this.thickness;if(this.thicknessMap&&this.thicknessMap.isTexture)data.thicknessMap=this.thicknessMap.toJSON(meta).uuid;if(this.attenuationDistance!==undefined)data.attenuationDistance=this.attenuationDistance;if(this.attenuationColor!==undefined)data.attenuationColor=this.attenuationColor.getHex();if(this.size!==undefined)data.size=this.size;if(this.shadowSide!==null)data.shadowSide=this.shadowSide;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors)data.vertexColors=true;if(this.opacity<1)data.opacity=this.opacity;if(this.format!==RGBAFormat)data.format=this.format;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;data.colorWrite=this.colorWrite;data.stencilWrite=this.stencilWrite;data.stencilWriteMask=this.stencilWriteMask;data.stencilFunc=this.stencilFunc;data.stencilRef=this.stencilRef;data.stencilFuncMask=this.stencilFuncMask;data.stencilFail=this.stencilFail;data.stencilZFail=this.stencilZFail;data.stencilZPass=this.stencilZPass;// rotation (SpriteMaterial)
  if(this.rotation&&this.rotation!==0)data.rotation=this.rotation;if(this.polygonOffset===true)data.polygonOffset=true;if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth&&this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.alphaToCoverage===true)data.alphaToCoverage=this.alphaToCoverage;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.flatShading===true)data.flatShading=this.flatShading;if(this.visible===false)data.visible=false;if(this.toneMapped===false)data.toneMapped=false;if(JSON.stringify(this.userData)!=='{}')data.userData=this.userData;// TODO: Copied from Object3D.toJSON
  function extractFromCache(cache){var values=[];for(var key in cache){var _data=cache[key];delete _data.metadata;values.push(_data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;}clone(){return new this.constructor().copy(this);}copy(source){this.name=source.name;this.fog=source.fog;this.blending=source.blending;this.side=source.side;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.format=source.format;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;var srcPlanes=source.clippingPlanes;var dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var _i30=0;_i30!==n;++_i30){dstPlanes[_i30]=srcPlanes[_i30].clone();}}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.alphaToCoverage=source.alphaToCoverage;this.premultipliedAlpha=source.premultipliedAlpha;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse(JSON.stringify(source.userData));return this;}dispose(){this.dispatchEvent({type:'dispose'});}set needsUpdate(value){if(value===true)this.version++;}}Material.prototype.isMaterial=true;var _colorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};var _hslA={h:0,s:0,l:0};var _hslB={h:0,s:0,l:0};function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}function SRGBToLinear(c){return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);}function LinearToSRGB(c){return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;}class Color{constructor(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
  return this.set(r);}return this.setRGB(r,g,b);}set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;}setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;}setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;}setRGB(r,g,b){this.r=r;this.g=g;this.b=b;return this;}setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
  h=euclideanModulo(h,1);s=clamp(s,0,1);l=clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else {var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;}setStyle(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)){// rgb / hsl
  var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
  this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[4]);return this;}if(color=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[4]);return this;}break;case'hsl':case'hsla':if(color=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  var h=parseFloat(color[1])/360;var s=parseInt(color[2],10)/100;var l=parseInt(color[3],10)/100;handleAlpha(color[4]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f\d]+)$/.exec(style)){// hex color
  var hex=m[1];var size=hex.length;if(size===3){// #ff0
  this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
  this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){return this.setColorName(style);}return this;}setColorName(style){// color keywords
  var hex=_colorKeywords[style.toLowerCase()];if(hex!==undefined){// red
  this.setHex(hex);}else {// unknown color
  console.warn('THREE.Color: Unknown color '+style);}return this;}clone(){return new this.constructor(this.r,this.g,this.b);}copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;}copyGammaToLinear(color){var gammaFactor=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;}copyLinearToGamma(color){var gammaFactor=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;}convertGammaToLinear(gammaFactor){this.copyGammaToLinear(this,gammaFactor);return this;}convertLinearToGamma(gammaFactor){this.copyLinearToGamma(this,gammaFactor);return this;}copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this;}copyLinearToSRGB(color){this.r=LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this;}convertSRGBToLinear(){this.copySRGBToLinear(this);return this;}convertLinearToSRGB(){this.copyLinearToSRGB(this);return this;}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;}getHexString(){return ('000000'+this.getHex().toString(16)).slice(-6);}getHSL(target){// h,s,l ranges are in 0.0 - 1.0
  var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else {var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;}getStyle(){return 'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';}offsetHSL(h,s,l){this.getHSL(_hslA);_hslA.h+=h;_hslA.s+=s;_hslA.l+=l;this.setHSL(_hslA.h,_hslA.s,_hslA.l);return this;}add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;}addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;}addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;}sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;}multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;}multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;}lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;}lerpColors(color1,color2,alpha){this.r=color1.r+(color2.r-color1.r)*alpha;this.g=color1.g+(color2.g-color1.g)*alpha;this.b=color1.b+(color2.b-color1.b)*alpha;return this;}lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);var h=lerp(_hslA.h,_hslB.h,alpha);var s=lerp(_hslA.s,_hslB.s,alpha);var l=lerp(_hslA.l,_hslB.l,alpha);this.setHSL(h,s,l);return this;}equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;}fromBufferAttribute(attribute,index){this.r=attribute.getX(index);this.g=attribute.getY(index);this.b=attribute.getZ(index);if(attribute.normalized===true){// assuming Uint8Array
  this.r/=255;this.g/=255;this.b/=255;}return this;}toJSON(){return this.getHex();}}Color.NAMES=_colorKeywords;Color.prototype.isColor=true;Color.prototype.r=1;Color.prototype.g=1;Color.prototype.b=1;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   * }
   */class MeshBasicMaterial extends Material{constructor(parameters){super();this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
  this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}MeshBasicMaterial.prototype.isMeshBasicMaterial=true;var _vector$9=/*@__PURE__*/new Vector3();var _vector2$1=/*@__PURE__*/new Vector2();class BufferAttribute{constructor(array,itemSize,normalized){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;}onUploadCallback(){}set needsUpdate(value){if(value===true)this.version++;}setUsage(value){this.usage=value;return this;}copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;return this;}copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var _i31=0,l=this.itemSize;_i31<l;_i31++){this.array[index1+_i31]=attribute.array[index2+_i31];}return this;}copyArray(array){this.array.set(array);return this;}copyColorsArray(colors){var array=this.array;var offset=0;for(var _i32=0,l=colors.length;_i32<l;_i32++){var color=colors[_i32];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',_i32);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;}copyVector2sArray(vectors){var array=this.array;var offset=0;for(var _i33=0,l=vectors.length;_i33<l;_i33++){var vector=vectors[_i33];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',_i33);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;}copyVector3sArray(vectors){var array=this.array;var offset=0;for(var _i34=0,l=vectors.length;_i34<l;_i34++){var vector=vectors[_i34];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',_i34);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;}copyVector4sArray(vectors){var array=this.array;var offset=0;for(var _i35=0,l=vectors.length;_i35<l;_i35++){var vector=vectors[_i35];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',_i35);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;}applyMatrix3(m){if(this.itemSize===2){for(var _i36=0,l=this.count;_i36<l;_i36++){_vector2$1.fromBufferAttribute(this,_i36);_vector2$1.applyMatrix3(m);this.setXY(_i36,_vector2$1.x,_vector2$1.y);}}else if(this.itemSize===3){for(var _i37=0,_l2=this.count;_i37<_l2;_i37++){_vector$9.fromBufferAttribute(this,_i37);_vector$9.applyMatrix3(m);this.setXYZ(_i37,_vector$9.x,_vector$9.y,_vector$9.z);}}return this;}applyMatrix4(m){for(var _i38=0,l=this.count;_i38<l;_i38++){_vector$9.x=this.getX(_i38);_vector$9.y=this.getY(_i38);_vector$9.z=this.getZ(_i38);_vector$9.applyMatrix4(m);this.setXYZ(_i38,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}applyNormalMatrix(m){for(var _i39=0,l=this.count;_i39<l;_i39++){_vector$9.x=this.getX(_i39);_vector$9.y=this.getY(_i39);_vector$9.z=this.getZ(_i39);_vector$9.applyNormalMatrix(m);this.setXYZ(_i39,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}transformDirection(m){for(var _i40=0,l=this.count;_i40<l;_i40++){_vector$9.x=this.getX(_i40);_vector$9.y=this.getY(_i40);_vector$9.z=this.getZ(_i40);_vector$9.transformDirection(m);this.setXYZ(_i40,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}set(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.array.set(value,offset);return this;}getX(index){return this.array[index*this.itemSize];}setX(index,x){this.array[index*this.itemSize]=x;return this;}getY(index){return this.array[index*this.itemSize+1];}setY(index,y){this.array[index*this.itemSize+1]=y;return this;}getZ(index){return this.array[index*this.itemSize+2];}setZ(index,z){this.array[index*this.itemSize+2]=z;return this;}getW(index){return this.array[index*this.itemSize+3];}setW(index,w){this.array[index*this.itemSize+3]=w;return this;}setXY(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;}setXYZ(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;}setXYZW(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;}onUpload(callback){this.onUploadCallback=callback;return this;}clone(){return new this.constructor(this.array,this.itemSize).copy(this);}toJSON(){var data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};if(this.name!=='')data.name=this.name;if(this.usage!==StaticDrawUsage)data.usage=this.usage;if(this.updateRange.offset!==0||this.updateRange.count!==-1)data.updateRange=this.updateRange;return data;}}BufferAttribute.prototype.isBufferAttribute=true;//
  class Uint16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized);}}class Uint32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint32Array(array),itemSize,normalized);}}class Float16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized);}}Float16BufferAttribute.prototype.isFloat16BufferAttribute=true;class Float32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Float32Array(array),itemSize,normalized);}}var _id=0;var _m1=/*@__PURE__*/new Matrix4();var _obj=/*@__PURE__*/new Object3D();var _offset=/*@__PURE__*/new Vector3();var _box$1=/*@__PURE__*/new Box3();var _boxMorphTargets=/*@__PURE__*/new Box3();var _vector$8=/*@__PURE__*/new Vector3();class BufferGeometry extends EventDispatcher{constructor(){super();Object.defineProperty(this,'id',{value:_id++});this.uuid=generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.morphTargetsRelative=false;this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};this.userData={};}getIndex(){return this.index;}setIndex(index){if(Array.isArray(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else {this.index=index;}return this;}getAttribute(name){return this.attributes[name];}setAttribute(name,attribute){this.attributes[name]=attribute;return this;}deleteAttribute(name){delete this.attributes[name];return this;}hasAttribute(name){return this.attributes[name]!==undefined;}addGroup(start,count){var materialIndex=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;this.groups.push({start:start,count:count,materialIndex:materialIndex});}clearGroups(){this.groups=[];}setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;}applyMatrix4(matrix){var position=this.attributes.position;if(position!==undefined){position.applyMatrix4(matrix);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix);normal.needsUpdate=true;}var tangent=this.attributes.tangent;if(tangent!==undefined){tangent.transformDirection(matrix);tangent.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;}applyQuaternion(q){_m1.makeRotationFromQuaternion(q);this.applyMatrix4(_m1);return this;}rotateX(angle){// rotate geometry around world x-axis
  _m1.makeRotationX(angle);this.applyMatrix4(_m1);return this;}rotateY(angle){// rotate geometry around world y-axis
  _m1.makeRotationY(angle);this.applyMatrix4(_m1);return this;}rotateZ(angle){// rotate geometry around world z-axis
  _m1.makeRotationZ(angle);this.applyMatrix4(_m1);return this;}translate(x,y,z){// translate geometry
  _m1.makeTranslation(x,y,z);this.applyMatrix4(_m1);return this;}scale(x,y,z){// scale geometry
  _m1.makeScale(x,y,z);this.applyMatrix4(_m1);return this;}lookAt(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this;}center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset).negate();this.translate(_offset.x,_offset.y,_offset.z);return this;}setFromPoints(points){var position=[];for(var _i41=0,l=points.length;_i41<l;_i41++){var point=points[_i41];position.push(point.x,point.y,point.z||0);}this.setAttribute('position',new Float32BufferAttribute(position,3));return this;}computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingBox.set(new Vector3(-Infinity,-Infinity,-Infinity),new Vector3(+Infinity,+Infinity,+Infinity));return;}if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);// process morph attributes if present
  if(morphAttributesPosition){for(var _i42=0,il=morphAttributesPosition.length;_i42<il;_i42++){var morphAttribute=morphAttributesPosition[_i42];_box$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(this.boundingBox.min,_box$1.min);this.boundingBox.expandByPoint(_vector$8);_vector$8.addVectors(this.boundingBox.max,_box$1.max);this.boundingBox.expandByPoint(_vector$8);}else {this.boundingBox.expandByPoint(_box$1.min);this.boundingBox.expandByPoint(_box$1.max);}}}}else {this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}}computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingSphere.set(new Vector3(),Infinity);return;}if(position){// first, find the center of the bounding sphere
  var center=this.boundingSphere.center;_box$1.setFromBufferAttribute(position);// process morph attributes if present
  if(morphAttributesPosition){for(var _i43=0,il=morphAttributesPosition.length;_i43<il;_i43++){var morphAttribute=morphAttributesPosition[_i43];_boxMorphTargets.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(_box$1.min,_boxMorphTargets.min);_box$1.expandByPoint(_vector$8);_vector$8.addVectors(_box$1.max,_boxMorphTargets.max);_box$1.expandByPoint(_vector$8);}else {_box$1.expandByPoint(_boxMorphTargets.min);_box$1.expandByPoint(_boxMorphTargets.max);}}}_box$1.getCenter(center);// second, try to find a boundingSphere with a radius smaller than the
  // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
  var maxRadiusSq=0;for(var _i44=0,_il=position.count;_i44<_il;_i44++){_vector$8.fromBufferAttribute(position,_i44);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}// process morph attributes if present
  if(morphAttributesPosition){for(var _i45=0,_il2=morphAttributesPosition.length;_i45<_il2;_i45++){var _morphAttribute=morphAttributesPosition[_i45];var morphTargetsRelative=this.morphTargetsRelative;for(var j=0,jl=_morphAttribute.count;j<jl;j++){_vector$8.fromBufferAttribute(_morphAttribute,j);if(morphTargetsRelative){_offset.fromBufferAttribute(position,j);_vector$8.add(_offset);}maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}}}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}}computeTangents(){var index=this.index;var attributes=this.attributes;// based on http://www.terathon.com/code/tangent.html
  // (per vertex tangents)
  if(index===null||attributes.position===undefined||attributes.normal===undefined||attributes.uv===undefined){console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');return;}var indices=index.array;var positions=attributes.position.array;var normals=attributes.normal.array;var uvs=attributes.uv.array;var nVertices=positions.length/3;if(attributes.tangent===undefined){this.setAttribute('tangent',new BufferAttribute(new Float32Array(4*nVertices),4));}var tangents=attributes.tangent.array;var tan1=[],tan2=[];for(var _i46=0;_i46<nVertices;_i46++){tan1[_i46]=new Vector3();tan2[_i46]=new Vector3();}var vA=new Vector3(),vB=new Vector3(),vC=new Vector3(),uvA=new Vector2(),uvB=new Vector2(),uvC=new Vector2(),sdir=new Vector3(),tdir=new Vector3();function handleTriangle(a,b,c){vA.fromArray(positions,a*3);vB.fromArray(positions,b*3);vC.fromArray(positions,c*3);uvA.fromArray(uvs,a*2);uvB.fromArray(uvs,b*2);uvC.fromArray(uvs,c*2);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);var r=1.0/(uvB.x*uvC.y-uvC.x*uvB.y);// silently ignore degenerate uv triangles having coincident or colinear vertices
  if(!isFinite(r))return;sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r);tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r);tan1[a].add(sdir);tan1[b].add(sdir);tan1[c].add(sdir);tan2[a].add(tdir);tan2[b].add(tdir);tan2[c].add(tdir);}var groups=this.groups;if(groups.length===0){groups=[{start:0,count:indices.length}];}for(var _i47=0,il=groups.length;_i47<il;++_i47){var group=groups[_i47];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){handleTriangle(indices[j+0],indices[j+1],indices[j+2]);}}var tmp=new Vector3(),tmp2=new Vector3();var n=new Vector3(),n2=new Vector3();function handleVertex(v){n.fromArray(normals,v*3);n2.copy(n);var t=tan1[v];// Gram-Schmidt orthogonalize
  tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();// Calculate handedness
  tmp2.crossVectors(n2,t);var test=tmp2.dot(tan2[v]);var w=test<0.0?-1.0:1.0;tangents[v*4]=tmp.x;tangents[v*4+1]=tmp.y;tangents[v*4+2]=tmp.z;tangents[v*4+3]=w;}for(var _i48=0,_il3=groups.length;_i48<_il3;++_i48){var _group=groups[_i48];var _start2=_group.start;var _count=_group.count;for(var _j=_start2,_jl=_start2+_count;_j<_jl;_j+=3){handleVertex(indices[_j+0]);handleVertex(indices[_j+1]);handleVertex(indices[_j+2]);}}}computeVertexNormals(){var index=this.index;var positionAttribute=this.getAttribute('position');if(positionAttribute!==undefined){var normalAttribute=this.getAttribute('normal');if(normalAttribute===undefined){normalAttribute=new BufferAttribute(new Float32Array(positionAttribute.count*3),3);this.setAttribute('normal',normalAttribute);}else {// reset existing normals to zero
  for(var _i49=0,il=normalAttribute.count;_i49<il;_i49++){normalAttribute.setXYZ(_i49,0,0,0);}}var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var nA=new Vector3(),nB=new Vector3(),nC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
  if(index){for(var _i50=0,_il4=index.count;_i50<_il4;_i50+=3){var vA=index.getX(_i50+0);var vB=index.getX(_i50+1);var vC=index.getX(_i50+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z);}}else {// non-indexed elements (unconnected triangle soup)
  for(var _i51=0,_il5=positionAttribute.count;_i51<_il5;_i51+=3){pA.fromBufferAttribute(positionAttribute,_i51+0);pB.fromBufferAttribute(positionAttribute,_i51+1);pC.fromBufferAttribute(positionAttribute,_i51+2);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normalAttribute.setXYZ(_i51+0,cb.x,cb.y,cb.z);normalAttribute.setXYZ(_i51+1,cb.x,cb.y,cb.z);normalAttribute.setXYZ(_i51+2,cb.x,cb.y,cb.z);}}this.normalizeNormals();normalAttribute.needsUpdate=true;}}merge(geometry,offset){if(!(geometry&&geometry.isBufferGeometry)){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined){offset=0;console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '+'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');}var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeOffset=attribute2.itemSize*offset;var length=Math.min(attributeArray2.length,attributeArray1.length-attributeOffset);for(var _i52=0,j=attributeOffset;_i52<length;_i52++,j++){attributeArray1[j]=attributeArray2[_i52];}}return this;}normalizeNormals(){var normals=this.attributes.normal;for(var _i53=0,il=normals.count;_i53<il;_i53++){_vector$8.fromBufferAttribute(normals,_i53);_vector$8.normalize();normals.setXYZ(_i53,_vector$8.x,_vector$8.y,_vector$8.z);}}toNonIndexed(){function convertBufferAttribute(attribute,indices){var array=attribute.array;var itemSize=attribute.itemSize;var normalized=attribute.normalized;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var _i54=0,l=indices.length;_i54<l;_i54++){if(attribute.isInterleavedBufferAttribute){index=indices[_i54]*attribute.data.stride+attribute.offset;}else {index=indices[_i54]*itemSize;}for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}return new BufferAttribute(array2,itemSize,normalized);}//
  if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;// attributes
  for(var name in attributes){var attribute=attributes[name];var newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute);}// morph attributes
  var morphAttributes=this.morphAttributes;for(var _name in morphAttributes){var morphArray=[];var morphAttribute=morphAttributes[_name];// morphAttribute: array of Float32BufferAttributes
  for(var _i55=0,il=morphAttribute.length;_i55<il;_i55++){var _attribute=morphAttribute[_i55];var _newAttribute=convertBufferAttribute(_attribute,indices);morphArray.push(_newAttribute);}geometry2.morphAttributes[_name]=morphArray;}geometry2.morphTargetsRelative=this.morphTargetsRelative;// groups
  var groups=this.groups;for(var _i56=0,l=groups.length;_i56<l;_i56++){var group=groups[_i56];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;}toJSON(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(Object.keys(this.userData).length>0)data.userData=this.userData;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}// for simplicity the code assumes attributes are not shared across geometries, see #15811
  data.data={attributes:{}};var index=this.index;if(index!==null){data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)};}var attributes=this.attributes;for(var _key in attributes){var attribute=attributes[_key];data.data.attributes[_key]=attribute.toJSON(data.data);}var morphAttributes={};var hasMorphAttributes=false;for(var _key2 in this.morphAttributes){var attributeArray=this.morphAttributes[_key2];var array=[];for(var _i57=0,il=attributeArray.length;_i57<il;_i57++){var _attribute2=attributeArray[_i57];array.push(_attribute2.toJSON(data.data));}if(array.length>0){morphAttributes[_key2]=array;hasMorphAttributes=true;}}if(hasMorphAttributes){data.data.morphAttributes=morphAttributes;data.data.morphTargetsRelative=this.morphTargetsRelative;}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;}clone(){return new this.constructor().copy(this);}copy(source){// reset
  this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// used for storing cloned, shared data
  var data={};// name
  this.name=source.name;// index
  var index=source.index;if(index!==null){this.setIndex(index.clone(data));}// attributes
  var attributes=source.attributes;for(var name in attributes){var attribute=attributes[name];this.setAttribute(name,attribute.clone(data));}// morph attributes
  var morphAttributes=source.morphAttributes;for(var _name2 in morphAttributes){var array=[];var morphAttribute=morphAttributes[_name2];// morphAttribute: array of Float32BufferAttributes
  for(var _i58=0,l=morphAttribute.length;_i58<l;_i58++){array.push(morphAttribute[_i58].clone(data));}this.morphAttributes[_name2]=array;}this.morphTargetsRelative=source.morphTargetsRelative;// groups
  var groups=source.groups;for(var _i59=0,_l3=groups.length;_i59<_l3;_i59++){var group=groups[_i59];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
  var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
  var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
  this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;// user data
  this.userData=source.userData;// geometry generator parameters
  if(source.parameters!==undefined)this.parameters=Object.assign({},source.parameters);return this;}dispose(){this.dispatchEvent({type:'dispose'});}}BufferGeometry.prototype.isBufferGeometry=true;var _inverseMatrix$2=/*@__PURE__*/new Matrix4();var _ray$2=/*@__PURE__*/new Ray();var _sphere$3=/*@__PURE__*/new Sphere();var _vA$1=/*@__PURE__*/new Vector3();var _vB$1=/*@__PURE__*/new Vector3();var _vC$1=/*@__PURE__*/new Vector3();var _tempA=/*@__PURE__*/new Vector3();var _tempB=/*@__PURE__*/new Vector3();var _tempC=/*@__PURE__*/new Vector3();var _morphA=/*@__PURE__*/new Vector3();var _morphB=/*@__PURE__*/new Vector3();var _morphC=/*@__PURE__*/new Vector3();var _uvA$1=/*@__PURE__*/new Vector2();var _uvB$1=/*@__PURE__*/new Vector2();var _uvC$1=/*@__PURE__*/new Vector2();var _intersectionPoint=/*@__PURE__*/new Vector3();var _intersectionPointWorld=/*@__PURE__*/new Vector3();class Mesh extends Object3D{constructor(){var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new BufferGeometry();var material=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new MeshBasicMaterial();super();this.type='Mesh';this.geometry=geometry;this.material=material;this.updateMorphTargets();}copy(source){super.copy(source);if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}this.material=source.material;this.geometry=source.geometry;return this;}updateMorphTargets(){var geometry=this.geometry;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphAttribute.length;m<ml;m++){var name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else {var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}}raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$3.copy(geometry.boundingSphere);_sphere$3.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(_sphere$3)===false)return;//
  _inverseMatrix$2.copy(matrixWorld).invert();_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);// Check boundingBox before continuing
  if(geometry.boundingBox!==null){if(_ray$2.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var index=geometry.index;var position=geometry.attributes.position;var morphPosition=geometry.morphAttributes.position;var morphTargetsRelative=geometry.morphTargetsRelative;var uv=geometry.attributes.uv;var uv2=geometry.attributes.uv2;var groups=geometry.groups;var drawRange=geometry.drawRange;if(index!==null){// indexed buffer geometry
  if(Array.isArray(material)){for(var _i60=0,il=groups.length;_i60<il;_i60++){var group=groups[_i60];var groupMaterial=material[group.materialIndex];var start=Math.max(group.start,drawRange.start);var end=Math.min(index.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(var j=start,jl=end;j<jl;j+=3){var a=index.getX(j);var b=index.getX(j+1);var c=index.getX(j+2);intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
  intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else {var _start3=Math.max(0,drawRange.start);var _end2=Math.min(index.count,drawRange.start+drawRange.count);for(var _i61=_start3,_il6=_end2;_i61<_il6;_i61+=3){var _a=index.getX(_i61);var _b=index.getX(_i61+1);var _c=index.getX(_i61+2);intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a,_b,_c);if(intersection){intersection.faceIndex=Math.floor(_i61/3);// triangle number in indexed buffer semantics
  intersects.push(intersection);}}}}else if(position!==undefined){// non-indexed buffer geometry
  if(Array.isArray(material)){for(var _i62=0,_il7=groups.length;_i62<_il7;_i62++){var _group2=groups[_i62];var _groupMaterial=material[_group2.materialIndex];var _start4=Math.max(_group2.start,drawRange.start);var _end3=Math.min(position.count,Math.min(_group2.start+_group2.count,drawRange.start+drawRange.count));for(var _j2=_start4,_jl2=_end3;_j2<_jl2;_j2+=3){var _a2=_j2;var _b2=_j2+1;var _c2=_j2+2;intersection=checkBufferGeometryIntersection(this,_groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a2,_b2,_c2);if(intersection){intersection.faceIndex=Math.floor(_j2/3);// triangle number in non-indexed buffer semantics
  intersection.face.materialIndex=_group2.materialIndex;intersects.push(intersection);}}}}else {var _start5=Math.max(0,drawRange.start);var _end4=Math.min(position.count,drawRange.start+drawRange.count);for(var _i63=_start5,_il8=_end4;_i63<_il8;_i63+=3){var _a3=_i63;var _b3=_i63+1;var _c3=_i63+2;intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a3,_b3,_c3);if(intersection){intersection.faceIndex=Math.floor(_i63/3);// triangle number in non-indexed buffer semantics
  intersects.push(intersection);}}}}}else if(geometry.isGeometry){console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}}Mesh.prototype.isMesh=true;function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){var intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else {intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;_intersectionPointWorld.copy(point);_intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return {distance:distance,point:_intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c){_vA$1.fromBufferAttribute(position,a);_vB$1.fromBufferAttribute(position,b);_vC$1.fromBufferAttribute(position,c);var morphInfluences=object.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(var _i64=0,il=morphPosition.length;_i64<il;_i64++){var influence=morphInfluences[_i64];var morphAttribute=morphPosition[_i64];if(influence===0)continue;_tempA.fromBufferAttribute(morphAttribute,a);_tempB.fromBufferAttribute(morphAttribute,b);_tempC.fromBufferAttribute(morphAttribute,c);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);_morphB.addScaledVector(_tempB,influence);_morphC.addScaledVector(_tempC,influence);}else {_morphA.addScaledVector(_tempA.sub(_vA$1),influence);_morphB.addScaledVector(_tempB.sub(_vB$1),influence);_morphC.addScaledVector(_tempC.sub(_vC$1),influence);}}_vA$1.add(_morphA);_vB$1.add(_morphB);_vC$1.add(_morphC);}if(object.isSkinnedMesh){object.boneTransform(a,_vA$1);object.boneTransform(b,_vB$1);object.boneTransform(c,_vC$1);}var intersection=checkIntersection(object,material,raycaster,ray,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(intersection){if(uv){_uvA$1.fromBufferAttribute(uv,a);_uvB$1.fromBufferAttribute(uv,b);_uvC$1.fromBufferAttribute(uv,c);intersection.uv=Triangle.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}if(uv2){_uvA$1.fromBufferAttribute(uv2,a);_uvB$1.fromBufferAttribute(uv2,b);_uvC$1.fromBufferAttribute(uv2,c);intersection.uv2=Triangle.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}var face={a:a,b:b,c:c,normal:new Vector3(),materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,face.normal);intersection.face=face;}return intersection;}class BoxGeometry extends BufferGeometry{constructor(){var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var widthSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var heightSegments=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;var depthSegments=arguments.length>5&&arguments[5]!==undefined?arguments[5]:1;super();this.type='BoxGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=this;// segments
  widthSegments=Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);depthSegments=Math.floor(depthSegments);// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
  buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
  buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
  buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
  buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
  buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
  buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
  // build geometry
  this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var vector=new Vector3();// generate vertices, normals and uvs
  for(var iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(var ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
  vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
  vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
  vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
  normals.push(vector.x,vector.y,vector.z);// uvs
  uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
  vertexCounter+=1;}}// indices
  // 1. you need three indices to draw a single face
  // 2. a single segment consists of two faces
  // 3. so we need to generate six (2*3) indices per segment
  for(var _iy=0;_iy<gridY;_iy++){for(var _ix=0;_ix<gridX;_ix++){var a=numberOfVertices+_ix+gridX1*_iy;var b=numberOfVertices+_ix+gridX1*(_iy+1);var c=numberOfVertices+(_ix+1)+gridX1*(_iy+1);var d=numberOfVertices+(_ix+1)+gridX1*_iy;// faces
  indices.push(a,b,d);indices.push(b,c,d);// increase counter
  groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
  groupStart+=groupCount;// update total number of vertices
  numberOfVertices+=vertexCounter;}}static fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);}}/**
   * Uniform Utilities
   */function cloneUniforms(src){var dst={};for(var u in src){dst[u]={};for(var p in src[u]){var property=src[u][p];if(property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)){dst[u][p]=property.clone();}else if(Array.isArray(property)){dst[u][p]=property.slice();}else {dst[u][p]=property;}}}return dst;}function mergeUniforms(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var _tmp=cloneUniforms(uniforms[u]);for(var p in _tmp){merged[p]=_tmp[p];}}return merged;}// Legacy
  var UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";/**
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>
   * }
   */class ShaderMaterial extends Material{constructor(parameters){super();this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader=default_vertex;this.fragmentShader=default_fragment;this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
  this.lights=false;// set to use scene lights
  this.clipping=false;// set to use user-defined clipping planes
  this.extensions={derivatives:false,// set to use derivatives
  fragDepth:false,// set to use fragment depth values
  drawBuffers:false,// set to use draw buffers
  shaderTextureLOD:false// set to use shader texture LOD
  };// When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;this.uniformsNeedUpdate=false;this.glslVersion=null;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}copy(source){super.copy(source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.extensions=Object.assign({},source.extensions);this.glslVersion=source.glslVersion;return this;}toJSON(meta){var data=super.toJSON(meta);data.glslVersion=this.glslVersion;data.uniforms={};for(var name in this.uniforms){var uniform=this.uniforms[name];var value=uniform.value;if(value&&value.isTexture){data.uniforms[name]={type:'t',value:value.toJSON(meta).uuid};}else if(value&&value.isColor){data.uniforms[name]={type:'c',value:value.getHex()};}else if(value&&value.isVector2){data.uniforms[name]={type:'v2',value:value.toArray()};}else if(value&&value.isVector3){data.uniforms[name]={type:'v3',value:value.toArray()};}else if(value&&value.isVector4){data.uniforms[name]={type:'v4',value:value.toArray()};}else if(value&&value.isMatrix3){data.uniforms[name]={type:'m3',value:value.toArray()};}else if(value&&value.isMatrix4){data.uniforms[name]={type:'m4',value:value.toArray()};}else {data.uniforms[name]={value:value};// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
  }}if(Object.keys(this.defines).length>0)data.defines=this.defines;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;var extensions={};for(var key in this.extensions){if(this.extensions[key]===true)extensions[key]=true;}if(Object.keys(extensions).length>0)data.extensions=extensions;return data;}}ShaderMaterial.prototype.isShaderMaterial=true;class Camera extends Object3D{constructor(){super();this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();this.projectionMatrixInverse=new Matrix4();}copy(source,recursive){super.copy(source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);return this;}getWorldDirection(target){this.updateWorldMatrix(true,false);var e=this.matrixWorld.elements;return target.set(-e[8],-e[9],-e[10]).normalize();}updateMatrixWorld(force){super.updateMatrixWorld(force);this.matrixWorldInverse.copy(this.matrixWorld).invert();}updateWorldMatrix(updateParents,updateChildren){super.updateWorldMatrix(updateParents,updateChildren);this.matrixWorldInverse.copy(this.matrixWorld).invert();}clone(){return new this.constructor().copy(this);}}Camera.prototype.isCamera=true;class PerspectiveCamera extends Camera{constructor(){var fov=arguments.length>0&&arguments[0]!==undefined?arguments[0]:50;var aspect=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.1;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:2000;super();this.type='PerspectiveCamera';this.fov=fov;this.zoom=1;this.near=near;this.far=far;this.focus=10;this.aspect=aspect;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
  this.filmOffset=0;// horizontal film offset (same unit as gauge)
  this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;}/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */setFocalLength(focalLength){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();}/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */getFocalLength(){var vExtentSlope=Math.tan(DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*0.5*this.fov)/this.zoom);}getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
  return this.filmGauge*Math.min(this.aspect,1);}getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
  return this.filmGauge/Math.max(this.aspect,1);}/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   const w = 1920;
  	 *   const h = 1080;
  	 *   const fullWidth = w * 3;
  	 *   const fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}updateProjectionMatrix(){var near=this.near;var top=near*Math.tan(DEG2RAD*0.5*this.fov)/this.zoom;var height=2*top;var width=this.aspect*height;var left=-0.5*width;var view=this.view;if(this.view!==null&&this.view.enabled){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){var data=super.toJSON(meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}}PerspectiveCamera.prototype.isPerspectiveCamera=true;var fov=90,aspect=1;class CubeCamera extends Object3D{constructor(near,far,renderTarget){super();this.type='CubeCamera';if(renderTarget.isWebGLCubeRenderTarget!==true){console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');return;}this.renderTarget=renderTarget;var cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.layers=this.layers;cameraPX.up.set(0,-1,0);cameraPX.lookAt(new Vector3(1,0,0));this.add(cameraPX);var cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.layers=this.layers;cameraNX.up.set(0,-1,0);cameraNX.lookAt(new Vector3(-1,0,0));this.add(cameraNX);var cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.layers=this.layers;cameraPY.up.set(0,0,1);cameraPY.lookAt(new Vector3(0,1,0));this.add(cameraPY);var cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.layers=this.layers;cameraNY.up.set(0,0,-1);cameraNY.lookAt(new Vector3(0,-1,0));this.add(cameraNY);var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.layers=this.layers;cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new Vector3(0,0,1));this.add(cameraPZ);var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.layers=this.layers;cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new Vector3(0,0,-1));this.add(cameraNZ);}update(renderer,scene){if(this.parent===null)this.updateMatrixWorld();var renderTarget=this.renderTarget;var[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=this.children;var currentXrEnabled=renderer.xr.enabled;var currentRenderTarget=renderer.getRenderTarget();renderer.xr.enabled=false;var generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderer.setRenderTarget(renderTarget,0);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,2);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4);renderer.render(scene,cameraPZ);renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget);renderer.xr.enabled=currentXrEnabled;}}class CubeTexture extends Texture{constructor(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;super(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}get images(){return this.image;}set images(value){this.image=value;}}CubeTexture.prototype.isCubeTexture=true;class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(size,options,dummy){if(Number.isInteger(options)){console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');options=dummy;}super(size,size,options);options=options||{};// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
  // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
  // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
  this.texture=new CubeTexture(undefined,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.isRenderTargetTexture=true;this.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;this.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;this.texture._needsFlipEnvMap=false;}fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type;this.texture.format=RGBAFormat;// see #18859
  this.texture.encoding=texture.encoding;this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;var shader={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:/* glsl */"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"};var geometry=new BoxGeometry(5,5,5);var material=new ShaderMaterial({name:'CubemapFromEquirect',uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;var mesh=new Mesh(geometry,material);var currentMinFilter=texture.minFilter;// Avoid blurred poles
  if(texture.minFilter===LinearMipmapLinearFilter)texture.minFilter=LinearFilter;var camera=new CubeCamera(1,10,this);camera.update(renderer,mesh);texture.minFilter=currentMinFilter;mesh.geometry.dispose();mesh.material.dispose();return this;}clear(renderer,color,depth,stencil){var currentRenderTarget=renderer.getRenderTarget();for(var _i65=0;_i65<6;_i65++){renderer.setRenderTarget(this,_i65);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(currentRenderTarget);}}WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=true;var _vector1=/*@__PURE__*/new Vector3();var _vector2=/*@__PURE__*/new Vector3();var _normalMatrix=/*@__PURE__*/new Matrix3();class Plane{constructor(){var normal=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3(1,0,0);var constant=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;// normal is assumed to be normalized
  this.normal=normal;this.constant=constant;}set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;}setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;}setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;}setFromCoplanarPoints(a,b,c){var normal=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
  this.setFromNormalAndCoplanarPoint(normal,a);return this;}copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;}normalize(){// Note: will lead to a divide by zero if the plane is invalid.
  var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;}negate(){this.constant*=-1;this.normal.negate();return this;}distanceToPoint(point){return this.normal.dot(point)+this.constant;}distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;}projectPoint(point,target){return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);}intersectLine(line,target){var direction=line.delta(_vector1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
  if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
  return null;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return null;}return target.copy(direction).multiplyScalar(t).add(line.start);}intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
  var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;}intersectsBox(box){return box.intersectsPlane(this);}intersectsSphere(sphere){return sphere.intersectsPlane(this);}coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant);}applyMatrix4(matrix,optionalNormalMatrix){var normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);var referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;}translate(offset){this.constant-=offset.dot(this.normal);return this;}equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}clone(){return new this.constructor().copy(this);}}Plane.prototype.isPlane=true;var _sphere$2=/*@__PURE__*/new Sphere();var _vector$7=/*@__PURE__*/new Vector3();class Frustum{constructor(){var p0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Plane();var p1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Plane();var p2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Plane();var p3=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Plane();var p4=arguments.length>4&&arguments[4]!==undefined?arguments[4]:new Plane();var p5=arguments.length>5&&arguments[5]!==undefined?arguments[5]:new Plane();this.planes=[p0,p1,p2,p3,p4,p5];}set(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;}copy(frustum){var planes=this.planes;for(var _i66=0;_i66<6;_i66++){planes[_i66].copy(frustum.planes[_i66]);}return this;}setFromProjectionMatrix(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;}intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(_sphere$2);}intersectsSprite(sprite){_sphere$2.center.set(0,0,0);_sphere$2.radius=0.7071067811865476;_sphere$2.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$2);}intersectsSphere(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var _i67=0;_i67<6;_i67++){var distance=planes[_i67].distanceToPoint(center);if(distance<negRadius){return false;}}return true;}intersectsBox(box){var planes=this.planes;for(var _i68=0;_i68<6;_i68++){var plane=planes[_i68];// corner at max distance
  _vector$7.x=plane.normal.x>0?box.max.x:box.min.x;_vector$7.y=plane.normal.y>0?box.max.y:box.min.y;_vector$7.z=plane.normal.z>0?box.max.z:box.min.z;if(plane.distanceToPoint(_vector$7)<0){return false;}}return true;}containsPoint(point){var planes=this.planes;for(var _i69=0;_i69<6;_i69++){if(planes[_i69].distanceToPoint(point)<0){return false;}}return true;}clone(){return new this.constructor().copy(this);}}function WebGLAnimation(){var context=null;var isAnimating=false;var animationLoop=null;var requestId=null;function onAnimationFrame(time,frame){animationLoop(time,frame);requestId=context.requestAnimationFrame(onAnimationFrame);}return {start:function(){if(isAnimating===true)return;if(animationLoop===null)return;requestId=context.requestAnimationFrame(onAnimationFrame);isAnimating=true;},stop:function(){context.cancelAnimationFrame(requestId);isAnimating=false;},setAnimationLoop:function(callback){animationLoop=callback;},setContext:function(value){context=value;}};}function WebGLAttributes(gl,capabilities){var isWebGL2=capabilities.isWebGL2;var buffers=new WeakMap();function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.usage;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type=5126;if(array instanceof Float32Array){type=5126;}else if(array instanceof Float64Array){console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');}else if(array instanceof Uint16Array){if(attribute.isFloat16BufferAttribute){if(isWebGL2){type=5131;}else {console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');}}else {type=5123;}}else if(array instanceof Int16Array){type=5122;}else if(array instanceof Uint32Array){type=5125;}else if(array instanceof Int32Array){type=5124;}else if(array instanceof Int8Array){type=5120;}else if(array instanceof Uint8Array){type=5121;}else if(array instanceof Uint8ClampedArray){type=5121;}return {buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(updateRange.count===-1){// Not using update ranges
  gl.bufferSubData(bufferType,0,array);}else {if(isWebGL2){gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array,updateRange.offset,updateRange.count);}else {gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));}updateRange.count=-1;// reset range
  }}//
  function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers.delete(attribute);}}function update(attribute,bufferType){if(attribute.isGLBufferAttribute){var cached=buffers.get(attribute);if(!cached||cached.version<attribute.version){buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});}return;}if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return {get:get,remove:remove,update:update};}class PlaneGeometry extends BufferGeometry{constructor(){var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var widthSegments=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var heightSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;super();this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments);var gridY=Math.floor(heightSegments);var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;//
  var indices=[];var vertices=[];var normals=[];var uvs=[];for(var iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(var ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}for(var _iy2=0;_iy2<gridY;_iy2++){for(var _ix2=0;_ix2<gridX;_ix2++){var a=_ix2+gridX1*_iy2;var b=_ix2+gridX1*(_iy2+1);var c=_ix2+1+gridX1*(_iy2+1);var d=_ix2+1+gridX1*_iy2;indices.push(a,b,d);indices.push(b,c,d);}}this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments);}}var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var alphatest_fragment="#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";var alphatest_pars_fragment="#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="vec3 transformed = vec3( position );";var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var bsdfs="vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var color_fragment="#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_pars_vertex="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_vertex="#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";var common="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";var defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var encodings_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";var envmap_fragment="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var envmap_common_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";var envmap_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var envmap_vertex="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var fog_vertex="#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";var lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";var envmap_physical_pars_fragment="#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";var lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";var lights_toon_pars_fragment="varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_phong_pars_fragment="varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var map_particle_pars_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";var normal_fragment_begin="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";var normal_fragment_maps="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";var normal_pars_fragment="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_pars_vertex="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_vertex="#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";var clearcoat_normal_fragment_begin="#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";var clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";var clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";var output_fragment="#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var dithering_fragment="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var dithering_pars_fragment="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var tonemapping_pars_fragment="#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";var transmission_fragment="#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";var transmission_pars_fragment="#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";var uv_pars_fragment="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";var uv_vertex="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";var vertex$g="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";var fragment$g="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$f="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";var fragment$f="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$e="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";var fragment$e="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";var vertex$d="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";var fragment$d="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";var vertex$c="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";var fragment$c="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$b="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var fragment$b="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var vertex$a="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$a="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$9="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$9="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$8="#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";var fragment$8="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$7="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";var fragment$7="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";var vertex$6="#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$6="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$5="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";var fragment$5="#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$4="#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$4="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$3="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";var fragment$3="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var vertex$2="#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$2="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var vertex$1="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var fragment$1="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,alphatest_pars_fragment:alphatest_pars_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_common_pars_fragment:envmap_common_pars_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_physical_pars_fragment:envmap_physical_pars_fragment,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars_begin:lights_pars_begin,lights_toon_fragment:lights_toon_fragment,lights_toon_pars_fragment:lights_toon_pars_fragment,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normal_pars_fragment:normal_pars_fragment,normal_pars_vertex:normal_pars_vertex,normal_vertex:normal_vertex,normalmap_pars_fragment:normalmap_pars_fragment,clearcoat_normal_fragment_begin:clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:clearcoat_normal_fragment_maps,clearcoat_pars_fragment:clearcoat_pars_fragment,output_fragment:output_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,transmission_fragment:transmission_fragment,transmission_pars_fragment:transmission_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,background_vert:vertex$g,background_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1};/**
   * Uniforms library for shared webgl shaders
   */var UniformsLib={common:{diffuse:{value:new Color(0xffffff)},opacity:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3()},uv2Transform:{value:new Matrix3()},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},// basic, lambert, phong
  ior:{value:1.5},// standard, physical
  refractionRatio:{value:0.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(0xffffff)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3()}},sprite:{diffuse:{value:new Color(0xffffff)},opacity:{value:1.0},center:{value:new Vector2(0.5,0.5)},rotation:{value:0.0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3()}}};var ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},roughness:{value:1.0},metalness:{value:0.0},envMapIntensity:{value:1}// temporary
  }]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3()},t2D:{value:null}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},/* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */cube:{uniforms:mergeUniforms([UniformsLib.envmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Color(0x000000)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Vector2()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Color(0x000000)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};function WebGLBackground(renderer,cubemaps,state,objects,premultipliedAlpha){var clearColor=new Color(0x000000);var clearAlpha=0;var planeMesh;var boxMesh;var currentBackground=null;var currentBackgroundVersion=0;var currentTonemapping=null;function render(renderList,scene){var forceClear=false;var background=scene.isScene===true?scene.background:null;if(background&&background.isTexture){background=cubemaps.get(background);}// Ignore background in AR
  // TODO: Reconsider this.
  var xr=renderer.xr;var session=xr.getSession&&xr.getSession();if(session&&session.environmentBlendMode==='additive'){background=null;}if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}if(renderer.autoClear||forceClear){renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}if(background&&(background.isCubeTexture||background.mapping===CubeUVReflectionMapping)){if(boxMesh===undefined){boxMesh=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:'BackgroundCubeMaterial',uniforms:cloneUniforms(ShaderLib.cube.uniforms),vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));boxMesh.geometry.deleteAttribute('normal');boxMesh.geometry.deleteAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};// enable code injection for non-built-in material
  Object.defineProperty(boxMesh.material,'envMap',{get:function(){return this.uniforms.envMap.value;}});objects.update(boxMesh);}boxMesh.material.uniforms.envMap.value=background;boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&background.isRenderTargetTexture===false?-1:1;if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){boxMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
  renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);}else if(background&&background.isTexture){if(planeMesh===undefined){planeMesh=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:'BackgroundMaterial',uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:false,depthWrite:false,fog:false}));planeMesh.geometry.deleteAttribute('normal');// enable code injection for non-built-in material
  Object.defineProperty(planeMesh.material,'map',{get:function(){return this.uniforms.t2D.value;}});objects.update(planeMesh);}planeMesh.material.uniforms.t2D.value=background;if(background.matrixAutoUpdate===true){background.updateMatrix();}planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){planeMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
  renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);}}function setClear(color,alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);}return {getClearColor:function(){return clearColor;},setClearColor:function(color){var alpha=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;clearColor.set(color);clearAlpha=alpha;setClear(clearColor,clearAlpha);},getClearAlpha:function(){return clearAlpha;},setClearAlpha:function(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render};}function WebGLBindingStates(gl,extensions,attributes,capabilities){var maxVertexAttributes=gl.getParameter(34921);var extension=capabilities.isWebGL2?null:extensions.get('OES_vertex_array_object');var vaoAvailable=capabilities.isWebGL2||extension!==null;var bindingStates={};var defaultState=createBindingState(null);var currentState=defaultState;function setup(object,material,program,geometry,index){var updateBuffers=false;if(vaoAvailable){var state=getBindingState(geometry,program,material);if(currentState!==state){currentState=state;bindVertexArrayObject(currentState.object);}updateBuffers=needsUpdate(geometry,index);if(updateBuffers)saveCache(geometry,index);}else {var wireframe=material.wireframe===true;if(currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==wireframe){currentState.geometry=geometry.id;currentState.program=program.id;currentState.wireframe=wireframe;updateBuffers=true;}}if(object.isInstancedMesh===true){updateBuffers=true;}if(index!==null){attributes.update(index,34963);}if(updateBuffers){setupVertexAttributes(object,material,program,geometry);if(index!==null){gl.bindBuffer(34963,attributes.get(index).buffer);}}}function createVertexArrayObject(){if(capabilities.isWebGL2)return gl.createVertexArray();return extension.createVertexArrayOES();}function bindVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.bindVertexArray(vao);return extension.bindVertexArrayOES(vao);}function deleteVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.deleteVertexArray(vao);return extension.deleteVertexArrayOES(vao);}function getBindingState(geometry,program,material){var wireframe=material.wireframe===true;var programMap=bindingStates[geometry.id];if(programMap===undefined){programMap={};bindingStates[geometry.id]=programMap;}var stateMap=programMap[program.id];if(stateMap===undefined){stateMap={};programMap[program.id]=stateMap;}var state=stateMap[wireframe];if(state===undefined){state=createBindingState(createVertexArrayObject());stateMap[wireframe]=state;}return state;}function createBindingState(vao){var newAttributes=[];var enabledAttributes=[];var attributeDivisors=[];for(var _i70=0;_i70<maxVertexAttributes;_i70++){newAttributes[_i70]=0;enabledAttributes[_i70]=0;attributeDivisors[_i70]=0;}return {// for backward compatibility on non-VAO support browser
  geometry:null,program:null,wireframe:false,newAttributes:newAttributes,enabledAttributes:enabledAttributes,attributeDivisors:attributeDivisors,object:vao,attributes:{},index:null};}function needsUpdate(geometry,index){var cachedAttributes=currentState.attributes;var geometryAttributes=geometry.attributes;var attributesNum=0;for(var key in geometryAttributes){var cachedAttribute=cachedAttributes[key];var geometryAttribute=geometryAttributes[key];if(cachedAttribute===undefined)return true;if(cachedAttribute.attribute!==geometryAttribute)return true;if(cachedAttribute.data!==geometryAttribute.data)return true;attributesNum++;}if(currentState.attributesNum!==attributesNum)return true;if(currentState.index!==index)return true;return false;}function saveCache(geometry,index){var cache={};var attributes=geometry.attributes;var attributesNum=0;for(var key in attributes){var attribute=attributes[key];var data={};data.attribute=attribute;if(attribute.data){data.data=attribute.data;}cache[key]=data;attributesNum++;}currentState.attributes=cache;currentState.attributesNum=attributesNum;currentState.index=index;}function initAttributes(){var newAttributes=currentState.newAttributes;for(var _i71=0,il=newAttributes.length;_i71<il;_i71++){newAttributes[_i71]=0;}}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0);}function enableAttributeAndDivisor(attribute,meshPerAttribute){var newAttributes=currentState.newAttributes;var enabledAttributes=currentState.enabledAttributes;var attributeDivisors=currentState.attributeDivisors;newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var _extension=capabilities.isWebGL2?gl:extensions.get('ANGLE_instanced_arrays');_extension[capabilities.isWebGL2?'vertexAttribDivisor':'vertexAttribDivisorANGLE'](attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){var newAttributes=currentState.newAttributes;var enabledAttributes=currentState.enabledAttributes;for(var _i72=0,il=enabledAttributes.length;_i72<il;_i72++){if(enabledAttributes[_i72]!==newAttributes[_i72]){gl.disableVertexAttribArray(_i72);enabledAttributes[_i72]=0;}}}function vertexAttribPointer(index,size,type,normalized,stride,offset){if(capabilities.isWebGL2===true&&(type===5124||type===5125)){gl.vertexAttribIPointer(index,size,type,stride,offset);}else {gl.vertexAttribPointer(index,size,type,normalized,stride,offset);}}function setupVertexAttributes(object,material,program,geometry){if(capabilities.isWebGL2===false&&(object.isInstancedMesh||geometry.isInstancedBufferGeometry)){if(extensions.get('ANGLE_instanced_arrays')===null)return;}initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute.location>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
  if(attribute===undefined)continue;var buffer=attribute.buffer;var type=attribute.type;var bytesPerElement=attribute.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){for(var _i73=0;_i73<programAttribute.locationSize;_i73++){enableAttributeAndDivisor(programAttribute.location+_i73,data.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=data.meshPerAttribute*data.count;}}else {for(var _i74=0;_i74<programAttribute.locationSize;_i74++){enableAttribute(programAttribute.location+_i74);}}gl.bindBuffer(34962,buffer);for(var _i75=0;_i75<programAttribute.locationSize;_i75++){vertexAttribPointer(programAttribute.location+_i75,size/programAttribute.locationSize,type,normalized,stride*bytesPerElement,(offset+size/programAttribute.locationSize*_i75)*bytesPerElement);}}else {if(geometryAttribute.isInstancedBufferAttribute){for(var _i76=0;_i76<programAttribute.locationSize;_i76++){enableAttributeAndDivisor(programAttribute.location+_i76,geometryAttribute.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else {for(var _i77=0;_i77<programAttribute.locationSize;_i77++){enableAttribute(programAttribute.location+_i77);}}gl.bindBuffer(34962,buffer);for(var _i78=0;_i78<programAttribute.locationSize;_i78++){vertexAttribPointer(programAttribute.location+_i78,size/programAttribute.locationSize,type,normalized,size*bytesPerElement,size/programAttribute.locationSize*_i78*bytesPerElement);}}}else if(materialDefaultAttributeValues!==undefined){var value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:gl.vertexAttrib2fv(programAttribute.location,value);break;case 3:gl.vertexAttrib3fv(programAttribute.location,value);break;case 4:gl.vertexAttrib4fv(programAttribute.location,value);break;default:gl.vertexAttrib1fv(programAttribute.location,value);}}}}}disableUnusedAttributes();}function dispose(){reset();for(var geometryId in bindingStates){var programMap=bindingStates[geometryId];for(var programId in programMap){var stateMap=programMap[programId];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometryId];}}function releaseStatesOfGeometry(geometry){if(bindingStates[geometry.id]===undefined)return;var programMap=bindingStates[geometry.id];for(var programId in programMap){var stateMap=programMap[programId];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometry.id];}function releaseStatesOfProgram(program){for(var geometryId in bindingStates){var programMap=bindingStates[geometryId];if(programMap[program.id]===undefined)continue;var stateMap=programMap[program.id];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[program.id];}}function reset(){resetDefaultState();if(currentState===defaultState)return;currentState=defaultState;bindVertexArrayObject(currentState.object);}// for backward-compatilibity
  function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=false;}return {setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes};}function WebGLBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawArraysInstanced';}else {extension=extensions.get('ANGLE_instanced_arrays');methodName='drawArraysInstancedANGLE';if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,start,count,primcount);info.update(count,mode,primcount);}//
  this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;if(extensions.has('EXT_texture_filter_anisotropic')===true){var extension=extensions.get('EXT_texture_filter_anisotropic');maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else {maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(35633,36338).precision>0&&gl.getShaderPrecisionFormat(35632,36338).precision>0){return 'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(35633,36337).precision>0&&gl.getShaderPrecisionFormat(35632,36337).precision>0){return 'mediump';}}return 'lowp';}/* eslint-disable no-undef */var isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&gl instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!=='undefined'&&gl instanceof WebGL2ComputeRenderingContext;/* eslint-enable no-undef */var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var drawBuffers=isWebGL2||extensions.has('WEBGL_draw_buffers');var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;var maxTextures=gl.getParameter(34930);var maxVertexTextures=gl.getParameter(35660);var maxTextureSize=gl.getParameter(3379);var maxCubemapSize=gl.getParameter(34076);var maxAttributes=gl.getParameter(34921);var maxVertexUniforms=gl.getParameter(36347);var maxVaryings=gl.getParameter(36348);var maxFragmentUniforms=gl.getParameter(36349);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=isWebGL2||extensions.has('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;var maxSamples=isWebGL2?gl.getParameter(36183):0;return {isWebGL2:isWebGL2,drawBuffers:drawBuffers,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures,maxSamples:maxSamples};}function WebGLClipping(properties){var scope=this;var globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false;var plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
  // run another frame in order to reset the state:
  numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(material,camera,useCache){var planes=material.clippingPlanes,clipIntersection=material.clipIntersection,clipShadows=material.clipShadows;var materialProperties=properties.get(material);if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
  if(renderingShadows){// there's no global clipping
  projectPlanes(null);}else {resetGlobalState();}}else {var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4;var dstArray=materialProperties.clippingState||null;uniform.value=dstArray;// ensure unique state
  dstArray=projectPlanes(planes,camera,lGlobal,useCache);for(var _i79=0;_i79!==lGlobal;++_i79){dstArray[_i79]=globalState[_i79];}materialProperties.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0;var dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var _i80=0,i4=dstOffset;_i80!==nPlanes;++_i80,i4+=4){plane.copy(planes[_i80]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray;}}function WebGLCubeMaps(renderer){var cubemaps=new WeakMap();function mapTextureMapping(texture,mapping){if(mapping===EquirectangularReflectionMapping){texture.mapping=CubeReflectionMapping;}else if(mapping===EquirectangularRefractionMapping){texture.mapping=CubeRefractionMapping;}return texture;}function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===false){var mapping=texture.mapping;if(mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping){if(cubemaps.has(texture)){var cubemap=cubemaps.get(texture).texture;return mapTextureMapping(cubemap,texture.mapping);}else {var image=texture.image;if(image&&image.height>0){var currentRenderTarget=renderer.getRenderTarget();var renderTarget=new WebGLCubeRenderTarget(image.height/2);renderTarget.fromEquirectangularTexture(renderer,texture);cubemaps.set(texture,renderTarget);renderer.setRenderTarget(currentRenderTarget);texture.addEventListener('dispose',onTextureDispose);return mapTextureMapping(renderTarget.texture,texture.mapping);}else {// image not yet ready. try the conversion next frame
  return null;}}}}return texture;}function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);var cubemap=cubemaps.get(texture);if(cubemap!==undefined){cubemaps.delete(texture);cubemap.dispose();}}function dispose(){cubemaps=new WeakMap();}return {get:get,dispose:dispose};}class OrthographicCamera extends Camera{constructor(){var left=arguments.length>0&&arguments[0]!==undefined?arguments[0]:-1;var right=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var top=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var bottom=arguments.length>3&&arguments[3]!==undefined?arguments[3]:-1;var near=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0.1;var far=arguments.length>5&&arguments[5]!==undefined?arguments[5]:2000;super();this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near;this.far=far;this.updateProjectionMatrix();}copy(source,recursive){super.copy(source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;}setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null&&this.view.enabled){var scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom;var scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX;right=left+scaleW*this.view.width;top-=scaleH*this.view.offsetY;bottom=top-scaleH*this.view.height;}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}toJSON(meta){var data=super.toJSON(meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}}OrthographicCamera.prototype.isOrthographicCamera=true;class RawShaderMaterial extends ShaderMaterial{constructor(parameters){super(parameters);this.type='RawShaderMaterial';}}RawShaderMaterial.prototype.isRawShaderMaterial=true;var LOD_MIN=4;var LOD_MAX=8;var SIZE_MAX=Math.pow(2,LOD_MAX);// The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  var EXTRA_LOD_SIGMA=[0.125,0.215,0.35,0.446,0.526,0.582];var TOTAL_LODS=LOD_MAX-LOD_MIN+1+EXTRA_LOD_SIGMA.length;// The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  var MAX_SAMPLES=20;var ENCODINGS={[LinearEncoding]:0,[sRGBEncoding]:1,[RGBEEncoding]:2,[RGBM7Encoding]:3,[RGBM16Encoding]:4,[RGBDEncoding]:5,[GammaEncoding]:6};var _flatCamera=/*@__PURE__*/new OrthographicCamera();var{_lodPlanes,_sizeLods,_sigmas}=/*@__PURE__*/_createPlanes();var _clearColor=/*@__PURE__*/new Color();var _oldTarget=null;// Golden Ratio
  var PHI=(1+Math.sqrt(5))/2;var INV_PHI=1/PHI;// Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  var _axisDirections=[/*@__PURE__*/new Vector3(1,1,1),/*@__PURE__*/new Vector3(-1,1,1),/*@__PURE__*/new Vector3(1,1,-1),/*@__PURE__*/new Vector3(-1,1,-1),/*@__PURE__*/new Vector3(0,PHI,INV_PHI),/*@__PURE__*/new Vector3(0,PHI,-INV_PHI),/*@__PURE__*/new Vector3(INV_PHI,0,PHI),/*@__PURE__*/new Vector3(-INV_PHI,0,PHI),/*@__PURE__*/new Vector3(PHI,INV_PHI,0),/*@__PURE__*/new Vector3(-PHI,INV_PHI,0)];/**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting
   * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
  */class PMREMGenerator{constructor(renderer){this._renderer=renderer;this._pingPongRenderTarget=null;this._blurMaterial=_getBlurShader(MAX_SAMPLES);this._equirectShader=null;this._cubemapShader=null;this._compileMaterial(this._blurMaterial);}/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
  	 * is placed at the origin).
  	 */fromScene(scene){var sigma=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.1;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;_oldTarget=this._renderer.getRenderTarget();var cubeUVRenderTarget=this._allocateTargets();this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget);if(sigma>0){this._blur(cubeUVRenderTarget,0,0,sigma);}this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */fromEquirectangular(equirectangular){return this._fromTexture(equirectangular);}/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */fromCubemap(cubemap){return this._fromTexture(cubemap);}/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */compileCubemapShader(){if(this._cubemapShader===null){this._cubemapShader=_getCubemapShader();this._compileMaterial(this._cubemapShader);}}/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */compileEquirectangularShader(){if(this._equirectShader===null){this._equirectShader=_getEquirectShader();this._compileMaterial(this._equirectShader);}}/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */dispose(){this._blurMaterial.dispose();if(this._cubemapShader!==null)this._cubemapShader.dispose();if(this._equirectShader!==null)this._equirectShader.dispose();for(var _i81=0;_i81<_lodPlanes.length;_i81++){_lodPlanes[_i81].dispose();}}// private interface
  _cleanup(outputTarget){this._pingPongRenderTarget.dispose();this._renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=false;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height);}_fromTexture(texture){_oldTarget=this._renderer.getRenderTarget();var cubeUVRenderTarget=this._allocateTargets(texture);this._textureToCubeUV(texture,cubeUVRenderTarget);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}_allocateTargets(texture){// warning: null texture is valid
  var params={magFilter:NearestFilter,minFilter:NearestFilter,generateMipmaps:false,type:UnsignedByteType,format:RGBEFormat,encoding:_isLDR(texture)?texture.encoding:RGBEEncoding,depthBuffer:false};var cubeUVRenderTarget=_createRenderTarget(params);cubeUVRenderTarget.depthBuffer=texture?false:true;this._pingPongRenderTarget=_createRenderTarget(params);return cubeUVRenderTarget;}_compileMaterial(material){var tmpMesh=new Mesh(_lodPlanes[0],material);this._renderer.compile(tmpMesh,_flatCamera);}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget){var fov=90;var aspect=1;var cubeCamera=new PerspectiveCamera(fov,aspect,near,far);var upSign=[1,-1,1,1,1,1];var forwardSign=[1,1,1,-1,-1,-1];var renderer=this._renderer;var originalAutoClear=renderer.autoClear;var outputEncoding=renderer.outputEncoding;var toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);renderer.toneMapping=NoToneMapping;renderer.outputEncoding=LinearEncoding;renderer.autoClear=false;var backgroundMaterial=new MeshBasicMaterial({name:'PMREM.Background',side:BackSide,depthWrite:false,depthTest:false});var backgroundBox=new Mesh(new BoxGeometry(),backgroundMaterial);var useSolidColor=false;var background=scene.background;if(background){if(background.isColor){backgroundMaterial.color.copy(background);scene.background=null;useSolidColor=true;}}else {backgroundMaterial.color.copy(_clearColor);useSolidColor=true;}for(var _i82=0;_i82<6;_i82++){var col=_i82%3;if(col==0){cubeCamera.up.set(0,upSign[_i82],0);cubeCamera.lookAt(forwardSign[_i82],0,0);}else if(col==1){cubeCamera.up.set(0,0,upSign[_i82]);cubeCamera.lookAt(0,forwardSign[_i82],0);}else {cubeCamera.up.set(0,upSign[_i82],0);cubeCamera.lookAt(0,0,forwardSign[_i82]);}_setViewport(cubeUVRenderTarget,col*SIZE_MAX,_i82>2?SIZE_MAX:0,SIZE_MAX,SIZE_MAX);renderer.setRenderTarget(cubeUVRenderTarget);if(useSolidColor){renderer.render(backgroundBox,cubeCamera);}renderer.render(scene,cubeCamera);}backgroundBox.geometry.dispose();backgroundBox.material.dispose();renderer.toneMapping=toneMapping;renderer.outputEncoding=outputEncoding;renderer.autoClear=originalAutoClear;scene.background=background;}_setEncoding(uniform,texture){if(this._renderer.capabilities.isWebGL2===true&&texture.format===RGBAFormat&&texture.type===UnsignedByteType&&texture.encoding===sRGBEncoding){uniform.value=ENCODINGS[LinearEncoding];}else {uniform.value=ENCODINGS[texture.encoding];}}_textureToCubeUV(texture,cubeUVRenderTarget){var renderer=this._renderer;var isCubeTexture=texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping;if(isCubeTexture){if(this._cubemapShader==null){this._cubemapShader=_getCubemapShader();}}else {if(this._equirectShader==null){this._equirectShader=_getEquirectShader();}}var material=isCubeTexture?this._cubemapShader:this._equirectShader;var mesh=new Mesh(_lodPlanes[0],material);var uniforms=material.uniforms;uniforms['envMap'].value=texture;if(!isCubeTexture){uniforms['texelSize'].value.set(1.0/texture.image.width,1.0/texture.image.height);}this._setEncoding(uniforms['inputEncoding'],texture);this._setEncoding(uniforms['outputEncoding'],cubeUVRenderTarget.texture);_setViewport(cubeUVRenderTarget,0,0,3*SIZE_MAX,2*SIZE_MAX);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(mesh,_flatCamera);}_applyPMREM(cubeUVRenderTarget){var renderer=this._renderer;var autoClear=renderer.autoClear;renderer.autoClear=false;for(var _i83=1;_i83<TOTAL_LODS;_i83++){var sigma=Math.sqrt(_sigmas[_i83]*_sigmas[_i83]-_sigmas[_i83-1]*_sigmas[_i83-1]);var poleAxis=_axisDirections[(_i83-1)%_axisDirections.length];this._blur(cubeUVRenderTarget,_i83-1,_i83,sigma,poleAxis);}renderer.autoClear=autoClear;}/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 */_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){var pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,'latitudinal',poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,'longitudinal',poleAxis);}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){var renderer=this._renderer;var blurMaterial=this._blurMaterial;if(direction!=='latitudinal'&&direction!=='longitudinal'){console.error('blur direction must be either latitudinal or longitudinal!');}// Number of standard deviations at which to cut off the discrete approximation.
  var STANDARD_DEVIATIONS=3;var blurMesh=new Mesh(_lodPlanes[lodOut],blurMaterial);var blurUniforms=blurMaterial.uniforms;var pixels=_sizeLods[lodIn]-1;var radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1);var sigmaPixels=sigmaRadians/radiansPerPixel;var samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;if(samples>MAX_SAMPLES){console.warn("sigmaRadians, ".concat(sigmaRadians,", is too large and will clip, as it requested ").concat(samples," samples when the maximum is set to ").concat(MAX_SAMPLES));}var weights=[];var sum=0;for(var _i84=0;_i84<MAX_SAMPLES;++_i84){var _x2=_i84/sigmaPixels;var weight=Math.exp(-_x2*_x2/2);weights.push(weight);if(_i84==0){sum+=weight;}else if(_i84<samples){sum+=2*weight;}}for(var _i85=0;_i85<weights.length;_i85++){weights[_i85]=weights[_i85]/sum;}blurUniforms['envMap'].value=targetIn.texture;blurUniforms['samples'].value=samples;blurUniforms['weights'].value=weights;blurUniforms['latitudinal'].value=direction==='latitudinal';if(poleAxis){blurUniforms['poleAxis'].value=poleAxis;}blurUniforms['dTheta'].value=radiansPerPixel;blurUniforms['mipInt'].value=LOD_MAX-lodIn;this._setEncoding(blurUniforms['inputEncoding'],targetIn.texture);this._setEncoding(blurUniforms['outputEncoding'],targetIn.texture);var outputSize=_sizeLods[lodOut];var x=3*Math.max(0,SIZE_MAX-2*outputSize);var y=(lodOut===0?0:2*SIZE_MAX)+2*outputSize*(lodOut>LOD_MAX-LOD_MIN?lodOut-LOD_MAX+LOD_MIN:0);_setViewport(targetOut,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera);}}function _isLDR(texture){if(texture===undefined||texture.type!==UnsignedByteType)return false;return texture.encoding===LinearEncoding||texture.encoding===sRGBEncoding||texture.encoding===GammaEncoding;}function _createPlanes(){var _lodPlanes=[];var _sizeLods=[];var _sigmas=[];var lod=LOD_MAX;for(var _i86=0;_i86<TOTAL_LODS;_i86++){var sizeLod=Math.pow(2,lod);_sizeLods.push(sizeLod);var sigma=1.0/sizeLod;if(_i86>LOD_MAX-LOD_MIN){sigma=EXTRA_LOD_SIGMA[_i86-LOD_MAX+LOD_MIN-1];}else if(_i86==0){sigma=0;}_sigmas.push(sigma);var texelSize=1.0/(sizeLod-1);var min=-texelSize/2;var max=1+texelSize/2;var uv1=[min,min,max,min,max,max,min,min,max,max,min,max];var cubeFaces=6;var vertices=6;var positionSize=3;var uvSize=2;var faceIndexSize=1;var position=new Float32Array(positionSize*vertices*cubeFaces);var uv=new Float32Array(uvSize*vertices*cubeFaces);var faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(var face=0;face<cubeFaces;face++){var x=face%3*2/3-1;var y=face>2?0:-1;var coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0];position.set(coordinates,positionSize*vertices*face);uv.set(uv1,uvSize*vertices*face);var fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face);}var planes=new BufferGeometry();planes.setAttribute('position',new BufferAttribute(position,positionSize));planes.setAttribute('uv',new BufferAttribute(uv,uvSize));planes.setAttribute('faceIndex',new BufferAttribute(faceIndex,faceIndexSize));_lodPlanes.push(planes);if(lod>LOD_MIN){lod--;}}return {_lodPlanes,_sizeLods,_sigmas};}function _createRenderTarget(params){var cubeUVRenderTarget=new WebGLRenderTarget(3*SIZE_MAX,3*SIZE_MAX,params);cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping;cubeUVRenderTarget.texture.name='PMREM.cubeUv';cubeUVRenderTarget.scissorTest=true;return cubeUVRenderTarget;}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height);}function _getBlurShader(maxSamples){var weights=new Float32Array(maxSamples);var poleAxis=new Vector3(0,1,0);var shaderMaterial=new RawShaderMaterial({name:'SphericalGaussianBlur',defines:{'n':maxSamples},uniforms:{'envMap':{value:null},'samples':{value:1},'weights':{value:weights},'latitudinal':{value:false},'dTheta':{value:0},'mipInt':{value:0},'poleAxis':{value:poleAxis},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t".concat(_getEncodings(),"\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getEquirectShader(){var texelSize=new Vector2(1,1);var shaderMaterial=new RawShaderMaterial({name:'EquirectangularToCubeUV',uniforms:{'envMap':{value:null},'texelSize':{value:texelSize},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t".concat(_getEncodings(),"\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getCubemapShader(){var shaderMaterial=new RawShaderMaterial({name:'CubemapToCubeUV',uniforms:{'envMap':{value:null},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t".concat(_getEncodings(),"\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getCommonVertexShader(){return(/* glsl */"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t");}function _getEncodings(){return(/* glsl */"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t");}function WebGLCubeUVMaps(renderer){var cubeUVmaps=new WeakMap();var pmremGenerator=null;function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===false){var mapping=texture.mapping;var isEquirectMap=mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping;var isCubeMap=mapping===CubeReflectionMapping||mapping===CubeRefractionMapping;if(isEquirectMap||isCubeMap){// equirect/cube map to cubeUV conversion
  if(cubeUVmaps.has(texture)){return cubeUVmaps.get(texture).texture;}else {var image=texture.image;if(isEquirectMap&&image&&image.height>0||isCubeMap&&image&&isCubeTextureComplete(image)){var currentRenderTarget=renderer.getRenderTarget();if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);var renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture);cubeUVmaps.set(texture,renderTarget);renderer.setRenderTarget(currentRenderTarget);texture.addEventListener('dispose',onTextureDispose);return renderTarget.texture;}else {// image not yet ready. try the conversion next frame
  return null;}}}}return texture;}function isCubeTextureComplete(image){var count=0;var length=6;for(var _i87=0;_i87<length;_i87++){if(image[_i87]!==undefined)count++;}return count===length;}function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);var cubemapUV=cubeUVmaps.get(texture);if(cubemapUV!==undefined){cubeUVmaps.delete(texture);cubemapUV.dispose();}}function dispose(){cubeUVmaps=new WeakMap();if(pmremGenerator!==null){pmremGenerator.dispose();pmremGenerator=null;}}return {get:get,dispose:dispose};}function WebGLExtensions(gl){var extensions={};function getExtension(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}extensions[name]=extension;return extension;}return {has:function(name){return getExtension(name)!==null;},init:function(capabilities){if(capabilities.isWebGL2){getExtension('EXT_color_buffer_float');}else {getExtension('WEBGL_depth_texture');getExtension('OES_texture_float');getExtension('OES_texture_half_float');getExtension('OES_texture_half_float_linear');getExtension('OES_standard_derivatives');getExtension('OES_element_index_uint');getExtension('OES_vertex_array_object');getExtension('ANGLE_instanced_arrays');}getExtension('OES_texture_float_linear');getExtension('EXT_color_buffer_half_float');},get:function(name){var extension=getExtension(name);if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}return extension;}};}function WebGLGeometries(gl,attributes,info,bindingStates){var geometries={};var wireframeAttributes=new WeakMap();function onGeometryDispose(event){var geometry=event.target;if(geometry.index!==null){attributes.remove(geometry.index);}for(var name in geometry.attributes){attributes.remove(geometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];var attribute=wireframeAttributes.get(geometry);if(attribute){attributes.remove(attribute);wireframeAttributes.delete(geometry);}bindingStates.releaseStatesOfGeometry(geometry);if(geometry.isInstancedBufferGeometry===true){delete geometry._maxInstanceCount;}//
  info.memory.geometries--;}function get(object,geometry){if(geometries[geometry.id]===true)return geometry;geometry.addEventListener('dispose',onGeometryDispose);geometries[geometry.id]=true;info.memory.geometries++;return geometry;}function update(geometry){var geometryAttributes=geometry.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
  for(var name in geometryAttributes){attributes.update(geometryAttributes[name],34962);}// morph targets
  var morphAttributes=geometry.morphAttributes;for(var _name3 in morphAttributes){var array=morphAttributes[_name3];for(var _i88=0,l=array.length;_i88<l;_i88++){attributes.update(array[_i88],34962);}}}function updateWireframeAttribute(geometry){var indices=[];var geometryIndex=geometry.index;var geometryPosition=geometry.attributes.position;var version=0;if(geometryIndex!==null){var array=geometryIndex.array;version=geometryIndex.version;for(var _i89=0,l=array.length;_i89<l;_i89+=3){var a=array[_i89+0];var b=array[_i89+1];var c=array[_i89+2];indices.push(a,b,b,c,c,a);}}else {var _array=geometryPosition.array;version=geometryPosition.version;for(var _i90=0,_l4=_array.length/3-1;_i90<_l4;_i90+=3){var _a4=_i90+0;var _b4=_i90+1;var _c4=_i90+2;indices.push(_a4,_b4,_b4,_c4,_c4,_a4);}}var attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attribute.version=version;// Updating index buffer in VAO now. See WebGLBindingStates
  //
  var previousAttribute=wireframeAttributes.get(geometry);if(previousAttribute)attributes.remove(previousAttribute);//
  wireframeAttributes.set(geometry,attribute);}function getWireframeAttribute(geometry){var currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){var geometryIndex=geometry.index;if(geometryIndex!==null){// if the attribute is obsolete, create a new one
  if(currentAttribute.version<geometryIndex.version){updateWireframeAttribute(geometry);}}}else {updateWireframeAttribute(geometry);}return wireframeAttributes.get(geometry);}return {get:get,update:update,getWireframeAttribute:getWireframeAttribute};}function WebGLIndexedBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}var type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawElementsInstanced';}else {extension=extensions.get('ANGLE_instanced_arrays');methodName='drawElementsInstancedANGLE';if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,count,type,start*bytesPerElement,primcount);info.update(count,mode,primcount);}//
  this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}function WebGLInfo(gl){var memory={geometries:0,textures:0};var render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){render.calls++;switch(mode){case 4:render.triangles+=instanceCount*(count/3);break;case 1:render.lines+=instanceCount*(count/2);break;case 3:render.lines+=instanceCount*(count-1);break;case 2:render.lines+=instanceCount*count;break;case 0:render.points+=instanceCount*count;break;default:console.error('THREE.WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.frame++;render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return {memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}class DataTexture2DArray extends Texture{constructor(){var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var depth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;super(null);this.image={data,width,height,depth};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.needsUpdate=true;}}DataTexture2DArray.prototype.isDataTexture2DArray=true;function numericalSort(a,b){return a[0]-b[0];}function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1]);}function denormalize(morph,attribute){var denominator=1;var array=attribute.isInterleavedBufferAttribute?attribute.data.array:attribute.array;if(array instanceof Int8Array)denominator=127;else if(array instanceof Int16Array)denominator=32767;else if(array instanceof Int32Array)denominator=2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ',array);morph.divideScalar(denominator);}function WebGLMorphtargets(gl,capabilities,textures){var influencesList={};var morphInfluences=new Float32Array(8);var morphTextures=new WeakMap();var morph=new Vector3();var workInfluences=[];for(var _i91=0;_i91<8;_i91++){workInfluences[_i91]=[_i91,0];}function update(object,geometry,material,program){var objectInfluences=object.morphTargetInfluences;if(capabilities.isWebGL2===true){// instead of using attributes, the WebGL 2 code path encodes morph targets
  // into an array of data textures. Each layer represents a single morph target.
  var numberOfMorphTargets=geometry.morphAttributes.position.length;var entry=morphTextures.get(geometry);if(entry===undefined||entry.count!==numberOfMorphTargets){if(entry!==undefined)entry.texture.dispose();var hasMorphNormals=geometry.morphAttributes.normal!==undefined;var morphTargets=geometry.morphAttributes.position;var morphNormals=geometry.morphAttributes.normal||[];var numberOfVertices=geometry.attributes.position.count;var numberOfVertexData=hasMorphNormals===true?2:1;// (v,n) vs. (v)
  var width=numberOfVertices*numberOfVertexData;var height=1;if(width>capabilities.maxTextureSize){height=Math.ceil(width/capabilities.maxTextureSize);width=capabilities.maxTextureSize;}var buffer=new Float32Array(width*height*4*numberOfMorphTargets);var texture=new DataTexture2DArray(buffer,width,height,numberOfMorphTargets);texture.format=RGBAFormat;// using RGBA since RGB might be emulated (and is thus slower)
  texture.type=FloatType;// fill buffer
  var vertexDataStride=numberOfVertexData*4;for(var _i92=0;_i92<numberOfMorphTargets;_i92++){var morphTarget=morphTargets[_i92];var morphNormal=morphNormals[_i92];var offset=width*height*4*_i92;for(var j=0;j<morphTarget.count;j++){morph.fromBufferAttribute(morphTarget,j);if(morphTarget.normalized===true)denormalize(morph,morphTarget);var stride=j*vertexDataStride;buffer[offset+stride+0]=morph.x;buffer[offset+stride+1]=morph.y;buffer[offset+stride+2]=morph.z;buffer[offset+stride+3]=0;if(hasMorphNormals===true){morph.fromBufferAttribute(morphNormal,j);if(morphNormal.normalized===true)denormalize(morph,morphNormal);buffer[offset+stride+4]=morph.x;buffer[offset+stride+5]=morph.y;buffer[offset+stride+6]=morph.z;buffer[offset+stride+7]=0;}}}entry={count:numberOfMorphTargets,texture:texture,size:new Vector2(width,height)};morphTextures.set(geometry,entry);}//
  var morphInfluencesSum=0;for(var _i93=0;_i93<objectInfluences.length;_i93++){morphInfluencesSum+=objectInfluences[_i93];}var morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',objectInfluences);program.getUniforms().setValue(gl,'morphTargetsTexture',entry.texture,textures);program.getUniforms().setValue(gl,'morphTargetsTextureSize',entry.size);}else {// When object doesn't have morph target influences defined, we treat it as a 0-length array
  // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
  var length=objectInfluences===undefined?0:objectInfluences.length;var influences=influencesList[geometry.id];if(influences===undefined||influences.length!==length){// initialise list
  influences=[];for(var _i94=0;_i94<length;_i94++){influences[_i94]=[_i94,0];}influencesList[geometry.id]=influences;}// Collect influences
  for(var _i95=0;_i95<length;_i95++){var influence=influences[_i95];influence[0]=_i95;influence[1]=objectInfluences[_i95];}influences.sort(absNumericalSort);for(var _i96=0;_i96<8;_i96++){if(_i96<length&&influences[_i96][1]){workInfluences[_i96][0]=influences[_i96][0];workInfluences[_i96][1]=influences[_i96][1];}else {workInfluences[_i96][0]=Number.MAX_SAFE_INTEGER;workInfluences[_i96][1]=0;}}workInfluences.sort(numericalSort);var _morphTargets=geometry.morphAttributes.position;var _morphNormals=geometry.morphAttributes.normal;var _morphInfluencesSum=0;for(var _i97=0;_i97<8;_i97++){var _influence=workInfluences[_i97];var index=_influence[0];var value=_influence[1];if(index!==Number.MAX_SAFE_INTEGER&&value){if(_morphTargets&&geometry.getAttribute('morphTarget'+_i97)!==_morphTargets[index]){geometry.setAttribute('morphTarget'+_i97,_morphTargets[index]);}if(_morphNormals&&geometry.getAttribute('morphNormal'+_i97)!==_morphNormals[index]){geometry.setAttribute('morphNormal'+_i97,_morphNormals[index]);}morphInfluences[_i97]=value;_morphInfluencesSum+=value;}else {if(_morphTargets&&geometry.hasAttribute('morphTarget'+_i97)===true){geometry.deleteAttribute('morphTarget'+_i97);}if(_morphNormals&&geometry.hasAttribute('morphNormal'+_i97)===true){geometry.deleteAttribute('morphNormal'+_i97);}morphInfluences[_i97]=0;}}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
  // This allows us to switch between absolute morphs and relative morphs without changing shader code
  // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
  var _morphBaseInfluence=geometry.morphTargetsRelative?1:1-_morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',_morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);}}return {update:update};}function WebGLObjects(gl,geometries,attributes,info){var updateMap=new WeakMap();function update(object){var frame=info.render.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
  if(updateMap.get(buffergeometry)!==frame){geometries.update(buffergeometry);updateMap.set(buffergeometry,frame);}if(object.isInstancedMesh){if(object.hasEventListener('dispose',onInstancedMeshDispose)===false){object.addEventListener('dispose',onInstancedMeshDispose);}attributes.update(object.instanceMatrix,34962);if(object.instanceColor!==null){attributes.update(object.instanceColor,34962);}}return buffergeometry;}function dispose(){updateMap=new WeakMap();}function onInstancedMeshDispose(event){var instancedMesh=event.target;instancedMesh.removeEventListener('dispose',onInstancedMeshDispose);attributes.remove(instancedMesh.instanceMatrix);if(instancedMesh.instanceColor!==null)attributes.remove(instancedMesh.instanceColor);}return {update:update,dispose:dispose};}class DataTexture3D extends Texture{constructor(){var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var depth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;// We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	const texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839
  super(null);this.image={data,width,height,depth};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.needsUpdate=true;}}DataTexture3D.prototype.isDataTexture3D=true;/**
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [textures] )
   *
   * 		uploads a uniform value(s)
   *  	the 'textures' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (textures factorizations):
   *
   * .upload( gl, seq, values, textures )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (textures factorizations):
   *
   * .setValue( gl, name, value, textures )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */var emptyTexture=new Texture();var emptyTexture2dArray=new DataTexture2DArray();var emptyTexture3d=new DataTexture3D();var emptyCubeTexture=new CubeTexture();// --- Utilities ---
  // Array Caches (provide typed arrays for temporary by size)
  var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
  var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);var mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
  function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983
  var n=nBlocks*blockSize;var r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var _i98=1,offset=0;_i98!==nBlocks;++_i98){offset+=blockSize;array[_i98].toArray(r,offset);}}return r;}function arraysEqual(a,b){if(a.length!==b.length)return false;for(var _i99=0,l=a.length;_i99<l;_i99++){if(a[_i99]!==b[_i99])return false;}return true;}function copyArray(a,b){for(var _i100=0,l=b.length;_i100<l;_i100++){a[_i100]=b[_i100];}}// Texture unit allocation
  function allocTexUnits(textures,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var _i101=0;_i101!==n;++_i101){r[_i101]=textures.allocateTextureUnit();}return r;}// --- Setters ---
  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.
  // Single scalar
  function setValueV1f(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1f(this.addr,v);cache[0]=v;}// Single float vector (from flat array or THREE.VectorN)
  function setValueV2f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2f(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2fv(this.addr,v);copyArray(cache,v);}}function setValueV3f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3f(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else if(v.r!==undefined){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){gl.uniform3f(this.addr,v.r,v.g,v.b);cache[0]=v.r;cache[1]=v.g;cache[2]=v.b;}}else {if(arraysEqual(cache,v))return;gl.uniform3fv(this.addr,v);copyArray(cache,v);}}function setValueV4f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4fv(this.addr,v);copyArray(cache,v);}}// Single matrix (from flat array or THREE.MatrixN)
  function setValueM2(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix2fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat2array.set(elements);gl.uniformMatrix2fv(this.addr,false,mat2array);copyArray(cache,elements);}}function setValueM3(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix3fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat3array.set(elements);gl.uniformMatrix3fv(this.addr,false,mat3array);copyArray(cache,elements);}}function setValueM4(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix4fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat4array.set(elements);gl.uniformMatrix4fv(this.addr,false,mat4array);copyArray(cache,elements);}}// Single integer / boolean
  function setValueV1i(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1i(this.addr,v);cache[0]=v;}// Single integer / boolean vector (from flat array)
  function setValueV2i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2iv(this.addr,v);copyArray(cache,v);}function setValueV3i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3iv(this.addr,v);copyArray(cache,v);}function setValueV4i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4iv(this.addr,v);copyArray(cache,v);}// Single unsigned integer
  function setValueV1ui(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1ui(this.addr,v);cache[0]=v;}// Single unsigned integer vector (from flat array)
  function setValueV2ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2uiv(this.addr,v);copyArray(cache,v);}function setValueV3ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3uiv(this.addr,v);copyArray(cache,v);}function setValueV4ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4uiv(this.addr,v);copyArray(cache,v);}// Single texture (2D / Cube)
  function setValueT1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTexture2D(v||emptyTexture,unit);}function setValueT3D1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture3D(v||emptyTexture3d,unit);}function setValueT6(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTextureCube(v||emptyCubeTexture,unit);}function setValueT2DArray1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2DArray(v||emptyTexture2dArray,unit);}// Helper to pick the right setter for the singular case
  function getSingularSetter(type){switch(type){case 0x1406:return setValueV1f;// FLOAT
  case 0x8b50:return setValueV2f;// _VEC2
  case 0x8b51:return setValueV3f;// _VEC3
  case 0x8b52:return setValueV4f;// _VEC4
  case 0x8b5a:return setValueM2;// _MAT2
  case 0x8b5b:return setValueM3;// _MAT3
  case 0x8b5c:return setValueM4;// _MAT4
  case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
  case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
  case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
  case 0x1405:return setValueV1ui;// UINT
  case 0x8dc6:return setValueV2ui;// _VEC2
  case 0x8dc7:return setValueV3ui;// _VEC3
  case 0x8dc8:return setValueV4ui;// _VEC4
  case 0x8b5e:// SAMPLER_2D
  case 0x8d66:// SAMPLER_EXTERNAL_OES
  case 0x8dca:// INT_SAMPLER_2D
  case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
  case 0x8b62:// SAMPLER_2D_SHADOW
  return setValueT1;case 0x8b5f:// SAMPLER_3D
  case 0x8dcb:// INT_SAMPLER_3D
  case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
  return setValueT3D1;case 0x8b60:// SAMPLER_CUBE
  case 0x8dcc:// INT_SAMPLER_CUBE
  case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
  case 0x8dc5:// SAMPLER_CUBE_SHADOW
  return setValueT6;case 0x8dc1:// SAMPLER_2D_ARRAY
  case 0x8dcf:// INT_SAMPLER_2D_ARRAY
  case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
  case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
  return setValueT2DArray1;}}// Array of scalars
  function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v);}// Array of vectors (from flat array or array of THREE.VectorN)
  function setValueV2fArray(gl,v){var data=flatten(v,this.size,2);gl.uniform2fv(this.addr,data);}function setValueV3fArray(gl,v){var data=flatten(v,this.size,3);gl.uniform3fv(this.addr,data);}function setValueV4fArray(gl,v){var data=flatten(v,this.size,4);gl.uniform4fv(this.addr,data);}// Array of matrices (from flat array or array of THREE.MatrixN)
  function setValueM2Array(gl,v){var data=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,false,data);}function setValueM3Array(gl,v){var data=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,false,data);}function setValueM4Array(gl,v){var data=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,false,data);}// Array of integer / boolean
  function setValueV1iArray(gl,v){gl.uniform1iv(this.addr,v);}// Array of integer / boolean vectors (from flat array)
  function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v);}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v);}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v);}// Array of unsigned integer
  function setValueV1uiArray(gl,v){gl.uniform1uiv(this.addr,v);}// Array of unsigned integer vectors (from flat array)
  function setValueV2uiArray(gl,v){gl.uniform2uiv(this.addr,v);}function setValueV3uiArray(gl,v){gl.uniform3uiv(this.addr,v);}function setValueV4uiArray(gl,v){gl.uniform4uiv(this.addr,v);}// Array of textures (2D / Cube)
  function setValueT1Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var _i102=0;_i102!==n;++_i102){textures.safeSetTexture2D(v[_i102]||emptyTexture,units[_i102]);}}function setValueT6Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var _i103=0;_i103!==n;++_i103){textures.safeSetTextureCube(v[_i103]||emptyCubeTexture,units[_i103]);}}// Helper to pick the right setter for a pure (bottom-level) array
  function getPureArraySetter(type){switch(type){case 0x1406:return setValueV1fArray;// FLOAT
  case 0x8b50:return setValueV2fArray;// _VEC2
  case 0x8b51:return setValueV3fArray;// _VEC3
  case 0x8b52:return setValueV4fArray;// _VEC4
  case 0x8b5a:return setValueM2Array;// _MAT2
  case 0x8b5b:return setValueM3Array;// _MAT3
  case 0x8b5c:return setValueM4Array;// _MAT4
  case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
  case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
  case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
  case 0x1405:return setValueV1uiArray;// UINT
  case 0x8dc6:return setValueV2uiArray;// _VEC2
  case 0x8dc7:return setValueV3uiArray;// _VEC3
  case 0x8dc8:return setValueV4uiArray;// _VEC4
  case 0x8b5e:// SAMPLER_2D
  case 0x8d66:// SAMPLER_EXTERNAL_OES
  case 0x8dca:// INT_SAMPLER_2D
  case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
  case 0x8b62:// SAMPLER_2D_SHADOW
  return setValueT1Array;case 0x8b60:// SAMPLER_CUBE
  case 0x8dcc:// INT_SAMPLER_CUBE
  case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
  case 0x8dc5:// SAMPLER_CUBE_SHADOW
  return setValueT6Array;}}// --- Uniform Classes ---
  function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  }function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  }PureArrayUniform.prototype.updateCache=function(data){var cache=this.cache;if(data instanceof Float32Array&&cache.length!==data.length){this.cache=new Float32Array(data.length);}copyArray(cache,data);};function StructuredUniform(id){this.id=id;this.seq=[];this.map={};}StructuredUniform.prototype.setValue=function(gl,value,textures){var seq=this.seq;for(var _i104=0,n=seq.length;_i104!==n;++_i104){var u=seq[_i104];u.setValue(gl,value[u.id],textures);}};// --- Top-level ---
  // Parser - builds up the property tree from the path strings
  var RePathPart=/(\w+)(\])?(\[|\.)?/g;// extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.
  function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
  RePathPart.lastIndex=0;while(true){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex;var id=match[1];var idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
  if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
  addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else {// step into inner node / create it in case it doesn't exist
  var map=container.map;var next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
  function WebGLUniforms(gl,program){this.seq=[];this.map={};var n=gl.getProgramParameter(program,35718);for(var _i105=0;_i105<n;++_i105){var info=gl.getActiveUniform(program,_i105),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value,textures){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,textures);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
  WebGLUniforms.upload=function(gl,seq,values,textures){for(var _i106=0,n=seq.length;_i106!==n;++_i106){var u=seq[_i106],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
  u.setValue(gl,v.value,textures);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var _i107=0,n=seq.length;_i107!==n;++_i107){var u=seq[_i107];if(u.id in values)r.push(u);}return r;};function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);return shader;}var programIdCount=0;function addLineNumbers(string){var lines=string.split('\n');for(var _i108=0;_i108<lines.length;_i108++){lines[_i108]=_i108+1+': '+lines[_i108];}return lines.join('\n');}function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return ['Linear','( value )'];case sRGBEncoding:return ['sRGB','( value )'];case RGBEEncoding:return ['RGBE','( value )'];case RGBM7Encoding:return ['RGBM','( value, 7.0 )'];case RGBM16Encoding:return ['RGBM','( value, 16.0 )'];case RGBDEncoding:return ['RGBD','( value, 256.0 )'];case GammaEncoding:return ['Gamma','( value, float( GAMMA_FACTOR ) )'];case LogLuvEncoding:return ['LogLuv','( value )'];default:console.warn('THREE.WebGLProgram: Unsupported encoding:',encoding);return ['Linear','( value )'];}}function getShaderErrors(gl,shader,type){var status=gl.getShaderParameter(shader,35713);var errors=gl.getShaderInfoLog(shader).trim();if(status&&errors==='')return '';// --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
  return type.toUpperCase()+'\n\n'+errors+'\n\n'+addLineNumbers(gl.getShaderSource(shader));}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return 'vec4 '+functionName+'( vec4 value ) { return '+components[0]+'ToLinear'+components[1]+'; }';}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return 'vec4 '+functionName+'( vec4 value ) { return LinearTo'+components[0]+components[1]+'; }';}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case CineonToneMapping:toneMappingName='OptimizedCineon';break;case ACESFilmicToneMapping:toneMappingName='ACESFilmic';break;case CustomToneMapping:toneMappingName='Custom';break;default:console.warn('THREE.WebGLProgram: Unsupported toneMapping:',toneMapping);toneMappingName='Linear';}return 'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}function generateExtensions(parameters){var chunks=[parameters.extensionDerivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.tangentSpaceNormalMap||parameters.clearcoatNormalMap||parameters.flatShading||parameters.shaderID==='physical'?'#extension GL_OES_standard_derivatives : enable':'',(parameters.extensionFragDepth||parameters.logarithmicDepthBuffer)&&parameters.rendererExtensionFragDepth?'#extension GL_EXT_frag_depth : enable':'',parameters.extensionDrawBuffers&&parameters.rendererExtensionDrawBuffers?'#extension GL_EXT_draw_buffers : require':'',(parameters.extensionShaderTextureLOD||parameters.envMap||parameters.transmission)&&parameters.rendererExtensionShaderTextureLod?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){var attributes={};var n=gl.getProgramParameter(program,35721);for(var _i109=0;_i109<n;_i109++){var info=gl.getActiveAttrib(program,_i109);var name=info.name;var locationSize=1;if(info.type===35674)locationSize=2;if(info.type===35675)locationSize=3;if(info.type===35676)locationSize=4;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
  attributes[name]={type:info.type,location:gl.getAttribLocation(program,name),locationSize:locationSize};}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}// Resolve Includes
  var includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer);}function includeReplacer(match,include){var string=ShaderChunk[include];if(string===undefined){throw new Error('Can not resolve #include <'+include+'>');}return resolveIncludes(string);}// Unroll Loops
  var deprecatedUnrollLoopPattern=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;var unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer).replace(deprecatedUnrollLoopPattern,deprecatedLoopReplacer);}function deprecatedLoopReplacer(match,start,end,snippet){console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');return loopReplacer(match,start,end,snippet);}function loopReplacer(match,start,end,snippet){var string='';for(var _i110=parseInt(start);_i110<parseInt(end);_i110++){string+=snippet.replace(/\[\s*i\s*\]/g,'[ '+_i110+' ]').replace(/UNROLLED_LOOP_INDEX/g,_i110);}return string;}//
  function generatePrecision(parameters){var precisionstring='precision '+parameters.precision+' float;\nprecision '+parameters.precision+' int;';if(parameters.precision==='highp'){precisionstring+='\n#define HIGH_PRECISION';}else if(parameters.precision==='mediump'){precisionstring+='\n#define MEDIUM_PRECISION';}else if(parameters.precision==='lowp'){precisionstring+='\n#define LOW_PRECISION';}return precisionstring;}function generateShadowMapTypeDefine(parameters){var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}else if(parameters.shadowMapType===VSMShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_VSM';}return shadowMapTypeDefine;}function generateEnvMapTypeDefine(parameters){var envMapTypeDefine='ENVMAP_TYPE_CUBE';if(parameters.envMap){switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;}}return envMapTypeDefine;}function generateEnvMapModeDefine(parameters){var envMapModeDefine='ENVMAP_MODE_REFLECTION';if(parameters.envMap){switch(parameters.envMapMode){case CubeRefractionMapping:case CubeUVRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}}return envMapModeDefine;}function generateEnvMapBlendingDefine(parameters){var envMapBlendingDefine='ENVMAP_BLENDING_NONE';if(parameters.envMap){switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}return envMapBlendingDefine;}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){// TODO Send this event to Three.js DevTools
  // console.log( 'WebGLProgram', cacheKey );
  var gl=renderer.getContext();var defines=parameters.defines;var vertexShader=parameters.vertexShader;var fragmentShader=parameters.fragmentShader;var shadowMapTypeDefine=generateShadowMapTypeDefine(parameters);var envMapTypeDefine=generateEnvMapTypeDefine(parameters);var envMapModeDefine=generateEnvMapModeDefine(parameters);var envMapBlendingDefine=generateEnvMapBlendingDefine(parameters);var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;var customExtensions=parameters.isWebGL2?'':generateExtensions(parameters);var customDefines=generateDefines(defines);var program=gl.createProgram();var prefixVertex,prefixFragment;var versionString=parameters.glslVersion?'#version '+parameters.glslVersion+'\n':'';if(parameters.isRawShaderMaterial){prefixVertex=[customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=[customExtensions,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else {prefixVertex=[generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.instancing?'#define USE_INSTANCING':'',parameters.instancingColor?'#define USE_INSTANCING_COLOR':'',parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularColorMap?'#define USE_SPECULARCOLORMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.sheenColorMap?'#define USE_SHEENCOLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEENROUGHNESSMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.morphTargets&&parameters.isWebGL2?'#define MORPHTARGETS_TEXTURE':'',parameters.morphTargets&&parameters.isWebGL2?'#define MORPHTARGETS_COUNT '+parameters.morphTargetsCount:'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;','#ifdef USE_INSTANCING','	attribute mat4 instanceMatrix;','#endif','#ifdef USE_INSTANCING_COLOR','	attribute vec3 instanceColor;','#endif','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_TANGENT','	attribute vec4 tangent;','#endif','#if defined( USE_COLOR_ALPHA )','	attribute vec4 color;','#elif defined( USE_COLOR )','	attribute vec3 color;','#endif','#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,'#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.matcap?'#define USE_MATCAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoat?'#define USE_CLEARCOAT':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularColorMap?'#define USE_SPECULARCOLORMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.alphaTest?'#define USE_ALPHATEST':'',parameters.sheen?'#define USE_SHEEN':'',parameters.sheenColorMap?'#define USE_SHEENCOLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEENROUGHNESSMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors||parameters.instancingColor?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'',(parameters.extensionShaderTextureLOD||parameters.envMap)&&parameters.rendererExtensionShaderTextureLod?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
  parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.format===RGBFormat?'#define OPAQUE':'',ShaderChunk['encodings_pars_fragment'],// this code is required here because it is used by the various encoding/decoding function defined below
  parameters.map?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.matcap?getTexelDecodingFunction('matcapTexelToLinear',parameters.matcapEncoding):'',parameters.envMap?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMap?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.specularColorMap?getTexelDecodingFunction('specularColorMapTexelToLinear',parameters.specularColorMapEncoding):'',parameters.sheenColorMap?getTexelDecodingFunction('sheenColorMapTexelToLinear',parameters.sheenColorMapEncoding):'',parameters.lightMap?getTexelDecodingFunction('lightMapTexelToLinear',parameters.lightMapEncoding):'',getTexelEncodingFunction('linearToOutputTexel',parameters.outputEncoding),parameters.depthPacking?'#define DEPTH_PACKING '+parameters.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=resolveIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=resolveIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);if(parameters.isWebGL2&&parameters.isRawShaderMaterial!==true){// GLSL 3.0 conversion for built-in materials and ShaderMaterial
  versionString='#version 300 es\n';prefixVertex=['precision mediump sampler2DArray;','#define attribute in','#define varying out','#define texture2D texture'].join('\n')+'\n'+prefixVertex;prefixFragment=['#define varying in',parameters.glslVersion===GLSL3?'':'out highp vec4 pc_fragColor;',parameters.glslVersion===GLSL3?'':'#define gl_FragColor pc_fragColor','#define gl_FragDepthEXT gl_FragDepth','#define texture2D texture','#define textureCube texture','#define texture2DProj textureProj','#define texture2DLodEXT textureLod','#define texture2DProjLodEXT textureProjLod','#define textureCubeLodEXT textureLod','#define texture2DGradEXT textureGrad','#define texture2DProjGradEXT textureProjGrad','#define textureCubeGradEXT textureGrad'].join('\n')+'\n'+prefixFragment;}var vertexGlsl=versionString+prefixVertex+vertexShader;var fragmentGlsl=versionString+prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );
  var glVertexShader=WebGLShader(gl,35633,vertexGlsl);var glFragmentShader=WebGLShader(gl,35632,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
  if(parameters.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,parameters.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
  gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);// check for link errors
  if(renderer.debug.checkShaderErrors){var programLog=gl.getProgramInfoLog(program).trim();var vertexLog=gl.getShaderInfoLog(glVertexShader).trim();var fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();var runnable=true;var haveDiagnostics=true;if(gl.getProgramParameter(program,35714)===false){runnable=false;var vertexErrors=getShaderErrors(gl,glVertexShader,'vertex');var fragmentErrors=getShaderErrors(gl,glFragmentShader,'fragment');console.error('THREE.WebGLProgram: Shader Error '+gl.getError()+' - '+'VALIDATE_STATUS '+gl.getProgramParameter(program,35715)+'\n\n'+'Program Info Log: '+programLog+'\n'+vertexErrors+'\n'+fragmentErrors);}else if(programLog!==''){console.warn('THREE.WebGLProgram: Program Info Log:',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}}// Clean up
  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );
  gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
  var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program);}return cachedUniforms;};// set up caching for attribute locations
  var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
  this.destroy=function(){bindingStates.releaseStatesOfProgram(this);gl.deleteProgram(program);this.program=undefined;};//
  this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping){var programs=[];var isWebGL2=capabilities.isWebGL2;var logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer;var floatVertexTextures=capabilities.floatVertexTextures;var maxVertexUniforms=capabilities.maxVertexUniforms;var vertexTextures=capabilities.vertexTextures;var precision=capabilities.precision;var shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'toon',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshMatcapMaterial:'matcap',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow',SpriteMaterial:'sprite'};var parameterNames=['precision','isWebGL2','supportsVertexTextures','outputEncoding','instancing','instancingColor','map','mapEncoding','matcap','matcapEncoding','envMap','envMapMode','envMapEncoding','envMapCubeUV','lightMap','lightMapEncoding','aoMap','emissiveMap','emissiveMapEncoding','bumpMap','normalMap','objectSpaceNormalMap','tangentSpaceNormalMap','clearcoat','clearcoatMap','clearcoatRoughnessMap','clearcoatNormalMap','displacementMap','specularMap',,'roughnessMap','metalnessMap','gradientMap','alphaMap','alphaTest','combine','vertexColors','vertexAlphas','vertexTangents','vertexUvs','uvsVertexOnly','fog','useFog','fogExp2','flatShading','sizeAttenuation','logarithmicDepthBuffer','skinning','maxBones','useVertexTexture','morphTargets','morphNormals','morphTargetsCount','premultipliedAlpha','numDirLights','numPointLights','numSpotLights','numHemiLights','numRectAreaLights','numDirLightShadows','numPointLightShadows','numSpotLightShadows','shadowMapEnabled','shadowMapType','toneMapping','physicallyCorrectLights','doubleSided','flipSided','numClippingPlanes','numClipIntersection','depthPacking','dithering','format','specularIntensityMap','specularColorMap','specularColorMapEncoding','transmission','transmissionMap','thicknessMap','sheen','sheenColorMap','sheenColorMapEncoding','sheenRoughnessMap'];function getMaxBones(object){var skeleton=object.skeleton;var bones=skeleton.bones;if(floatVertexTextures){return 1024;}else {// default for when object is not specified
  // ( for example when prebuilding shader to be used with multiple objects )
  //
  //  - leave some extra space for other uniforms
  //  - limit here is ANGLE's 254 max uniform vectors
  //    (up to 54 should be safe)
  var nVertexUniforms=maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');return 0;}return maxBones;}}function getTextureEncodingFromMap(map){var encoding;if(map&&map.isTexture){encoding=map.encoding;}else if(map&&map.isWebGLRenderTarget){console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');encoding=map.texture.encoding;}else {encoding=LinearEncoding;}if(isWebGL2&&map&&map.isTexture&&map.format===RGBAFormat&&map.type===UnsignedByteType&&map.encoding===sRGBEncoding){encoding=LinearEncoding;// disable inline decode for sRGB textures in WebGL 2
  }return encoding;}function getParameters(material,lights,shadows,scene,object){var fog=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null;var envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
  // (not to blow over maxLights budget)
  var maxBones=object.isSkinnedMesh?getMaxBones(object):0;if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var vertexShader,fragmentShader;if(shaderID){var shader=ShaderLib[shaderID];vertexShader=shader.vertexShader;fragmentShader=shader.fragmentShader;}else {vertexShader=material.vertexShader;fragmentShader=material.fragmentShader;}var currentRenderTarget=renderer.getRenderTarget();var useAlphaTest=material.alphaTest>0;var useClearcoat=material.clearcoat>0;var parameters={isWebGL2:isWebGL2,shaderID:shaderID,shaderName:material.type,vertexShader:vertexShader,fragmentShader:fragmentShader,defines:material.defines,isRawShaderMaterial:material.isRawShaderMaterial===true,glslVersion:material.glslVersion,precision:precision,instancing:object.isInstancedMesh===true,instancingColor:object.isInstancedMesh===true&&object.instanceColor!==null,supportsVertexTextures:vertexTextures,outputEncoding:currentRenderTarget!==null?getTextureEncodingFromMap(currentRenderTarget.texture):renderer.outputEncoding,map:!!material.map,mapEncoding:getTextureEncodingFromMap(material.map),matcap:!!material.matcap,matcapEncoding:getTextureEncodingFromMap(material.matcap),envMap:!!envMap,envMapMode:envMap&&envMap.mapping,envMapEncoding:getTextureEncodingFromMap(envMap),envMapCubeUV:!!envMap&&(envMap.mapping===CubeUVReflectionMapping||envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,lightMapEncoding:getTextureEncodingFromMap(material.lightMap),aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,objectSpaceNormalMap:material.normalMapType===ObjectSpaceNormalMap,tangentSpaceNormalMap:material.normalMapType===TangentSpaceNormalMap,clearcoat:useClearcoat,clearcoatMap:useClearcoat&&!!material.clearcoatMap,clearcoatRoughnessMap:useClearcoat&&!!material.clearcoatRoughnessMap,clearcoatNormalMap:useClearcoat&&!!material.clearcoatNormalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,specularIntensityMap:!!material.specularIntensityMap,specularColorMap:!!material.specularColorMap,specularColorMapEncoding:getTextureEncodingFromMap(material.specularColorMap),alphaMap:!!material.alphaMap,alphaTest:useAlphaTest,gradientMap:!!material.gradientMap,sheen:material.sheen>0,sheenColorMap:!!material.sheenColorMap,sheenColorMapEncoding:getTextureEncodingFromMap(material.sheenColorMap),sheenRoughnessMap:!!material.sheenRoughnessMap,transmission:material.transmission>0,transmissionMap:!!material.transmissionMap,thicknessMap:!!material.thicknessMap,combine:material.combine,vertexTangents:!!material.normalMap&&!!object.geometry&&!!object.geometry.attributes.tangent,vertexColors:material.vertexColors,vertexAlphas:material.vertexColors===true&&!!object.geometry&&!!object.geometry.attributes.color&&object.geometry.attributes.color.itemSize===4,vertexUvs:!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatMap||!!material.clearcoatRoughnessMap||!!material.clearcoatNormalMap||!!material.displacementMap||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularColorMap||!!material.sheenColorMap||material.sheenRoughnessMap,uvsVertexOnly:!(!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatNormalMap||material.transmission>0||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularColorMap||!!material.sheen>0||!!material.sheenColorMap||!!material.sheenRoughnessMap)&&!!material.displacementMap,fog:!!fog,useFog:material.fog,fogExp2:fog&&fog.isFogExp2,flatShading:!!material.flatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:logarithmicDepthBuffer,skinning:object.isSkinnedMesh===true&&maxBones>0,maxBones:maxBones,useVertexTexture:floatVertexTextures,morphTargets:!!object.geometry&&!!object.geometry.morphAttributes.position,morphNormals:!!object.geometry&&!!object.geometry.morphAttributes.normal,morphTargetsCount:!!object.geometry&&!!object.geometry.morphAttributes.position?object.geometry.morphAttributes.position.length:0,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,format:material.format,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:material.toneMapped?renderer.toneMapping:NoToneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false,index0AttributeName:material.index0AttributeName,extensionDerivatives:material.extensions&&material.extensions.derivatives,extensionFragDepth:material.extensions&&material.extensions.fragDepth,extensionDrawBuffers:material.extensions&&material.extensions.drawBuffers,extensionShaderTextureLOD:material.extensions&&material.extensions.shaderTextureLOD,rendererExtensionFragDepth:isWebGL2||extensions.has('EXT_frag_depth'),rendererExtensionDrawBuffers:isWebGL2||extensions.has('WEBGL_draw_buffers'),rendererExtensionShaderTextureLod:isWebGL2||extensions.has('EXT_shader_texture_lod'),customProgramCacheKey:material.customProgramCacheKey()};return parameters;}function getProgramCacheKey(parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else {array.push(hashString(parameters.fragmentShader));array.push(hashString(parameters.vertexShader));}if(parameters.defines!==undefined){for(var name in parameters.defines){array.push(name);array.push(parameters.defines[name]);}}if(parameters.isRawShaderMaterial===false){for(var _i111=0;_i111<parameterNames.length;_i111++){array.push(parameters[parameterNames[_i111]]);}array.push(renderer.outputEncoding);array.push(renderer.gammaFactor);}array.push(parameters.customProgramCacheKey);return array.join();}function getUniforms(material){var shaderID=shaderIDs[material.type];var uniforms;if(shaderID){var shader=ShaderLib[shaderID];uniforms=UniformsUtils.clone(shader.uniforms);}else {uniforms=material.uniforms;}return uniforms;}function acquireProgram(parameters,cacheKey){var program;// Check if code has been already compiled
  for(var p=0,pl=programs.length;p<pl;p++){var preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates);programs.push(program);}return program;}function releaseProgram(program){if(--program.usedTimes===0){// Remove from unordered set
  var _i112=programs.indexOf(program);programs[_i112]=programs[programs.length-1];programs.pop();// Free WebGL resources
  program.destroy();}}return {getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,// Exposed for resource monitoring & error feedback via renderer.info:
  programs:programs};}function WebGLProperties(){var properties=new WeakMap();function get(object){var map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties.delete(object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new WeakMap();}return {get:get,remove:remove,update:update,dispose:dispose};}function painterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else {return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else {return a.id-b.id;}}function WebGLRenderList(properties){var renderItems=[];var renderItemsIndex=0;var opaque=[];var transmissive=[];var transparent=[];var defaultProgram={id:-1};function init(){renderItemsIndex=0;opaque.length=0;transmissive.length=0;transparent.length=0;}function getNextRenderItem(object,geometry,material,groupOrder,z,group){var renderItem=renderItems[renderItemsIndex];var materialProperties=properties.get(material);if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,program:materialProperties.program||defaultProgram,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else {renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=materialProperties.program||defaultProgram;renderItem.groupOrder=groupOrder;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}renderItemsIndex++;return renderItem;}function push(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.push(renderItem);}else if(material.transparent===true){transparent.push(renderItem);}else {opaque.push(renderItem);}}function unshift(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.unshift(renderItem);}else if(material.transparent===true){transparent.unshift(renderItem);}else {opaque.unshift(renderItem);}}function sort(customOpaqueSort,customTransparentSort){if(opaque.length>1)opaque.sort(customOpaqueSort||painterSortStable);if(transmissive.length>1)transmissive.sort(customTransparentSort||reversePainterSortStable);if(transparent.length>1)transparent.sort(customTransparentSort||reversePainterSortStable);}function finish(){// Clear references from inactive renderItems in the list
  for(var _i113=renderItemsIndex,il=renderItems.length;_i113<il;_i113++){var renderItem=renderItems[_i113];if(renderItem.id===null)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.program=null;renderItem.group=null;}}return {opaque:opaque,transmissive:transmissive,transparent:transparent,init:init,push:push,unshift:unshift,finish:finish,sort:sort};}function WebGLRenderLists(properties){var lists=new WeakMap();function get(scene,renderCallDepth){var list;if(lists.has(scene)===false){list=new WebGLRenderList(properties);lists.set(scene,[list]);}else {if(renderCallDepth>=lists.get(scene).length){list=new WebGLRenderList(properties);lists.get(scene).push(list);}else {list=lists.get(scene)[renderCallDepth];}}return list;}function dispose(){lists=new WeakMap();}return {get:get,dispose:dispose};}function UniformsCache(){var lights={};return {get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case'PointLight':uniforms={position:new Vector3(),color:new Color(),distance:0,decay:0};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()};break;}lights[light.id]=uniforms;return uniforms;}};}function ShadowUniformsCache(){var lights={};return {get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraNear:1,shadowCameraFar:1000};break;// TODO (abelnation): set RectAreaLight shadow uniforms
  }lights[light.id]=uniforms;return uniforms;}};}var nextVersion=0;function shadowCastingLightsFirst(lightA,lightB){return (lightB.castShadow?1:0)-(lightA.castShadow?1:0);}function WebGLLights(extensions,capabilities){var cache=new UniformsCache();var shadowCache=ShadowUniformsCache();var state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(var _i114=0;_i114<9;_i114++){state.probe.push(new Vector3());}var vector3=new Vector3();var matrix4=new Matrix4();var matrix42=new Matrix4();function setup(lights,physicallyCorrectLights){var r=0,g=0,b=0;for(var _i115=0;_i115<9;_i115++){state.probe[_i115].set(0,0,0);}var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var numDirectionalShadows=0;var numPointShadows=0;var numSpotShadows=0;lights.sort(shadowCastingLightsFirst);// artist-friendly light intensity scaling factor
  var scaleFactor=physicallyCorrectLights!==true?Math.PI:1;for(var _i116=0,l=lights.length;_i116<l;_i116++){var light=lights[_i116];var color=light.color;var intensity=light.intensity;var distance=light.distance;var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity*scaleFactor;g+=color.g*intensity*scaleFactor;b+=color.b*intensity*scaleFactor;}else if(light.isLightProbe){for(var j=0;j<9;j++){state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);}}else if(light.isDirectionalLight){var uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor);if(light.castShadow){var shadow=light.shadow;var shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.directionalShadow[directionalLength]=shadowUniforms;state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;numDirectionalShadows++;}state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var _uniforms=cache.get(light);_uniforms.position.setFromMatrixPosition(light.matrixWorld);_uniforms.color.copy(color).multiplyScalar(intensity*scaleFactor);_uniforms.distance=distance;_uniforms.coneCos=Math.cos(light.angle);_uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));_uniforms.decay=light.decay;if(light.castShadow){var _shadow=light.shadow;var _shadowUniforms=shadowCache.get(light);_shadowUniforms.shadowBias=_shadow.bias;_shadowUniforms.shadowNormalBias=_shadow.normalBias;_shadowUniforms.shadowRadius=_shadow.radius;_shadowUniforms.shadowMapSize=_shadow.mapSize;state.spotShadow[spotLength]=_shadowUniforms;state.spotShadowMap[spotLength]=shadowMap;state.spotShadowMatrix[spotLength]=light.shadow.matrix;numSpotShadows++;}state.spot[spotLength]=_uniforms;spotLength++;}else if(light.isRectAreaLight){var _uniforms2=cache.get(light);// (a) intensity is the total visible light emitted
  //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
  // (b) intensity is the brightness of the light
  _uniforms2.color.copy(color).multiplyScalar(intensity);_uniforms2.halfWidth.set(light.width*0.5,0.0,0.0);_uniforms2.halfHeight.set(0.0,light.height*0.5,0.0);state.rectArea[rectAreaLength]=_uniforms2;rectAreaLength++;}else if(light.isPointLight){var _uniforms3=cache.get(light);_uniforms3.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor);_uniforms3.distance=light.distance;_uniforms3.decay=light.decay;if(light.castShadow){var _shadow2=light.shadow;var _shadowUniforms2=shadowCache.get(light);_shadowUniforms2.shadowBias=_shadow2.bias;_shadowUniforms2.shadowNormalBias=_shadow2.normalBias;_shadowUniforms2.shadowRadius=_shadow2.radius;_shadowUniforms2.shadowMapSize=_shadow2.mapSize;_shadowUniforms2.shadowCameraNear=_shadow2.camera.near;_shadowUniforms2.shadowCameraFar=_shadow2.camera.far;state.pointShadow[pointLength]=_shadowUniforms2;state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;numPointShadows++;}state.point[pointLength]=_uniforms3;pointLength++;}else if(light.isHemisphereLight){var _uniforms4=cache.get(light);_uniforms4.skyColor.copy(light.color).multiplyScalar(intensity*scaleFactor);_uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity*scaleFactor);state.hemi[hemiLength]=_uniforms4;hemiLength++;}}if(rectAreaLength>0){if(capabilities.isWebGL2){// WebGL 2
  state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else {// WebGL 1
  if(extensions.has('OES_texture_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else if(extensions.has('OES_texture_half_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_HALF_1;state.rectAreaLTC2=UniformsLib.LTC_HALF_2;}else {console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');}}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;var hash=state.hash;if(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows){state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.directionalShadow.length=numDirectionalShadows;state.directionalShadowMap.length=numDirectionalShadows;state.pointShadow.length=numPointShadows;state.pointShadowMap.length=numPointShadows;state.spotShadow.length=numSpotShadows;state.spotShadowMap.length=numSpotShadows;state.directionalShadowMatrix.length=numDirectionalShadows;state.pointShadowMatrix.length=numPointShadows;state.spotShadowMatrix.length=numSpotShadows;hash.directionalLength=directionalLength;hash.pointLength=pointLength;hash.spotLength=spotLength;hash.rectAreaLength=rectAreaLength;hash.hemiLength=hemiLength;hash.numDirectionalShadows=numDirectionalShadows;hash.numPointShadows=numPointShadows;hash.numSpotShadows=numSpotShadows;state.version=nextVersion++;}}function setupView(lights,camera){var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var viewMatrix=camera.matrixWorldInverse;for(var _i117=0,l=lights.length;_i117<l;_i117++){var light=lights[_i117];if(light.isDirectionalLight){var uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);directionalLength++;}else if(light.isSpotLight){var _uniforms5=state.spot[spotLength];_uniforms5.position.setFromMatrixPosition(light.matrixWorld);_uniforms5.position.applyMatrix4(viewMatrix);_uniforms5.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);_uniforms5.direction.sub(vector3);_uniforms5.direction.transformDirection(viewMatrix);spotLength++;}else if(light.isRectAreaLight){var _uniforms6=state.rectArea[rectAreaLength];_uniforms6.position.setFromMatrixPosition(light.matrixWorld);_uniforms6.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
  matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);_uniforms6.halfWidth.set(light.width*0.5,0.0,0.0);_uniforms6.halfHeight.set(0.0,light.height*0.5,0.0);_uniforms6.halfWidth.applyMatrix4(matrix42);_uniforms6.halfHeight.applyMatrix4(matrix42);rectAreaLength++;}else if(light.isPointLight){var _uniforms7=state.point[pointLength];_uniforms7.position.setFromMatrixPosition(light.matrixWorld);_uniforms7.position.applyMatrix4(viewMatrix);pointLength++;}else if(light.isHemisphereLight){var _uniforms8=state.hemi[hemiLength];_uniforms8.direction.setFromMatrixPosition(light.matrixWorld);_uniforms8.direction.transformDirection(viewMatrix);_uniforms8.direction.normalize();hemiLength++;}}}return {setup:setup,setupView:setupView,state:state};}function WebGLRenderState(extensions,capabilities){var lights=new WebGLLights(extensions,capabilities);var lightsArray=[];var shadowsArray=[];function init(){lightsArray.length=0;shadowsArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function setupLights(physicallyCorrectLights){lights.setup(lightsArray,physicallyCorrectLights);}function setupLightsView(camera){lights.setupView(lightsArray,camera);}var state={lightsArray:lightsArray,shadowsArray:shadowsArray,lights:lights};return {init:init,state:state,setupLights:setupLights,setupLightsView:setupLightsView,pushLight:pushLight,pushShadow:pushShadow};}function WebGLRenderStates(extensions,capabilities){var renderStates=new WeakMap();function get(scene){var renderCallDepth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var renderState;if(renderStates.has(scene)===false){renderState=new WebGLRenderState(extensions,capabilities);renderStates.set(scene,[renderState]);}else {if(renderCallDepth>=renderStates.get(scene).length){renderState=new WebGLRenderState(extensions,capabilities);renderStates.get(scene).push(renderState);}else {renderState=renderStates.get(scene)[renderCallDepth];}}return renderState;}function dispose(){renderStates=new WeakMap();}return {get:get,dispose:dispose};}/**
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */class MeshDepthMaterial extends Material{constructor(parameters){super();this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.setValues(parameters);}copy(source){super.copy(source);this.depthPacking=source.depthPacking;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;}}MeshDepthMaterial.prototype.isMeshDepthMaterial=true;/**
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */class MeshDistanceMaterial extends Material{constructor(parameters){super();this.type='MeshDistanceMaterial';this.referencePosition=new Vector3();this.nearDistance=1;this.farDistance=1000;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.fog=false;this.setValues(parameters);}copy(source){super.copy(source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;}}MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;var vertex="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";var fragment="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function WebGLShadowMap(_renderer,_objects,_capabilities){var _frustum=new Frustum();var _shadowMapSize=new Vector2(),_viewportSize=new Vector2(),_viewport=new Vector4(),_depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),_distanceMaterial=new MeshDistanceMaterial(),_materialCache={},_maxTextureSize=_capabilities.maxTextureSize;var shadowSide={0:BackSide,1:FrontSide,2:DoubleSide};var shadowMaterialVertical=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2()},radius:{value:4.0}},vertexShader:vertex,fragmentShader:fragment});var shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;var fullScreenTri=new BufferGeometry();fullScreenTri.setAttribute('position',new BufferAttribute(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));var fullScreenMesh=new Mesh(fullScreenTri,shadowMaterialVertical);var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;var currentRenderTarget=_renderer.getRenderTarget();var activeCubeFace=_renderer.getActiveCubeFace();var activeMipmapLevel=_renderer.getActiveMipmapLevel();var _state=_renderer.state;// Set GL state for depth map.
  _state.setBlending(NoBlending);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
  for(var _i118=0,il=lights.length;_i118<il;_i118++){var light=lights[_i118];var shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}if(shadow.autoUpdate===false&&shadow.needsUpdate===false)continue;_shadowMapSize.copy(shadow.mapSize);var shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize){if(_shadowMapSize.x>_maxTextureSize){_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x);_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x;shadow.mapSize.x=_viewportSize.x;}if(_shadowMapSize.y>_maxTextureSize){_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y);_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y;shadow.mapSize.y=_viewportSize.y;}}if(shadow.map===null&&!shadow.isPointLightShadow&&this.type===VSMShadowMap){var pars={minFilter:LinearFilter,magFilter:LinearFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.camera.updateProjectionMatrix();}if(shadow.map===null){var _pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,_pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.camera.updateProjectionMatrix();}_renderer.setRenderTarget(shadow.map);_renderer.clear();var viewportCount=shadow.getViewportCount();for(var vp=0;vp<viewportCount;vp++){var viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type);}// do blur pass for VSM
  if(!shadow.isPointLightShadow&&this.type===VSMShadowMap){VSMPass(shadow,camera);}shadow.needsUpdate=false;}scope.needsUpdate=false;_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel);};function VSMPass(shadow,camera){var geometry=_objects.update(fullScreenMesh);if(shadowMaterialVertical.defines.VSM_SAMPLES!==shadow.blurSamples){shadowMaterialVertical.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialHorizontal.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialVertical.needsUpdate=true;shadowMaterialHorizontal.needsUpdate=true;}// vertical pass
  shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture;shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize;shadowMaterialVertical.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.mapPass);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null);// horizontal pass
  shadowMaterialHorizontal.uniforms.shadow_pass.value=shadow.mapPass.texture;shadowMaterialHorizontal.uniforms.resolution.value=shadow.mapSize;shadowMaterialHorizontal.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.map);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizontal,fullScreenMesh,null);}function getDepthMaterial(object,geometry,material,light,shadowCameraNear,shadowCameraFar,type){var result=null;var customMaterial=light.isPointLight===true?object.customDistanceMaterial:object.customDepthMaterial;if(customMaterial!==undefined){result=customMaterial;}else {result=light.isPointLight===true?_distanceMaterial:_depthMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0||material.displacementMap&&material.displacementScale!==0||material.alphaMap&&material.alphaTest>0){// in this case we need a unique material instance reflecting the
  // appropriate state
  var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;if(type===VSMShadowMap){result.side=material.shadowSide!==null?material.shadowSide:material.side;}else {result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side];}result.alphaMap=material.alphaMap;result.alphaTest=material.alphaTest;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.displacementMap=material.displacementMap;result.displacementScale=material.displacementScale;result.displacementBias=material.displacementBias;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(light.isPointLight===true&&result.isMeshDistanceMaterial===true){result.referencePosition.setFromMatrixPosition(light.matrixWorld);result.nearDistance=shadowCameraNear;result.farDistance=shadowCameraFar;}return result;}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if((object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,geometry,groupMaterial,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var _depthMaterial2=getDepthMaterial(object,geometry,material,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,_depthMaterial2,object,null);}}}var children=object.children;for(var _i119=0,l=children.length;_i119<l;_i119++){renderObject(children[_i119],camera,shadowCamera,light,type);}}}function WebGLState(gl,extensions,capabilities){var isWebGL2=capabilities.isWebGL2;function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4(0,0,0,0);return {setMask:function(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function(lock){locked=lock;},setClear:function(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
  }};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return {setTest:function(depthTest){if(depthTest){enable(2929);}else {disable(2929);}},setMask:function(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(512);break;case AlwaysDepth:gl.depthFunc(519);break;case LessDepth:gl.depthFunc(513);break;case LessEqualDepth:gl.depthFunc(515);break;case EqualDepth:gl.depthFunc(514);break;case GreaterEqualDepth:gl.depthFunc(518);break;case GreaterDepth:gl.depthFunc(516);break;case NotEqualDepth:gl.depthFunc(517);break;default:gl.depthFunc(515);}}else {gl.depthFunc(515);}currentDepthFunc=depthFunc;}},setLocked:function(lock){locked=lock;},setClear:function(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return {setTest:function(stencilTest){if(!locked){if(stencilTest){enable(2960);}else {disable(2960);}}},setMask:function(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function(lock){locked=lock;},setClear:function(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
  var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var enabledCapabilities={};var xrFramebuffer=null;var currentBoundFramebuffers={};var currentProgram=null;var currentBlendingEnabled=false;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var maxTextures=gl.getParameter(35661);var lineWidthAvailable=false;var version=0;var glVersion=gl.getParameter(7938);if(glVersion.indexOf('WebGL')!==-1){version=parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}var currentTextureSlot=null;var currentBoundTextures={};var scissorParam=gl.getParameter(3088);var viewportParam=gl.getParameter(2978);var currentScissor=new Vector4().fromArray(scissorParam);var currentViewport=new Vector4().fromArray(viewportParam);function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
  var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,10241,9728);gl.texParameteri(type,10240,9728);for(var _i120=0;_i120<count;_i120++){gl.texImage2D(target+_i120,0,6408,1,1,0,6408,5121,data);}return texture;}var emptyTextures={};emptyTextures[3553]=createTexture(3553,3553,1);emptyTextures[34067]=createTexture(34067,34069,6);// init
  colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(2929);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(2884);setBlending(NoBlending);//
  function enable(id){if(enabledCapabilities[id]!==true){gl.enable(id);enabledCapabilities[id]=true;}}function disable(id){if(enabledCapabilities[id]!==false){gl.disable(id);enabledCapabilities[id]=false;}}function bindXRFramebuffer(framebuffer){if(framebuffer!==xrFramebuffer){gl.bindFramebuffer(36160,framebuffer);xrFramebuffer=framebuffer;}}function bindFramebuffer(target,framebuffer){if(framebuffer===null&&xrFramebuffer!==null)framebuffer=xrFramebuffer;// use active XR framebuffer if available
  if(currentBoundFramebuffers[target]!==framebuffer){gl.bindFramebuffer(target,framebuffer);currentBoundFramebuffers[target]=framebuffer;if(isWebGL2){// 36009 is equivalent to 36160
  if(target===36009){currentBoundFramebuffers[36160]=framebuffer;}if(target===36160){currentBoundFramebuffers[36009]=framebuffer;}}return true;}return false;}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}var equationToGL={[AddEquation]:32774,[SubtractEquation]:32778,[ReverseSubtractEquation]:32779};if(isWebGL2){equationToGL[MinEquation]=32775;equationToGL[MaxEquation]=32776;}else {var extension=extensions.get('EXT_blend_minmax');if(extension!==null){equationToGL[MinEquation]=extension.MIN_EXT;equationToGL[MaxEquation]=extension.MAX_EXT;}}var factorToGL={[ZeroFactor]:0,[OneFactor]:1,[SrcColorFactor]:768,[SrcAlphaFactor]:770,[SrcAlphaSaturateFactor]:776,[DstColorFactor]:774,[DstAlphaFactor]:772,[OneMinusSrcColorFactor]:769,[OneMinusSrcAlphaFactor]:771,[OneMinusDstColorFactor]:775,[OneMinusDstAlphaFactor]:773};function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending===NoBlending){if(currentBlendingEnabled===true){disable(3042);currentBlendingEnabled=false;}return;}if(currentBlendingEnabled===false){enable(3042);currentBlendingEnabled=true;}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){gl.blendEquation(32774);currentBlendEquation=AddEquation;currentBlendEquationAlpha=AddEquation;}if(premultipliedAlpha){switch(blending){case NormalBlending:gl.blendFuncSeparate(1,771,1,771);break;case AdditiveBlending:gl.blendFunc(1,1);break;case SubtractiveBlending:gl.blendFuncSeparate(0,0,769,771);break;case MultiplyBlending:gl.blendFuncSeparate(0,768,0,770);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}else {switch(blending){case NormalBlending:gl.blendFuncSeparate(770,771,1,771);break;case AdditiveBlending:gl.blendFunc(770,1);break;case SubtractiveBlending:gl.blendFunc(0,769);break;case MultiplyBlending:gl.blendFunc(0,768);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}currentBlendSrc=null;currentBlendDst=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}return;}// custom blending
  blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]);currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]);currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}currentBlending=blending;currentPremultipledAlpha=null;}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(2884):enable(2884);var flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.blending===NormalBlending&&material.transparent===false?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);var stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite);if(stencilWrite){stencilBuffer.setMask(material.stencilWriteMask);stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask);stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass);}setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);material.alphaToCoverage===true?enable(32926):disable(32926);}//
  function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(2304);}else {gl.frontFace(2305);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(2884);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(1029);}else if(cullFace===CullFaceFront){gl.cullFace(1028);}else {gl.cullFace(1032);}}}else {disable(2884);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(32823);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else {disable(32823);}}function setScissorTest(scissorTest){if(scissorTest){enable(3089);}else {disable(3089);}}// texture
  function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=33984+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function unbindTexture(){var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture!==undefined&&boundTexture.type!==undefined){gl.bindTexture(boundTexture.type,null);boundTexture.type=undefined;boundTexture.texture=undefined;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage3D(){try{gl.texImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
  function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
  function reset(){// reset state
  gl.disable(3042);gl.disable(2884);gl.disable(2929);gl.disable(32823);gl.disable(3089);gl.disable(2960);gl.disable(32926);gl.blendEquation(32774);gl.blendFunc(1,0);gl.blendFuncSeparate(1,0,1,0);gl.colorMask(true,true,true,true);gl.clearColor(0,0,0,0);gl.depthMask(true);gl.depthFunc(513);gl.clearDepth(1);gl.stencilMask(0xffffffff);gl.stencilFunc(519,0,0xffffffff);gl.stencilOp(7680,7680,7680);gl.clearStencil(0);gl.cullFace(1029);gl.frontFace(2305);gl.polygonOffset(0,0);gl.activeTexture(33984);gl.bindFramebuffer(36160,null);if(isWebGL2===true){gl.bindFramebuffer(36009,null);gl.bindFramebuffer(36008,null);}gl.useProgram(null);gl.lineWidth(1);gl.scissor(0,0,gl.canvas.width,gl.canvas.height);gl.viewport(0,0,gl.canvas.width,gl.canvas.height);// reset internals
  enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};xrFramebuffer=null;currentBoundFramebuffers={};currentProgram=null;currentBlendingEnabled=false;currentBlending=null;currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentPremultipledAlpha=false;currentFlipSided=null;currentCullFace=null;currentLineWidth=null;currentPolygonOffsetFactor=null;currentPolygonOffsetUnits=null;currentScissor.set(0,0,gl.canvas.width,gl.canvas.height);currentViewport.set(0,0,gl.canvas.width,gl.canvas.height);colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return {buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable:enable,disable:disable,bindFramebuffer:bindFramebuffer,bindXRFramebuffer:bindXRFramebuffer,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,scissor:scissor,viewport:viewport,reset:reset};}function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){var isWebGL2=capabilities.isWebGL2;var maxTextures=capabilities.maxTextures;var maxCubemapSize=capabilities.maxCubemapSize;var maxTextureSize=capabilities.maxTextureSize;var maxSamples=capabilities.maxSamples;var _videoTextures=new WeakMap();var _canvas;// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
  var useOffscreenCanvas=false;try{useOffscreenCanvas=typeof OffscreenCanvas!=='undefined'&&new OffscreenCanvas(1,1).getContext('2d')!==null;}catch(err){// Ignore any errors
  }function createCanvas(width,height){// Use OffscreenCanvas when available. Specially needed in web workers
  return useOffscreenCanvas?new OffscreenCanvas(width,height):createElementNS('canvas');}function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){var scale=1;// handle case if texture exceeds max size
  if(image.width>maxSize||image.height>maxSize){scale=maxSize/Math.max(image.width,image.height);}// only perform resize if necessary
  if(scale<1||needsPowerOfTwo===true){// only perform resize for certain image types
  if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){var floor=needsPowerOfTwo?floorPowerOfTwo:Math.floor;var width=floor(scale*image.width);var height=floor(scale*image.height);if(_canvas===undefined)_canvas=createCanvas(width,height);// cube textures can't reuse the same canvas
  var canvas=needsNewCanvas?createCanvas(width,height):_canvas;canvas.width=width;canvas.height=height;var context=canvas.getContext('2d');context.drawImage(image,0,0,width,height);console.warn('THREE.WebGLRenderer: Texture has been resized from ('+image.width+'x'+image.height+') to ('+width+'x'+height+').');return canvas;}else {if('data'in image){console.warn('THREE.WebGLRenderer: Image in DataTexture is too big ('+image.width+'x'+image.height+').');}return image;}}return image;}function isPowerOfTwo$1(image){return isPowerOfTwo(image.width)&&isPowerOfTwo(image.height);}function textureNeedsPowerOfTwo(texture){if(isWebGL2)return false;return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function textureNeedsGenerateMipmaps(texture,supportsMips){return texture.generateMipmaps&&supportsMips&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function generateMipmap(target,texture,width,height){var depth=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;_gl.generateMipmap(target);var textureProperties=properties.get(texture);textureProperties.__maxMipLevel=Math.log2(Math.max(width,height,depth));}function getInternalFormat(internalFormatName,glFormat,glType,encoding){if(isWebGL2===false)return glFormat;if(internalFormatName!==null){if(_gl[internalFormatName]!==undefined)return _gl[internalFormatName];console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \''+internalFormatName+'\'');}var internalFormat=glFormat;if(glFormat===6403){if(glType===5126)internalFormat=33326;if(glType===5131)internalFormat=33325;if(glType===5121)internalFormat=33321;}if(glFormat===6407){if(glType===5126)internalFormat=34837;if(glType===5131)internalFormat=34843;if(glType===5121)internalFormat=32849;}if(glFormat===6408){if(glType===5126)internalFormat=34836;if(glType===5131)internalFormat=34842;if(glType===5121)internalFormat=encoding===sRGBEncoding?35907:32856;}if(internalFormat===33325||internalFormat===33326||internalFormat===34842||internalFormat===34836){extensions.get('EXT_color_buffer_float');}return internalFormat;}// Fallback filters for non-power-of-2 textures
  function filterFallback(f){if(f===NearestFilter||f===NearestMipmapNearestFilter||f===NearestMipmapLinearFilter){return 9728;}return 9729;}//
  function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){_videoTextures.delete(texture);}info.memory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);}//
  function deallocateTexture(texture){var textureProperties=properties.get(texture);if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);properties.remove(texture);}function deallocateRenderTarget(renderTarget){var texture=renderTarget.texture;var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);info.memory.textures--;}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLCubeRenderTarget){for(var _i121=0;_i121<6;_i121++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[_i121]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[_i121]);}}else {_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);if(renderTargetProperties.__webglMultisampledFramebuffer)_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);if(renderTargetProperties.__webglDepthRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);}if(renderTarget.isWebGLMultipleRenderTargets){for(var _i122=0,il=texture.length;_i122<il;_i122++){var attachmentProperties=properties.get(texture[_i122]);if(attachmentProperties.__webglTexture){_gl.deleteTexture(attachmentProperties.__webglTexture);info.memory.textures--;}properties.remove(texture[_i122]);}}properties.remove(texture);properties.remove(renderTarget);}//
  var textureUnits=0;function resetTextureUnits(){textureUnits=0;}function allocateTextureUnit(){var textureUnit=textureUnits;if(textureUnit>=maxTextures){console.warn('THREE.WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+maxTextures);}textureUnits+=1;return textureUnit;}//
  function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');}else {uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(33984+slot);state.bindTexture(3553,textureProperties.__webglTexture);}function setTexture2DArray(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(35866,textureProperties.__webglTexture);}function setTexture3D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(32879,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadCubeTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);}var wrappingToGL={[RepeatWrapping]:10497,[ClampToEdgeWrapping]:33071,[MirroredRepeatWrapping]:33648};var filterToGL={[NearestFilter]:9728,[NearestMipmapNearestFilter]:9984,[NearestMipmapLinearFilter]:9986,[LinearFilter]:9729,[LinearMipmapNearestFilter]:9985,[LinearMipmapLinearFilter]:9987};function setTextureParameters(textureType,texture,supportsMips){if(supportsMips){_gl.texParameteri(textureType,10242,wrappingToGL[texture.wrapS]);_gl.texParameteri(textureType,10243,wrappingToGL[texture.wrapT]);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,wrappingToGL[texture.wrapR]);}_gl.texParameteri(textureType,10240,filterToGL[texture.magFilter]);_gl.texParameteri(textureType,10241,filterToGL[texture.minFilter]);}else {_gl.texParameteri(textureType,10242,33071);_gl.texParameteri(textureType,10243,33071);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,33071);}if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');}_gl.texParameteri(textureType,10240,filterFallback(texture.magFilter));_gl.texParameteri(textureType,10241,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');}}if(extensions.has('EXT_texture_filter_anisotropic')===true){var extension=extensions.get('EXT_texture_filter_anisotropic');if(texture.type===FloatType&&extensions.has('OES_texture_float_linear')===false)return;// verify extension for WebGL 1 and WebGL 2
  if(isWebGL2===false&&texture.type===HalfFloatType&&extensions.has('OES_texture_half_float_linear')===false)return;// verify extension for WebGL 1 only
  if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function initTexture(textureProperties,texture){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}function uploadTexture(textureProperties,texture,slot){var textureType=3553;if(texture.isDataTexture2DArray)textureType=35866;if(texture.isDataTexture3D)textureType=32879;initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(textureType,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);var needsPowerOfTwo=textureNeedsPowerOfTwo(texture)&&isPowerOfTwo$1(texture.image)===false;var image=resizeImage(texture.image,needsPowerOfTwo,false,maxTextureSize);var supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);setTextureParameters(textureType,texture,supportsMips);var mipmap;var mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
  glInternalFormat=6402;if(isWebGL2){if(texture.type===FloatType){glInternalFormat=36012;}else if(texture.type===UnsignedIntType){glInternalFormat=33190;}else if(texture.type===UnsignedInt248Type){glInternalFormat=35056;}else {glInternalFormat=33189;// WebGL2 requires sized internalformat for glTexImage2D
  }}else {if(texture.type===FloatType){console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');}}// validation checks for WebGL 1
  if(texture.format===DepthFormat&&glInternalFormat===6402){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=utils.convert(texture.type);}}if(texture.format===DepthStencilFormat&&glInternalFormat===6402){// Depth stencil textures need the DEPTH_STENCIL internal format
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  glInternalFormat=34041;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=utils.convert(texture.type);}}//
  state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&supportsMips){for(var _i123=0,il=mipmaps.length;_i123<il;_i123++){mipmap=mipmaps[_i123];state.texImage2D(3553,_i123,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else {state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}}else if(texture.isCompressedTexture){for(var _i124=0,_il9=mipmaps.length;_i124<_il9;_i124++){mipmap=mipmaps[_i124];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(3553,_i124,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else {state.texImage2D(3553,_i124,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}textureProperties.__maxMipLevel=mipmaps.length-1;}else if(texture.isDataTexture2DArray){state.texImage3D(35866,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else if(texture.isDataTexture3D){state.texImage3D(32879,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else {// regular Texture (image, video, canvas)
  // use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&supportsMips){for(var _i125=0,_il10=mipmaps.length;_i125<_il10;_i125++){mipmap=mipmaps[_i125];state.texImage2D(3553,_i125,glInternalFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else {state.texImage2D(3553,0,glInternalFormat,glFormat,glType,image);textureProperties.__maxMipLevel=0;}}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(textureType,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}function uploadCubeTexture(textureProperties,texture,slot){if(texture.image.length!==6)return;initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);var isCompressed=texture&&(texture.isCompressedTexture||texture.image[0].isCompressedTexture);var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var _i126=0;_i126<6;_i126++){if(!isCompressed&&!isDataTexture){cubeImage[_i126]=resizeImage(texture.image[_i126],false,true,maxCubemapSize);}else {cubeImage[_i126]=isDataTexture?texture.image[_i126].image:texture.image[_i126];}}var image=cubeImage[0],supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);setTextureParameters(34067,texture,supportsMips);var mipmaps;if(isCompressed){for(var _i127=0;_i127<6;_i127++){mipmaps=cubeImage[_i127].mipmaps;for(var j=0;j<mipmaps.length;j++){var mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(34069+_i127,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else {state.texImage2D(34069+_i127,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}textureProperties.__maxMipLevel=mipmaps.length-1;}else {mipmaps=texture.mipmaps;for(var _i128=0;_i128<6;_i128++){if(isDataTexture){state.texImage2D(34069+_i128,0,glInternalFormat,cubeImage[_i128].width,cubeImage[_i128].height,0,glFormat,glType,cubeImage[_i128].data);for(var _j3=0;_j3<mipmaps.length;_j3++){var _mipmap=mipmaps[_j3];var mipmapImage=_mipmap.image[_i128].image;state.texImage2D(34069+_i128,_j3+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data);}}else {state.texImage2D(34069+_i128,0,glInternalFormat,glFormat,glType,cubeImage[_i128]);for(var _j4=0;_j4<mipmaps.length;_j4++){var _mipmap2=mipmaps[_j4];state.texImage2D(34069+_i128,_j4+1,glInternalFormat,glFormat,glType,_mipmap2.image[_i128]);}}}textureProperties.__maxMipLevel=mipmaps.length;}if(textureNeedsGenerateMipmaps(texture,supportsMips)){// We assume images for cube map have the same size.
  generateMipmap(34067,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget){var glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type);var glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);if(textureTarget===32879||textureTarget===35866){state.texImage3D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,renderTarget.depth,0,glFormat,glType,null);}else {state.texImage2D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);}state.bindFramebuffer(36160,framebuffer);_gl.framebufferTexture2D(36160,attachment,textureTarget,properties.get(texture).__webglTexture,0);state.bindFramebuffer(36160,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(36161,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){var glInternalFormat=33189;if(isMultisample){var depthTexture=renderTarget.depthTexture;if(depthTexture&&depthTexture.isDepthTexture){if(depthTexture.type===FloatType){glInternalFormat=36012;}else if(depthTexture.type===UnsignedIntType){glInternalFormat=33190;}}var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){if(isMultisample){var _samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,_samples,35056,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,34041,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);}else {// Use the first texture for MRT so far
  var texture=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture[0]:renderTarget.texture;var glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type);var _glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);if(isMultisample){var _samples2=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,_samples2,_glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,_glInternalFormat,renderTarget.width,renderTarget.height);}}_gl.bindRenderbuffer(36161,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
  function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLCubeRenderTarget;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');state.bindFramebuffer(36160,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
  if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(36160,36096,3553,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(36160,33306,3553,webglDepthTexture,0);}else {throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLCubeRenderTarget===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else {if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var _i129=0;_i129<6;_i129++){state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer[_i129]);renderTargetProperties.__webglDepthbuffer[_i129]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[_i129],renderTarget,false);}}else {state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,false);}}state.bindFramebuffer(36160,null);}// Set up GL resources for the render target
  function setupRenderTarget(renderTarget){var texture=renderTarget.texture;var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);if(renderTarget.isWebGLMultipleRenderTargets!==true){textureProperties.__webglTexture=_gl.createTexture();textureProperties.__version=texture.version;info.memory.textures++;}var isCube=renderTarget.isWebGLCubeRenderTarget===true;var isMultipleRenderTargets=renderTarget.isWebGLMultipleRenderTargets===true;var isMultisample=renderTarget.isWebGLMultisampleRenderTarget===true;var isRenderTarget3D=texture.isDataTexture3D||texture.isDataTexture2DArray;var supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;// Handles WebGL2 RGBFormat fallback - #18858
  if(isWebGL2&&texture.format===RGBFormat&&(texture.type===FloatType||texture.type===HalfFloatType)){texture.format=RGBAFormat;console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');}// Setup framebuffer
  if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var _i130=0;_i130<6;_i130++){renderTargetProperties.__webglFramebuffer[_i130]=_gl.createFramebuffer();}}else {renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();if(isMultipleRenderTargets){if(capabilities.drawBuffers){var textures=renderTarget.texture;for(var _i131=0,il=textures.length;_i131<il;_i131++){var attachmentProperties=properties.get(textures[_i131]);if(attachmentProperties.__webglTexture===undefined){attachmentProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}}else {console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');}}else if(isMultisample){if(isWebGL2){renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=_gl.createRenderbuffer();_gl.bindRenderbuffer(36161,renderTargetProperties.__webglColorRenderbuffer);var glFormat=utils.convert(texture.format);var glType=utils.convert(texture.type);var glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);state.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(36160,36064,36161,renderTargetProperties.__webglColorRenderbuffer);_gl.bindRenderbuffer(36161,null);if(renderTarget.depthBuffer){renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);}state.bindFramebuffer(36160,null);}else {console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');}}}// Setup color buffer
  if(isCube){state.bindTexture(34067,textureProperties.__webglTexture);setTextureParameters(34067,texture,supportsMips);for(var _i132=0;_i132<6;_i132++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i132],renderTarget,texture,36064,34069+_i132);}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(34067,texture,renderTarget.width,renderTarget.height);}state.unbindTexture();}else if(isMultipleRenderTargets){var _textures=renderTarget.texture;for(var _i133=0,_il11=_textures.length;_i133<_il11;_i133++){var attachment=_textures[_i133];var _attachmentProperties=properties.get(attachment);state.bindTexture(3553,_attachmentProperties.__webglTexture);setTextureParameters(3553,attachment,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,attachment,36064+_i133,3553);if(textureNeedsGenerateMipmaps(attachment,supportsMips)){generateMipmap(3553,attachment,renderTarget.width,renderTarget.height);}}state.unbindTexture();}else {var glTextureType=3553;if(isRenderTarget3D){// Render targets containing layers, i.e: Texture 3D and 2d arrays
  if(isWebGL2){var isTexture3D=texture.isDataTexture3D;glTextureType=isTexture3D?32879:35866;}else {console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');}}state.bindTexture(glTextureType,textureProperties.__webglTexture);setTextureParameters(glTextureType,texture,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,36064,glTextureType);if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(glTextureType,texture,renderTarget.width,renderTarget.height,renderTarget.depth);}state.unbindTexture();}// Setup depth and stencil buffers
  if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;var textures=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture:[renderTarget.texture];for(var _i134=0,il=textures.length;_i134<il;_i134++){var texture=textures[_i134];if(textureNeedsGenerateMipmaps(texture,supportsMips)){var target=renderTarget.isWebGLCubeRenderTarget?34067:3553;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);generateMipmap(target,texture,renderTarget.width,renderTarget.height);state.unbindTexture();}}}function updateMultisampleRenderTarget(renderTarget){if(renderTarget.isWebGLMultisampleRenderTarget){if(isWebGL2){var width=renderTarget.width;var height=renderTarget.height;var mask=16384;if(renderTarget.depthBuffer)mask|=256;if(renderTarget.stencilBuffer)mask|=1024;var renderTargetProperties=properties.get(renderTarget);state.bindFramebuffer(36008,renderTargetProperties.__webglMultisampledFramebuffer);state.bindFramebuffer(36009,renderTargetProperties.__webglFramebuffer);_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,9728);state.bindFramebuffer(36008,null);state.bindFramebuffer(36009,renderTargetProperties.__webglMultisampledFramebuffer);}else {console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');}}}function getRenderTargetSamples(renderTarget){return isWebGL2&&renderTarget.isWebGLMultisampleRenderTarget?Math.min(maxSamples,renderTarget.samples):0;}function updateVideoTexture(texture){var frame=info.render.frame;// Check the last frame we updated the VideoTexture
  if(_videoTextures.get(texture)!==frame){_videoTextures.set(texture,frame);texture.update();}}// backwards compatibility
  var warnedTexture2D=false;var warnedTextureCube=false;function safeSetTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(warnedTexture2D===false){console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');warnedTexture2D=true;}texture=texture.texture;}setTexture2D(texture,slot);}function safeSetTextureCube(texture,slot){if(texture&&texture.isWebGLCubeRenderTarget){if(warnedTextureCube===false){console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');warnedTextureCube=true;}texture=texture.texture;}setTextureCube(texture,slot);}//
  this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.safeSetTexture2D=safeSetTexture2D;this.safeSetTextureCube=safeSetTextureCube;}function WebGLUtils(gl,extensions,capabilities){var isWebGL2=capabilities.isWebGL2;function convert(p){var extension;if(p===UnsignedByteType)return 5121;if(p===UnsignedShort4444Type)return 32819;if(p===UnsignedShort5551Type)return 32820;if(p===UnsignedShort565Type)return 33635;if(p===ByteType)return 5120;if(p===ShortType)return 5122;if(p===UnsignedShortType)return 5123;if(p===IntType)return 5124;if(p===UnsignedIntType)return 5125;if(p===FloatType)return 5126;if(p===HalfFloatType){if(isWebGL2)return 5131;extension=extensions.get('OES_texture_half_float');if(extension!==null){return extension.HALF_FLOAT_OES;}else {return null;}}if(p===AlphaFormat)return 6406;if(p===RGBFormat)return 6407;if(p===RGBAFormat)return 6408;if(p===LuminanceFormat)return 6409;if(p===LuminanceAlphaFormat)return 6410;if(p===DepthFormat)return 6402;if(p===DepthStencilFormat)return 34041;if(p===RedFormat)return 6403;// WebGL2 formats.
  if(p===RedIntegerFormat)return 36244;if(p===RGFormat)return 33319;if(p===RGIntegerFormat)return 33320;if(p===RGBIntegerFormat)return 36248;if(p===RGBAIntegerFormat)return 36249;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else {return null;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else {return null;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null){return extension.COMPRESSED_RGB_ETC1_WEBGL;}else {return null;}}if(p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){extension=extensions.get('WEBGL_compressed_texture_etc');if(extension!==null){if(p===RGB_ETC2_Format)return extension.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return extension.COMPRESSED_RGBA8_ETC2_EAC;}}if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format||p===SRGB8_ALPHA8_ASTC_4x4_Format||p===SRGB8_ALPHA8_ASTC_5x4_Format||p===SRGB8_ALPHA8_ASTC_5x5_Format||p===SRGB8_ALPHA8_ASTC_6x5_Format||p===SRGB8_ALPHA8_ASTC_6x6_Format||p===SRGB8_ALPHA8_ASTC_8x5_Format||p===SRGB8_ALPHA8_ASTC_8x6_Format||p===SRGB8_ALPHA8_ASTC_8x8_Format||p===SRGB8_ALPHA8_ASTC_10x5_Format||p===SRGB8_ALPHA8_ASTC_10x6_Format||p===SRGB8_ALPHA8_ASTC_10x8_Format||p===SRGB8_ALPHA8_ASTC_10x10_Format||p===SRGB8_ALPHA8_ASTC_12x10_Format||p===SRGB8_ALPHA8_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){// TODO Complete?
  return p;}else {return null;}}if(p===RGBA_BPTC_Format){extension=extensions.get('EXT_texture_compression_bptc');if(extension!==null){// TODO Complete?
  return p;}else {return null;}}if(p===UnsignedInt248Type){if(isWebGL2)return 34042;extension=extensions.get('WEBGL_depth_texture');if(extension!==null){return extension.UNSIGNED_INT_24_8_WEBGL;}else {return null;}}}return {convert:convert};}class ArrayCamera extends PerspectiveCamera{constructor(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];super();this.cameras=array;}}ArrayCamera.prototype.isArrayCamera=true;class Group extends Object3D{constructor(){super();this.type='Group';}}Group.prototype.isGroup=true;var _moveEvent={type:'move'};class WebXRController{constructor(){this._targetRay=null;this._grip=null;this._hand=null;}getHandSpace(){if(this._hand===null){this._hand=new Group();this._hand.matrixAutoUpdate=false;this._hand.visible=false;this._hand.joints={};this._hand.inputState={pinching:false};}return this._hand;}getTargetRaySpace(){if(this._targetRay===null){this._targetRay=new Group();this._targetRay.matrixAutoUpdate=false;this._targetRay.visible=false;this._targetRay.hasLinearVelocity=false;this._targetRay.linearVelocity=new Vector3();this._targetRay.hasAngularVelocity=false;this._targetRay.angularVelocity=new Vector3();}return this._targetRay;}getGripSpace(){if(this._grip===null){this._grip=new Group();this._grip.matrixAutoUpdate=false;this._grip.visible=false;this._grip.hasLinearVelocity=false;this._grip.linearVelocity=new Vector3();this._grip.hasAngularVelocity=false;this._grip.angularVelocity=new Vector3();}return this._grip;}dispatchEvent(event){if(this._targetRay!==null){this._targetRay.dispatchEvent(event);}if(this._grip!==null){this._grip.dispatchEvent(event);}if(this._hand!==null){this._hand.dispatchEvent(event);}return this;}disconnect(inputSource){this.dispatchEvent({type:'disconnected',data:inputSource});if(this._targetRay!==null){this._targetRay.visible=false;}if(this._grip!==null){this._grip.visible=false;}if(this._hand!==null){this._hand.visible=false;}return this;}update(inputSource,frame,referenceSpace){var inputPose=null;var gripPose=null;var handPose=null;var targetRay=this._targetRay;var grip=this._grip;var hand=this._hand;if(inputSource&&frame.session.visibilityState!=='visible-blurred'){if(targetRay!==null){inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);if(inputPose!==null){targetRay.matrix.fromArray(inputPose.transform.matrix);targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale);if(inputPose.linearVelocity){targetRay.hasLinearVelocity=true;targetRay.linearVelocity.copy(inputPose.linearVelocity);}else {targetRay.hasLinearVelocity=false;}if(inputPose.angularVelocity){targetRay.hasAngularVelocity=true;targetRay.angularVelocity.copy(inputPose.angularVelocity);}else {targetRay.hasAngularVelocity=false;}this.dispatchEvent(_moveEvent);}}if(hand&&inputSource.hand){handPose=true;for(var inputjoint of inputSource.hand.values()){// Update the joints groups with the XRJoint poses
  var jointPose=frame.getJointPose(inputjoint,referenceSpace);if(hand.joints[inputjoint.jointName]===undefined){// The transform of this joint will be updated with the joint pose on each frame
  var _joint=new Group();_joint.matrixAutoUpdate=false;_joint.visible=false;hand.joints[inputjoint.jointName]=_joint;// ??
  hand.add(_joint);}var joint=hand.joints[inputjoint.jointName];if(jointPose!==null){joint.matrix.fromArray(jointPose.transform.matrix);joint.matrix.decompose(joint.position,joint.rotation,joint.scale);joint.jointRadius=jointPose.radius;}joint.visible=jointPose!==null;}// Custom events
  // Check pinchz
  var indexTip=hand.joints['index-finger-tip'];var thumbTip=hand.joints['thumb-tip'];var distance=indexTip.position.distanceTo(thumbTip.position);var distanceToPinch=0.02;var threshold=0.005;if(hand.inputState.pinching&&distance>distanceToPinch+threshold){hand.inputState.pinching=false;this.dispatchEvent({type:'pinchend',handedness:inputSource.handedness,target:this});}else if(!hand.inputState.pinching&&distance<=distanceToPinch-threshold){hand.inputState.pinching=true;this.dispatchEvent({type:'pinchstart',handedness:inputSource.handedness,target:this});}}else {if(grip!==null&&inputSource.gripSpace){gripPose=frame.getPose(inputSource.gripSpace,referenceSpace);if(gripPose!==null){grip.matrix.fromArray(gripPose.transform.matrix);grip.matrix.decompose(grip.position,grip.rotation,grip.scale);if(gripPose.linearVelocity){grip.hasLinearVelocity=true;grip.linearVelocity.copy(gripPose.linearVelocity);}else {grip.hasLinearVelocity=false;}if(gripPose.angularVelocity){grip.hasAngularVelocity=true;grip.angularVelocity.copy(gripPose.angularVelocity);}else {grip.hasAngularVelocity=false;}}}}}if(targetRay!==null){targetRay.visible=inputPose!==null;}if(grip!==null){grip.visible=gripPose!==null;}if(hand!==null){hand.visible=handPose!==null;}return this;}}class WebXRManager extends EventDispatcher{constructor(renderer,gl){super();var scope=this;var state=renderer.state;var session=null;var framebufferScaleFactor=1.0;var referenceSpace=null;var referenceSpaceType='local-floor';var pose=null;var glBinding=null;var glFramebuffer=null;var glProjLayer=null;var glBaseLayer=null;var isMultisample=false;var glMultisampledFramebuffer=null;var glColorRenderbuffer=null;var glDepthRenderbuffer=null;var xrFrame=null;var depthStyle=null;var clearStyle=null;var controllers=[];var inputSourcesMap=new Map();//
  var cameraL=new PerspectiveCamera();cameraL.layers.enable(1);cameraL.viewport=new Vector4();var cameraR=new PerspectiveCamera();cameraR.layers.enable(2);cameraR.viewport=new Vector4();var cameras=[cameraL,cameraR];var cameraVR=new ArrayCamera();cameraVR.layers.enable(1);cameraVR.layers.enable(2);var _currentDepthNear=null;var _currentDepthFar=null;//
  this.cameraAutoUpdate=true;this.enabled=false;this.isPresenting=false;this.getController=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getTargetRaySpace();};this.getControllerGrip=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getGripSpace();};this.getHand=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getHandSpace();};//
  function onSessionEvent(event){var controller=inputSourcesMap.get(event.inputSource);if(controller){controller.dispatchEvent({type:event.type,data:event.inputSource});}}function onSessionEnd(){inputSourcesMap.forEach(function(controller,inputSource){controller.disconnect(inputSource);});inputSourcesMap.clear();_currentDepthNear=null;_currentDepthFar=null;// restore framebuffer/rendering state
  state.bindXRFramebuffer(null);renderer.setRenderTarget(renderer.getRenderTarget());if(glFramebuffer)gl.deleteFramebuffer(glFramebuffer);if(glMultisampledFramebuffer)gl.deleteFramebuffer(glMultisampledFramebuffer);if(glColorRenderbuffer)gl.deleteRenderbuffer(glColorRenderbuffer);if(glDepthRenderbuffer)gl.deleteRenderbuffer(glDepthRenderbuffer);glFramebuffer=null;glMultisampledFramebuffer=null;glColorRenderbuffer=null;glDepthRenderbuffer=null;glBaseLayer=null;glProjLayer=null;glBinding=null;session=null;//
  animation.stop();scope.isPresenting=false;scope.dispatchEvent({type:'sessionend'});}this.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');}};this.setReferenceSpaceType=function(value){referenceSpaceType=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');}};this.getReferenceSpace=function(){return referenceSpace;};this.getBaseLayer=function(){return glProjLayer!==null?glProjLayer:glBaseLayer;};this.getBinding=function(){return glBinding;};this.getFrame=function(){return xrFrame;};this.getSession=function(){return session;};this.setSession=/*#__PURE__*/function(){var _ref=_asyncToGenerator(function*(value){session=value;if(session!==null){session.addEventListener('select',onSessionEvent);session.addEventListener('selectstart',onSessionEvent);session.addEventListener('selectend',onSessionEvent);session.addEventListener('squeeze',onSessionEvent);session.addEventListener('squeezestart',onSessionEvent);session.addEventListener('squeezeend',onSessionEvent);session.addEventListener('end',onSessionEnd);session.addEventListener('inputsourceschange',onInputSourcesChange);var attributes=gl.getContextAttributes();if(attributes.xrCompatible!==true){yield gl.makeXRCompatible();}if(session.renderState.layers===undefined){var layerInit={antialias:attributes.antialias,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({baseLayer:glBaseLayer});}else if(gl instanceof WebGLRenderingContext){// Use old style webgl layer because we can't use MSAA
  // WebGL2 support.
  var _layerInit={antialias:true,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,_layerInit);session.updateRenderState({layers:[glBaseLayer]});}else {isMultisample=attributes.antialias;var depthFormat=null;if(attributes.depth){clearStyle=256;if(attributes.stencil)clearStyle|=1024;depthStyle=attributes.stencil?33306:36096;depthFormat=attributes.stencil?35056:33190;}var projectionlayerInit={colorFormat:attributes.alpha?32856:32849,depthFormat:depthFormat,scaleFactor:framebufferScaleFactor};glBinding=new XRWebGLBinding(session,gl);glProjLayer=glBinding.createProjectionLayer(projectionlayerInit);glFramebuffer=gl.createFramebuffer();session.updateRenderState({layers:[glProjLayer]});if(isMultisample){glMultisampledFramebuffer=gl.createFramebuffer();glColorRenderbuffer=gl.createRenderbuffer();gl.bindRenderbuffer(36161,glColorRenderbuffer);gl.renderbufferStorageMultisample(36161,4,32856,glProjLayer.textureWidth,glProjLayer.textureHeight);state.bindFramebuffer(36160,glMultisampledFramebuffer);gl.framebufferRenderbuffer(36160,36064,36161,glColorRenderbuffer);gl.bindRenderbuffer(36161,null);if(depthFormat!==null){glDepthRenderbuffer=gl.createRenderbuffer();gl.bindRenderbuffer(36161,glDepthRenderbuffer);gl.renderbufferStorageMultisample(36161,4,depthFormat,glProjLayer.textureWidth,glProjLayer.textureHeight);gl.framebufferRenderbuffer(36160,depthStyle,36161,glDepthRenderbuffer);gl.bindRenderbuffer(36161,null);}state.bindFramebuffer(36160,null);}}referenceSpace=yield session.requestReferenceSpace(referenceSpaceType);animation.setContext(session);animation.start();scope.isPresenting=true;scope.dispatchEvent({type:'sessionstart'});}});return function(_x3){return _ref.apply(this,arguments);};}();function onInputSourcesChange(event){var inputSources=session.inputSources;// Assign inputSources to available controllers
  for(var _i135=0;_i135<controllers.length;_i135++){inputSourcesMap.set(inputSources[_i135],controllers[_i135]);}// Notify disconnected
  for(var _i136=0;_i136<event.removed.length;_i136++){var inputSource=event.removed[_i136];var controller=inputSourcesMap.get(inputSource);if(controller){controller.dispatchEvent({type:'disconnected',data:inputSource});inputSourcesMap.delete(inputSource);}}// Notify connected
  for(var _i137=0;_i137<event.added.length;_i137++){var _inputSource=event.added[_i137];var _controller=inputSourcesMap.get(_inputSource);if(_controller){_controller.dispatchEvent({type:'connected',data:_inputSource});}}}//
  var cameraLPos=new Vector3();var cameraRPos=new Vector3();/**
  		 * Assumes 2 cameras that are parallel and share an X-axis, and that
  		 * the cameras' projection and world matrices have already been set.
  		 * And that near and far planes are identical for both cameras.
  		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
  		 */function setProjectionFromUnion(camera,cameraL,cameraR){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);var ipd=cameraLPos.distanceTo(cameraRPos);var projL=cameraL.projectionMatrix.elements;var projR=cameraR.projectionMatrix.elements;// VR systems will have identical far and near planes, and
  // most likely identical top and bottom frustum extents.
  // Use the left camera for these values.
  var near=projL[14]/(projL[10]-1);var far=projL[14]/(projL[10]+1);var topFov=(projL[9]+1)/projL[5];var bottomFov=(projL[9]-1)/projL[5];var leftFov=(projL[8]-1)/projL[0];var rightFov=(projR[8]+1)/projR[0];var left=near*leftFov;var right=near*rightFov;// Calculate the new camera's position offset from the
  // left camera. xOffset should be roughly half `ipd`.
  var zOffset=ipd/(-leftFov+rightFov);var xOffset=zOffset*-leftFov;// TODO: Better way to apply this offset?
  cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);camera.translateX(xOffset);camera.translateZ(zOffset);camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);camera.matrixWorldInverse.copy(camera.matrixWorld).invert();// Find the union of the frustum values of the cameras and scale
  // the values so that the near plane's position does not change in world space,
  // although must now be relative to the new union camera.
  var near2=near+zOffset;var far2=far+zOffset;var left2=left-xOffset;var right2=right+(ipd-xOffset);var top2=topFov*far/far2*near2;var bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);}function updateCamera(camera,parent){if(parent===null){camera.matrixWorld.copy(camera.matrix);}else {camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);}camera.matrixWorldInverse.copy(camera.matrixWorld).invert();}this.updateCamera=function(camera){if(session===null)return;cameraVR.near=cameraR.near=cameraL.near=camera.near;cameraVR.far=cameraR.far=cameraL.far=camera.far;if(_currentDepthNear!==cameraVR.near||_currentDepthFar!==cameraVR.far){// Note that the new renderState won't apply until the next frame. See #18320
  session.updateRenderState({depthNear:cameraVR.near,depthFar:cameraVR.far});_currentDepthNear=cameraVR.near;_currentDepthFar=cameraVR.far;}var parent=camera.parent;var cameras=cameraVR.cameras;updateCamera(cameraVR,parent);for(var _i138=0;_i138<cameras.length;_i138++){updateCamera(cameras[_i138],parent);}cameraVR.matrixWorld.decompose(cameraVR.position,cameraVR.quaternion,cameraVR.scale);// update user camera and its children
  camera.position.copy(cameraVR.position);camera.quaternion.copy(cameraVR.quaternion);camera.scale.copy(cameraVR.scale);camera.matrix.copy(cameraVR.matrix);camera.matrixWorld.copy(cameraVR.matrixWorld);var children=camera.children;for(var _i139=0,l=children.length;_i139<l;_i139++){children[_i139].updateMatrixWorld(true);}// update projection matrix for proper view frustum culling
  if(cameras.length===2){setProjectionFromUnion(cameraVR,cameraL,cameraR);}else {// assume single camera setup (AR)
  cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);}};this.getCamera=function(){return cameraVR;};this.getFoveation=function(){if(glProjLayer!==null){return glProjLayer.fixedFoveation;}if(glBaseLayer!==null){return glBaseLayer.fixedFoveation;}return undefined;};this.setFoveation=function(foveation){// 0 = no foveation = full resolution
  // 1 = maximum foveation = the edges render at lower resolution
  if(glProjLayer!==null){glProjLayer.fixedFoveation=foveation;}if(glBaseLayer!==null&&glBaseLayer.fixedFoveation!==undefined){glBaseLayer.fixedFoveation=foveation;}};// Animation Loop
  var onAnimationFrameCallback=null;function onAnimationFrame(time,frame){pose=frame.getViewerPose(referenceSpace);xrFrame=frame;if(pose!==null){var views=pose.views;if(glBaseLayer!==null){state.bindXRFramebuffer(glBaseLayer.framebuffer);}var cameraVRNeedsUpdate=false;// check if it's necessary to rebuild cameraVR's camera list
  if(views.length!==cameraVR.cameras.length){cameraVR.cameras.length=0;cameraVRNeedsUpdate=true;}for(var _i140=0;_i140<views.length;_i140++){var view=views[_i140];var viewport=null;if(glBaseLayer!==null){viewport=glBaseLayer.getViewport(view);}else {var glSubImage=glBinding.getViewSubImage(glProjLayer,view);state.bindXRFramebuffer(glFramebuffer);if(glSubImage.depthStencilTexture!==undefined){gl.framebufferTexture2D(36160,depthStyle,3553,glSubImage.depthStencilTexture,0);}gl.framebufferTexture2D(36160,36064,3553,glSubImage.colorTexture,0);viewport=glSubImage.viewport;}var camera=cameras[_i140];camera.matrix.fromArray(view.transform.matrix);camera.projectionMatrix.fromArray(view.projectionMatrix);camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);if(_i140===0){cameraVR.matrix.copy(camera.matrix);}if(cameraVRNeedsUpdate===true){cameraVR.cameras.push(camera);}}if(isMultisample){state.bindXRFramebuffer(glMultisampledFramebuffer);if(clearStyle!==null)gl.clear(clearStyle);}}//
  var inputSources=session.inputSources;for(var _i141=0;_i141<controllers.length;_i141++){var controller=controllers[_i141];var inputSource=inputSources[_i141];controller.update(inputSource,frame,referenceSpace);}if(onAnimationFrameCallback)onAnimationFrameCallback(time,frame);if(isMultisample){var width=glProjLayer.textureWidth;var height=glProjLayer.textureHeight;state.bindFramebuffer(36008,glMultisampledFramebuffer);state.bindFramebuffer(36009,glFramebuffer);// Invalidate the depth here to avoid flush of the depth data to main memory.
  gl.invalidateFramebuffer(36008,[depthStyle]);gl.invalidateFramebuffer(36009,[depthStyle]);gl.blitFramebuffer(0,0,width,height,0,0,width,height,16384,9728);// Invalidate the MSAA buffer because it's not needed anymore.
  gl.invalidateFramebuffer(36008,[36064]);state.bindFramebuffer(36008,null);state.bindFramebuffer(36009,null);state.bindFramebuffer(36160,glMultisampledFramebuffer);}xrFrame=null;}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;};this.dispose=function(){};}}function WebGLMaterials(properties){function refreshFogUniforms(uniforms,fog){uniforms.fogColor.value.copy(fog.color);if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshMaterialUniforms(uniforms,material,pixelRatio,height,transmissionRenderTarget){if(material.isMeshBasicMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsLambert(uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsToon(uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsPhong(uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsCommon(uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(uniforms,material,transmissionRenderTarget);}else {refreshUniformsStandard(uniforms,material);}}else if(material.isMeshMatcapMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsMatcap(uniforms,material);}else if(material.isMeshDepthMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDepth(uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDistance(uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsNormal(uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(uniforms,material,pixelRatio,height);}else if(material.isSpriteMaterial){refreshUniformsSprites(uniforms,material);}else if(material.isShadowMaterial){uniforms.color.value.copy(material.color);uniforms.opacity.value=material.opacity;}else if(material.isShaderMaterial){material.uniformsNeedUpdate=false;// #15581
  }}function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value.copy(material.color);}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.specularMap){uniforms.specularMap.value=material.specularMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}var envMap=properties.get(material).envMap;if(envMap){uniforms.envMap.value=envMap;uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;uniforms.reflectivity.value=material.reflectivity;uniforms.ior.value=material.ior;uniforms.refractionRatio.value=material.refractionRatio;var maxMipLevel=properties.get(envMap).__maxMipLevel;if(maxMipLevel!==undefined){uniforms.maxMipLevel.value=maxMipLevel;}}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. specular map
  // 3. displacementMap map
  // 4. normal map
  // 5. bump map
  // 6. roughnessMap map
  // 7. metalnessMap map
  // 8. alphaMap map
  // 9. emissiveMap map
  // 10. clearcoat map
  // 11. clearcoat normal map
  // 12. clearcoat roughnessMap map
  // 13. specular intensity map
  // 14. specular tint map
  // 15. transmission map
  // 16. thickness map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}else if(material.clearcoatMap){uvScaleMap=material.clearcoatMap;}else if(material.clearcoatNormalMap){uvScaleMap=material.clearcoatNormalMap;}else if(material.clearcoatRoughnessMap){uvScaleMap=material.clearcoatRoughnessMap;}else if(material.specularIntensityMap){uvScaleMap=material.specularIntensityMap;}else if(material.specularColorMap){uvScaleMap=material.specularColorMap;}else if(material.transmissionMap){uvScaleMap=material.transmissionMap;}else if(material.thicknessMap){uvScaleMap=material.thicknessMap;}else if(material.sheenColorMap){uvScaleMap=material.sheenColorMap;}else if(material.sheenRoughnessMap){uvScaleMap=material.sheenRoughnessMap;}if(uvScaleMap!==undefined){// backwards compatibility
  if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}// uv repeat and offset setting priorities for uv2
  // 1. ao map
  // 2. light map
  var uv2ScaleMap;if(material.aoMap){uv2ScaleMap=material.aoMap;}else if(material.lightMap){uv2ScaleMap=material.lightMap;}if(uv2ScaleMap!==undefined){// backwards compatibility
  if(uv2ScaleMap.isWebGLRenderTarget){uv2ScaleMap=uv2ScaleMap.texture;}if(uv2ScaleMap.matrixAutoUpdate===true){uv2ScaleMap.updateMatrix();}uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material,pixelRatio,height){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*pixelRatio;uniforms.scale.value=height*0.5;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. alpha map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. alpha map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
  if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}var envMap=properties.get(material).envMap;if(envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
  uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material,transmissionRenderTarget){refreshUniformsStandard(uniforms,material);uniforms.ior.value=material.ior;// also part of uniforms common
  if(material.sheen>0){uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);uniforms.sheenRoughness.value=material.sheenRoughness;if(material.sheenColorMap){uniforms.sheenColorMap.value=material.sheenColorMap;}if(material.sheenRoughnessMap){uniforms.sheenRoughnessMap.value=material.sheenRoughnessMap;}}if(material.clearcoat>0){uniforms.clearcoat.value=material.clearcoat;uniforms.clearcoatRoughness.value=material.clearcoatRoughness;if(material.clearcoatMap){uniforms.clearcoatMap.value=material.clearcoatMap;}if(material.clearcoatRoughnessMap){uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap;}if(material.clearcoatNormalMap){uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap;if(material.side===BackSide){uniforms.clearcoatNormalScale.value.negate();}}}if(material.transmission>0){uniforms.transmission.value=material.transmission;uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture;uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height);if(material.transmissionMap){uniforms.transmissionMap.value=material.transmissionMap;}uniforms.thickness.value=material.thickness;if(material.thicknessMap){uniforms.thicknessMap.value=material.thicknessMap;}uniforms.attenuationDistance.value=material.attenuationDistance;uniforms.attenuationColor.value.copy(material.attenuationColor);}uniforms.specularIntensity.value=material.specularIntensity;uniforms.specularColor.value.copy(material.specularColor);if(material.specularIntensityMap){uniforms.specularIntensityMap.value=material.specularIntensityMap;}if(material.specularColorMap){uniforms.specularColorMap.value=material.specularColorMap;}}function refreshUniformsMatcap(uniforms,material){if(material.matcap){uniforms.matcap.value=material.matcap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDepth(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDistance(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}uniforms.referencePosition.value.copy(material.referencePosition);uniforms.nearDistance.value=material.nearDistance;uniforms.farDistance.value=material.farDistance;}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}return {refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms};}function createCanvasElement(){var canvas=createElementNS('canvas');canvas.style.display='block';return canvas;}function WebGLRenderer(){var parameters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var _canvas=parameters.canvas!==undefined?parameters.canvas:createCanvasElement(),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false,_powerPreference=parameters.powerPreference!==undefined?parameters.powerPreference:'default',_failIfMajorPerformanceCaveat=parameters.failIfMajorPerformanceCaveat!==undefined?parameters.failIfMajorPerformanceCaveat:false;var currentRenderList=null;var currentRenderState=null;// render() can be called from within a callback triggered by another render.
  // We track this so that the nested render call gets its list and state isolated from the parent render call.
  var renderListStack=[];var renderStateStack=[];// public properties
  this.domElement=_canvas;// Debug configuration container
  this.debug={/**
  		 * Enables error checking and reporting when shader programs are being compiled
  		 * @type {boolean}
  		 */checkShaderErrors:true};// clearing
  this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
  this.sortObjects=true;// user-defined clipping
  this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
  this.gammaFactor=2.0;// for backwards compatibility
  this.outputEncoding=LinearEncoding;// physical lights
  this.physicallyCorrectLights=false;// tone mapping
  this.toneMapping=NoToneMapping;this.toneMappingExposure=1.0;// internal properties
  var _this=this;var _isContextLost=false;// internal state cache
  var _currentActiveCubeFace=0;var _currentActiveMipmapLevel=0;var _currentRenderTarget=null;var _currentMaterialId=-1;var _currentCamera=null;var _currentViewport=new Vector4();var _currentScissor=new Vector4();var _currentScissorTest=null;//
  var _width=_canvas.width;var _height=_canvas.height;var _pixelRatio=1;var _opaqueSort=null;var _transparentSort=null;var _viewport=new Vector4(0,0,_width,_height);var _scissor=new Vector4(0,0,_width,_height);var _scissorTest=false;//
  var _currentDrawBuffers=[];// frustum
  var _frustum=new Frustum();// clipping
  var _clippingEnabled=false;var _localClippingEnabled=false;// transmission
  var _transmissionRenderTarget=null;// camera matrices cache
  var _projScreenMatrix=new Matrix4();var _vector3=new Vector3();var _emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:true};function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
  var _gl=_context;function getContext(contextNames,contextAttributes){for(var _i142=0;_i142<contextNames.length;_i142++){var contextName=contextNames[_i142];var context=_canvas.getContext(contextName,contextAttributes);if(context!==null)return context;}return null;}try{var contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer,powerPreference:_powerPreference,failIfMajorPerformanceCaveat:_failIfMajorPerformanceCaveat};// event listeners must be registered before WebGL context is created, see #12753
  _canvas.addEventListener('webglcontextlost',onContextLost,false);_canvas.addEventListener('webglcontextrestored',onContextRestore,false);if(_gl===null){var contextNames=['webgl2','webgl','experimental-webgl'];if(_this.isWebGL1Renderer===true){contextNames.shift();}_gl=getContext(contextNames,contextAttributes);if(_gl===null){if(getContext(contextNames)){throw new Error('Error creating WebGL context with your selected attributes.');}else {throw new Error('Error creating WebGL context.');}}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
  if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return {'rangeMin':1,'rangeMax':1,'precision':1};};}}catch(error){console.error('THREE.WebGLRenderer: '+error.message);throw error;}var extensions,capabilities,state,info;var properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects;var programCache,materials,renderLists,renderStates,clipping,shadowMap;var background,morphtargets,bufferRenderer,indexedBufferRenderer;var utils,bindingStates;function initGLContext(){extensions=new WebGLExtensions(_gl);capabilities=new WebGLCapabilities(_gl,extensions,parameters);extensions.init(capabilities);utils=new WebGLUtils(_gl,extensions,capabilities);state=new WebGLState(_gl,extensions,capabilities);_currentDrawBuffers[0]=1029;info=new WebGLInfo(_gl);properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);cubemaps=new WebGLCubeMaps(_this);cubeuvmaps=new WebGLCubeUVMaps(_this);attributes=new WebGLAttributes(_gl,capabilities);bindingStates=new WebGLBindingStates(_gl,extensions,attributes,capabilities);geometries=new WebGLGeometries(_gl,attributes,info,bindingStates);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl,capabilities,textures);clipping=new WebGLClipping(properties);programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping);materials=new WebGLMaterials(properties);renderLists=new WebGLRenderLists(properties);renderStates=new WebGLRenderStates(extensions,capabilities);background=new WebGLBackground(_this,cubemaps,state,objects,_premultipliedAlpha);shadowMap=new WebGLShadowMap(_this,objects,capabilities);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info,capabilities);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info,capabilities);info.programs=programCache.programs;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.shadowMap=shadowMap;_this.state=state;_this.info=info;}initGLContext();// xr
  var xr=new WebXRManager(_this,_gl);this.xr=xr;// API
  this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(target){return target.set(_width,_height);};this.setSize=function(width,height,updateStyle){if(xr.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;_canvas.width=Math.floor(width*_pixelRatio);_canvas.height=Math.floor(height*_pixelRatio);if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor();};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=Math.floor(width*pixelRatio);_canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height);};this.getCurrentViewport=function(target){return target.copy(_currentViewport);};this.getViewport=function(target){return target.copy(_viewport);};this.setViewport=function(x,y,width,height){if(x.isVector4){_viewport.set(x.x,x.y,x.z,x.w);}else {_viewport.set(x,y,width,height);}state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());};this.getScissor=function(target){return target.copy(_scissor);};this.setScissor=function(x,y,width,height){if(x.isVector4){_scissor.set(x.x,x.y,x.z,x.w);}else {_scissor.set(x,y,width,height);}state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());};this.getScissorTest=function(){return _scissorTest;};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};this.setOpaqueSort=function(method){_opaqueSort=method;};this.setTransparentSort=function(method){_transparentSort=method;};// Clearing
  this.getClearColor=function(target){return target.copy(background.getClearColor());};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=16384;if(depth===undefined||depth)bits|=256;if(stencil===undefined||stencil)bits|=1024;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};//
  this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);renderLists.dispose();renderStates.dispose();properties.dispose();cubemaps.dispose();cubeuvmaps.dispose();objects.dispose();bindingStates.dispose();xr.dispose();xr.removeEventListener('sessionstart',onXRSessionStart);xr.removeEventListener('sessionend',onXRSessionEnd);if(_transmissionRenderTarget){_transmissionRenderTarget.dispose();_transmissionRenderTarget=null;}animation.stop();};// Events
  function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function/* event */onContextRestore(){console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;var infoAutoReset=info.autoReset;var shadowMapEnabled=shadowMap.enabled;var shadowMapAutoUpdate=shadowMap.autoUpdate;var shadowMapNeedsUpdate=shadowMap.needsUpdate;var shadowMapType=shadowMap.type;initGLContext();info.autoReset=infoAutoReset;shadowMap.enabled=shadowMapEnabled;shadowMap.autoUpdate=shadowMapAutoUpdate;shadowMap.needsUpdate=shadowMapNeedsUpdate;shadowMap.type=shadowMapType;}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
  function deallocateMaterial(material){releaseMaterialProgramReferences(material);properties.remove(material);}function releaseMaterialProgramReferences(material){var programs=properties.get(material).programs;if(programs!==undefined){programs.forEach(function(program){programCache.releaseProgram(program);});}}// Buffer rendering
  this.renderBufferDirect=function(camera,scene,geometry,material,object,group){if(scene===null)scene=_emptyScene;// renderBufferDirect second parameter used to be fog (could be null)
  var frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;var program=setProgram(camera,scene,geometry,material,object);state.setMaterial(material,frontFaceCW);//
  var index=geometry.index;var position=geometry.attributes.position;//
  if(index===null){if(position===undefined||position.count===0)return;}else if(index.count===0){return;}//
  var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}bindingStates.setup(object,material,program,geometry,index);var attribute;var renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}//
  var dataCount=index!==null?index.count:position.count;var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
  if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(1);}else {renderer.setMode(4);}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
  state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(1);}else if(object.isLineLoop){renderer.setMode(2);}else {renderer.setMode(3);}}else if(object.isPoints){renderer.setMode(0);}else if(object.isSprite){renderer.setMode(4);}if(object.isInstancedMesh){renderer.renderInstances(drawStart,drawCount,object.count);}else if(geometry.isInstancedBufferGeometry){var instanceCount=Math.min(geometry.instanceCount,geometry._maxInstanceCount);renderer.renderInstances(drawStart,drawCount,instanceCount);}else {renderer.render(drawStart,drawCount);}};// Compile
  this.compile=function(scene,camera){currentRenderState=renderStates.get(scene);currentRenderState.init();renderStateStack.push(currentRenderState);scene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});currentRenderState.setupLights(_this.physicallyCorrectLights);scene.traverse(function(object){var material=object.material;if(material){if(Array.isArray(material)){for(var _i143=0;_i143<material.length;_i143++){var material2=material[_i143];getProgram(material2,scene,object);}}else {getProgram(material,scene,object);}}});renderStateStack.pop();currentRenderState=null;};// Animation Loop
  var onAnimationFrameCallback=null;function onAnimationFrame(time){if(onAnimationFrameCallback)onAnimationFrameCallback(time);}function onXRSessionStart(){animation.stop();}function onXRSessionEnd(){animation.start();}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);if(typeof window!=='undefined')animation.setContext(window);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;xr.setAnimationLoop(callback);callback===null?animation.stop():animation.start();};xr.addEventListener('sessionstart',onXRSessionStart);xr.addEventListener('sessionend',onXRSessionEnd);// Rendering
  this.render=function(scene,camera){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost===true)return;// update scene graph
  if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
  if(camera.parent===null)camera.updateMatrixWorld();if(xr.enabled===true&&xr.isPresenting===true){if(xr.cameraAutoUpdate===true)xr.updateCamera(camera);camera=xr.getCamera();// use XR camera for rendering
  }//
  if(scene.isScene===true)scene.onBeforeRender(_this,scene,camera,_currentRenderTarget);currentRenderState=renderStates.get(scene,renderStateStack.length);currentRenderState.init();renderStateStack.push(currentRenderState);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,renderListStack.length);currentRenderList.init();renderListStack.push(currentRenderList);projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort(_opaqueSort,_transparentSort);}//
  if(_clippingEnabled===true)clipping.beginShadows();var shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);if(_clippingEnabled===true)clipping.endShadows();//
  if(this.info.autoReset===true)this.info.reset();//
  background.render(currentRenderList,scene);// render scene
  currentRenderState.setupLights(_this.physicallyCorrectLights);if(camera.isArrayCamera){var cameras=camera.cameras;for(var _i144=0,l=cameras.length;_i144<l;_i144++){var camera2=cameras[_i144];renderScene(currentRenderList,scene,camera2,camera2.viewport);}}else {renderScene(currentRenderList,scene,camera);}//
  if(_currentRenderTarget!==null){// resolve multisample renderbuffers to a single-sample texture if necessary
  textures.updateMultisampleRenderTarget(_currentRenderTarget);// Generate mipmap if we're using any kind of mipmap filtering
  textures.updateRenderTargetMipmap(_currentRenderTarget);}//
  if(scene.isScene===true)scene.onAfterRender(_this,scene,camera);// Ensure depth buffer writing is enabled so it can be cleared on next render
  state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);// _gl.finish();
  bindingStates.resetDefaultState();_currentMaterialId=-1;_currentCamera=null;renderStateStack.pop();if(renderStateStack.length>0){currentRenderState=renderStateStack[renderStateStack.length-1];}else {currentRenderState=null;}renderListStack.pop();if(renderListStack.length>0){currentRenderList=renderListStack[renderListStack.length-1];}else {currentRenderList=null;}};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible){if(object.isGroup){groupOrder=object.renderOrder;}else if(object.isLOD){if(object.autoUpdate===true)object.update(camera);}else if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);}}}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){// update skeleton only once in a frame
  if(object.skeleton.frame!==info.render.frame){object.skeleton.update();object.skeleton.frame=info.render.frame;}}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var _geometry2=objects.update(object);var _material=object.material;if(Array.isArray(_material)){var groups=_geometry2.groups;for(var _i145=0,l=groups.length;_i145<l;_i145++){var group=groups[_i145];var groupMaterial=_material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,_geometry2,groupMaterial,groupOrder,_vector3.z,group);}}}else if(_material.visible){currentRenderList.push(object,_geometry2,_material,groupOrder,_vector3.z,null);}}}}var children=object.children;for(var _i146=0,_l5=children.length;_i146<_l5;_i146++){projectObject(children[_i146],camera,groupOrder,sortObjects);}}function renderScene(currentRenderList,scene,camera,viewport){var opaqueObjects=currentRenderList.opaque;var transmissiveObjects=currentRenderList.transmissive;var transparentObjects=currentRenderList.transparent;currentRenderState.setupLightsView(camera);if(transmissiveObjects.length>0)renderTransmissionPass(opaqueObjects,scene,camera);if(viewport)state.viewport(_currentViewport.copy(viewport));if(opaqueObjects.length>0)renderObjects(opaqueObjects,scene,camera);if(transmissiveObjects.length>0)renderObjects(transmissiveObjects,scene,camera);if(transparentObjects.length>0)renderObjects(transparentObjects,scene,camera);}function renderTransmissionPass(opaqueObjects,scene,camera){if(_transmissionRenderTarget===null){var needsAntialias=_antialias===true&&capabilities.isWebGL2===true;var renderTargetType=needsAntialias?WebGLMultisampleRenderTarget:WebGLRenderTarget;_transmissionRenderTarget=new renderTargetType(1024,1024,{generateMipmaps:true,type:utils.convert(HalfFloatType)!==null?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,magFilter:NearestFilter,wrapS:ClampToEdgeWrapping,wrapT:ClampToEdgeWrapping});}var currentRenderTarget=_this.getRenderTarget();_this.setRenderTarget(_transmissionRenderTarget);_this.clear();// Turn off the features which can affect the frag color for opaque objects pass.
  // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
  var currentToneMapping=_this.toneMapping;_this.toneMapping=NoToneMapping;renderObjects(opaqueObjects,scene,camera);_this.toneMapping=currentToneMapping;textures.updateMultisampleRenderTarget(_transmissionRenderTarget);textures.updateRenderTargetMipmap(_transmissionRenderTarget);_this.setRenderTarget(currentRenderTarget);}function renderObjects(renderList,scene,camera){var overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;for(var _i147=0,l=renderList.length;_i147<l;_i147++){var renderItem=renderList[_i147];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===null?renderItem.material:overrideMaterial;var group=renderItem.group;if(object.layers.test(camera.layers)){renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);material.onBeforeRender(_this,scene,camera,geometry,object,group);if(material.transparent===true&&material.side===DoubleSide){material.side=BackSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=FrontSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=DoubleSide;}else {_this.renderBufferDirect(camera,scene,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}function getProgram(material,scene,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
  var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;var shadowsArray=currentRenderState.state.shadowsArray;var lightsStateVersion=lights.state.version;var parameters=programCache.getParameters(material,lights.state,shadowsArray,scene,object);var programCacheKey=programCache.getProgramCacheKey(parameters);var programs=materialProperties.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
  materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.fog=scene.fog;materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||materialProperties.environment);if(programs===undefined){// new material
  material.addEventListener('dispose',onMaterialDispose);programs=new Map();materialProperties.programs=programs;}var program=programs.get(programCacheKey);if(program!==undefined){// early out if program and light state is identical
  if(materialProperties.currentProgram===program&&materialProperties.lightsStateVersion===lightsStateVersion){updateCommonMaterialProperties(material,parameters);return program;}}else {parameters.uniforms=programCache.getUniforms(material);material.onBuild(object,parameters,_this);material.onBeforeCompile(parameters,_this);program=programCache.acquireProgram(parameters,programCacheKey);programs.set(programCacheKey,program);materialProperties.uniforms=parameters.uniforms;}var uniforms=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){uniforms.clippingPlanes=clipping.uniform;}updateCommonMaterialProperties(material,parameters);// store the light setup it was created for
  materialProperties.needsLights=materialNeedsLights(material);materialProperties.lightsStateVersion=lightsStateVersion;if(materialProperties.needsLights){// wire up the material to this renderer's lighting state
  uniforms.ambientLightColor.value=lights.state.ambient;uniforms.lightProbe.value=lights.state.probe;uniforms.directionalLights.value=lights.state.directional;uniforms.directionalLightShadows.value=lights.state.directionalShadow;uniforms.spotLights.value=lights.state.spot;uniforms.spotLightShadows.value=lights.state.spotShadow;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.ltc_1.value=lights.state.rectAreaLTC1;uniforms.ltc_2.value=lights.state.rectAreaLTC2;uniforms.pointLights.value=lights.state.point;uniforms.pointLightShadows.value=lights.state.pointShadow;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotShadowMatrix.value=lights.state.spotShadowMatrix;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
  }var progUniforms=program.getUniforms();var uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.currentProgram=program;materialProperties.uniformsList=uniformsList;return program;}function updateCommonMaterialProperties(material,parameters){var materialProperties=properties.get(material);materialProperties.outputEncoding=parameters.outputEncoding;materialProperties.instancing=parameters.instancing;materialProperties.skinning=parameters.skinning;materialProperties.morphTargets=parameters.morphTargets;materialProperties.morphNormals=parameters.morphNormals;materialProperties.morphTargetsCount=parameters.morphTargetsCount;materialProperties.numClippingPlanes=parameters.numClippingPlanes;materialProperties.numIntersection=parameters.numClipIntersection;materialProperties.vertexAlphas=parameters.vertexAlphas;materialProperties.vertexTangents=parameters.vertexTangents;}function setProgram(camera,scene,geometry,material,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
  textures.resetTextureUnits();var fog=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null;var encoding=_currentRenderTarget===null?_this.outputEncoding:_currentRenderTarget.texture.encoding;var envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);var vertexAlphas=material.vertexColors===true&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4;var vertexTangents=!!material.normalMap&&!!geometry.attributes.tangent;var morphTargets=!!geometry.morphAttributes.position;var morphNormals=!!geometry.morphAttributes.normal;var morphTargetsCount=!!geometry.morphAttributes.position?geometry.morphAttributes.position.length:0;var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;if(_clippingEnabled===true){if(_localClippingEnabled===true||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
  // object instead of the material, once it becomes feasible
  // (#8465, #8379)
  clipping.setState(material,camera,useCache);}}//
  var needsProgramChange=false;if(material.version===materialProperties.__version){if(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version){needsProgramChange=true;}else if(materialProperties.outputEncoding!==encoding){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancing===false){needsProgramChange=true;}else if(!object.isInstancedMesh&&materialProperties.instancing===true){needsProgramChange=true;}else if(object.isSkinnedMesh&&materialProperties.skinning===false){needsProgramChange=true;}else if(!object.isSkinnedMesh&&materialProperties.skinning===true){needsProgramChange=true;}else if(materialProperties.envMap!==envMap){needsProgramChange=true;}else if(material.fog&&materialProperties.fog!==fog){needsProgramChange=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==clipping.numPlanes||materialProperties.numIntersection!==clipping.numIntersection)){needsProgramChange=true;}else if(materialProperties.vertexAlphas!==vertexAlphas){needsProgramChange=true;}else if(materialProperties.vertexTangents!==vertexTangents){needsProgramChange=true;}else if(materialProperties.morphTargets!==morphTargets){needsProgramChange=true;}else if(materialProperties.morphNormals!==morphNormals){needsProgramChange=true;}else if(capabilities.isWebGL2===true&&materialProperties.morphTargetsCount!==morphTargetsCount){needsProgramChange=true;}}else {needsProgramChange=true;materialProperties.__version=material.version;}//
  var program=materialProperties.currentProgram;if(needsProgramChange===true){program=getProgram(material,scene,object);}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||_currentCamera!==camera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(_currentCamera!==camera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
  // now, in case this material supports lights - or later, when
  // the next material that does gets activated:
  refreshMaterial=true;// set to true on material change
  refreshLights=true;// remains set until update done
  }// load material specific uniforms
  // (shader material also gets them for the sake of genericity)
  if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial){p_uniforms.setValue(_gl,'isOrthographic',camera.isOrthographicCamera===true);}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.isShadowMaterial||object.isSkinnedMesh){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}}// skinning and morph target uniforms must be set even if material didn't change
  // auto-setting of texture unit for bone and morph texture must go before other textures
  // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
  if(object.isSkinnedMesh){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){if(capabilities.floatVertexTextures){if(skeleton.boneTexture===null)skeleton.computeBoneTexture();p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else {p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(!!geometry&&(geometry.morphAttributes.position!==undefined||geometry.morphAttributes.normal!==undefined)){morphtargets.update(object,geometry,material,program);}if(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow){materialProperties.receiveShadow=object.receiveShadow;p_uniforms.setValue(_gl,'receiveShadow',object.receiveShadow);}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);if(materialProperties.needsLights){// the current material requires lighting info
  // note: all lighting uniforms are always set correctly
  // they simply reference the renderer's state for their
  // values
  //
  // use the current material's .needsUpdate flags to set
  // the GL state when required
  markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
  if(fog&&material.fog){materials.refreshFogUniforms(m_uniforms,fog);}materials.refreshMaterialUniforms(m_uniforms,material,_pixelRatio,_height,_transmissionRenderTarget);WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);material.uniformsNeedUpdate=false;}if(material.isSpriteMaterial){p_uniforms.setValue(_gl,'center',object.center);}// common matrices
  p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
  function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.lightProbe.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.directionalLightShadows.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.pointLightShadows.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.spotLightShadows.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===true;}this.getActiveCubeFace=function(){return _currentActiveCubeFace;};this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel;};this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget){var activeCubeFace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var activeMipmapLevel=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var framebuffer=null;var isCube=false;var isRenderTarget3D=false;if(renderTarget){var texture=renderTarget.texture;if(texture.isDataTexture3D||texture.isDataTexture2DArray){isRenderTarget3D=true;}var __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget){framebuffer=__webglFramebuffer[activeCubeFace];isCube=true;}else if(renderTarget.isWebGLMultisampleRenderTarget){framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;}else {framebuffer=__webglFramebuffer;}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else {_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();_currentScissorTest=_scissorTest;}var framebufferBound=state.bindFramebuffer(36160,framebuffer);if(framebufferBound&&capabilities.drawBuffers){var needsUpdate=false;if(renderTarget){if(renderTarget.isWebGLMultipleRenderTargets){var _textures2=renderTarget.texture;if(_currentDrawBuffers.length!==_textures2.length||_currentDrawBuffers[0]!==36064){for(var _i148=0,il=_textures2.length;_i148<il;_i148++){_currentDrawBuffers[_i148]=36064+_i148;}_currentDrawBuffers.length=_textures2.length;needsUpdate=true;}}else {if(_currentDrawBuffers.length!==1||_currentDrawBuffers[0]!==36064){_currentDrawBuffers[0]=36064;_currentDrawBuffers.length=1;needsUpdate=true;}}}else {if(_currentDrawBuffers.length!==1||_currentDrawBuffers[0]!==1029){_currentDrawBuffers[0]=1029;_currentDrawBuffers.length=1;needsUpdate=true;}}if(needsUpdate){if(capabilities.isWebGL2){_gl.drawBuffers(_currentDrawBuffers);}else {extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);}}}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(36160,36064,34069+activeCubeFace,textureProperties.__webglTexture,activeMipmapLevel);}else if(isRenderTarget3D){var _textureProperties=properties.get(renderTarget.texture);var layer=activeCubeFace||0;_gl.framebufferTextureLayer(36160,36064,_textureProperties.__webglTexture,activeMipmapLevel||0,layer);}_currentMaterialId=-1;// reset current material to ensure correct uniform bindings
  };this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){state.bindFramebuffer(36160,framebuffer);try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(35739)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}var halfFloatSupportedByExt=textureType===HalfFloatType&&(extensions.has('EXT_color_buffer_half_float')||capabilities.isWebGL2&&extensions.has('EXT_color_buffer_float'));if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(35738)&&// Edge and Chrome Mac < 52 (#9513)
  !(textureType===FloatType&&(capabilities.isWebGL2||extensions.has('OES_texture_float')||extensions.has('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
  !halfFloatSupportedByExt){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(36160)===36053){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
  if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}else {console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{// restore framebuffer of current render target if necessary
  var _framebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(36160,_framebuffer);}}};this.copyFramebufferToTexture=function(position,texture){var level=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var levelScale=Math.pow(2,-level);var width=Math.floor(texture.image.width*levelScale);var height=Math.floor(texture.image.height*levelScale);var glFormat=utils.convert(texture.format);if(capabilities.isWebGL2){// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
  // Not needed in Chrome 93+
  if(glFormat===6407)glFormat=32849;if(glFormat===6408)glFormat=32856;}textures.setTexture2D(texture,0);_gl.copyTexImage2D(3553,level,glFormat,position.x,position.y,width,height,0);state.unbindTexture();};this.copyTextureToTexture=function(position,srcTexture,dstTexture){var level=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var width=srcTexture.image.width;var height=srcTexture.image.height;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);textures.setTexture2D(dstTexture,0);// As another texture upload may have changed pixelStorei
  // parameters, make sure they are correct for the dstTexture
  _gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);if(srcTexture.isDataTexture){_gl.texSubImage2D(3553,level,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data);}else {if(srcTexture.isCompressedTexture){_gl.compressedTexSubImage2D(3553,level,position.x,position.y,srcTexture.mipmaps[0].width,srcTexture.mipmaps[0].height,glFormat,srcTexture.mipmaps[0].data);}else {_gl.texSubImage2D(3553,level,position.x,position.y,glFormat,glType,srcTexture.image);}}// Generate mipmaps only when copying level 0
  if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(3553);state.unbindTexture();};this.copyTextureToTexture3D=function(sourceBox,position,srcTexture,dstTexture){var level=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;if(_this.isWebGL1Renderer){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');return;}var width=sourceBox.max.x-sourceBox.min.x+1;var height=sourceBox.max.y-sourceBox.min.y+1;var depth=sourceBox.max.z-sourceBox.min.z+1;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);var glTarget;if(dstTexture.isDataTexture3D){textures.setTexture3D(dstTexture,0);glTarget=32879;}else if(dstTexture.isDataTexture2DArray){textures.setTexture2DArray(dstTexture,0);glTarget=35866;}else {console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');return;}_gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);var unpackRowLen=_gl.getParameter(3314);var unpackImageHeight=_gl.getParameter(32878);var unpackSkipPixels=_gl.getParameter(3316);var unpackSkipRows=_gl.getParameter(3315);var unpackSkipImages=_gl.getParameter(32877);var image=srcTexture.isCompressedTexture?srcTexture.mipmaps[0]:srcTexture.image;_gl.pixelStorei(3314,image.width);_gl.pixelStorei(32878,image.height);_gl.pixelStorei(3316,sourceBox.min.x);_gl.pixelStorei(3315,sourceBox.min.y);_gl.pixelStorei(32877,sourceBox.min.z);if(srcTexture.isDataTexture||srcTexture.isDataTexture3D){_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image.data);}else {if(srcTexture.isCompressedTexture){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');_gl.compressedTexSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,image.data);}else {_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image);}}_gl.pixelStorei(3314,unpackRowLen);_gl.pixelStorei(32878,unpackImageHeight);_gl.pixelStorei(3316,unpackSkipPixels);_gl.pixelStorei(3315,unpackSkipRows);_gl.pixelStorei(32877,unpackSkipImages);// Generate mipmaps only when copying level 0
  if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(glTarget);state.unbindTexture();};this.initTexture=function(texture){textures.setTexture2D(texture,0);state.unbindTexture();};this.resetState=function(){_currentActiveCubeFace=0;_currentActiveMipmapLevel=0;_currentRenderTarget=null;state.reset();bindingStates.reset();};if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));// eslint-disable-line no-undef
  }}WebGLRenderer.prototype.isWebGLRenderer=true;class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=true;class FogExp2{constructor(color){var density=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0.00025;this.name='';this.color=new Color(color);this.density=density;}clone(){return new FogExp2(this.color,this.density);}toJSON(){return {type:'FogExp2',color:this.color.getHex(),density:this.density};}}FogExp2.prototype.isFogExp2=true;class Fog{constructor(color){var near=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var far=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1000;this.name='';this.color=new Color(color);this.near=near;this.far=far;}clone(){return new Fog(this.color,this.near,this.far);}toJSON(){return {type:'Fog',color:this.color.getHex(),near:this.near,far:this.far};}}Fog.prototype.isFog=true;class Scene extends Object3D{constructor(){super();this.type='Scene';this.background=null;this.environment=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
  if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));// eslint-disable-line no-undef
  }}copy(source,recursive){super.copy(source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.environment!==null)this.environment=source.environment.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;}toJSON(meta){var data=super.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}}Scene.prototype.isScene=true;class InterleavedBuffer{constructor(array,stride){this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;this.uuid=generateUUID();}onUploadCallback(){}set needsUpdate(value){if(value===true)this.version++;}setUsage(value){this.usage=value;return this;}copy(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.usage=source.usage;return this;}copyAt(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(var _i149=0,l=this.stride;_i149<l;_i149++){this.array[index1+_i149]=attribute.array[index2+_i149];}return this;}set(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.array.set(value,offset);return this;}clone(data){if(data.arrayBuffers===undefined){data.arrayBuffers={};}if(this.array.buffer._uuid===undefined){this.array.buffer._uuid=generateUUID();}if(data.arrayBuffers[this.array.buffer._uuid]===undefined){data.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer;}var array=new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);var ib=new this.constructor(array,this.stride);ib.setUsage(this.usage);return ib;}onUpload(callback){this.onUploadCallback=callback;return this;}toJSON(data){if(data.arrayBuffers===undefined){data.arrayBuffers={};}// generate UUID for array buffer if necessary
  if(this.array.buffer._uuid===undefined){this.array.buffer._uuid=generateUUID();}if(data.arrayBuffers[this.array.buffer._uuid]===undefined){data.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer));}//
  return {uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride};}}InterleavedBuffer.prototype.isInterleavedBuffer=true;var _vector$6=/*@__PURE__*/new Vector3();class InterleavedBufferAttribute{constructor(interleavedBuffer,itemSize,offset){var normalized=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;this.name='';this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}get count(){return this.data.count;}get array(){return this.data.array;}set needsUpdate(value){this.data.needsUpdate=value;}applyMatrix4(m){for(var _i150=0,l=this.data.count;_i150<l;_i150++){_vector$6.x=this.getX(_i150);_vector$6.y=this.getY(_i150);_vector$6.z=this.getZ(_i150);_vector$6.applyMatrix4(m);this.setXYZ(_i150,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}applyNormalMatrix(m){for(var _i151=0,l=this.count;_i151<l;_i151++){_vector$6.x=this.getX(_i151);_vector$6.y=this.getY(_i151);_vector$6.z=this.getZ(_i151);_vector$6.applyNormalMatrix(m);this.setXYZ(_i151,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}transformDirection(m){for(var _i152=0,l=this.count;_i152<l;_i152++){_vector$6.x=this.getX(_i152);_vector$6.y=this.getY(_i152);_vector$6.z=this.getZ(_i152);_vector$6.transformDirection(m);this.setXYZ(_i152,_vector$6.x,_vector$6.y,_vector$6.z);}return this;}setX(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;}setY(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;}setZ(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;}setW(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;}getX(index){return this.data.array[index*this.data.stride+this.offset];}getY(index){return this.data.array[index*this.data.stride+this.offset+1];}getZ(index){return this.data.array[index*this.data.stride+this.offset+2];}getW(index){return this.data.array[index*this.data.stride+this.offset+3];}setXY(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;}setXYZ(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;}setXYZW(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}clone(data){if(data===undefined){console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');var array=[];for(var _i153=0;_i153<this.count;_i153++){var index=_i153*this.data.stride+this.offset;for(var j=0;j<this.itemSize;j++){array.push(this.data.array[index+j]);}}return new BufferAttribute(new this.array.constructor(array),this.itemSize,this.normalized);}else {if(data.interleavedBuffers===undefined){data.interleavedBuffers={};}if(data.interleavedBuffers[this.data.uuid]===undefined){data.interleavedBuffers[this.data.uuid]=this.data.clone(data);}return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);}}toJSON(data){if(data===undefined){console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');var array=[];for(var _i154=0;_i154<this.count;_i154++){var index=_i154*this.data.stride+this.offset;for(var j=0;j<this.itemSize;j++){array.push(this.data.array[index+j]);}}// deinterleave data and save it as an ordinary buffer attribute for now
  return {itemSize:this.itemSize,type:this.array.constructor.name,array:array,normalized:this.normalized};}else {// save as true interlaved attribtue
  if(data.interleavedBuffers===undefined){data.interleavedBuffers={};}if(data.interleavedBuffers[this.data.uuid]===undefined){data.interleavedBuffers[this.data.uuid]=this.data.toJSON(data);}return {isInterleavedBufferAttribute:true,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};}}}InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute=true;/**
   * parameters = {
   *  color: <hex>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *  rotation: <float>,
   *  sizeAttenuation: <bool>
   * }
   */class SpriteMaterial extends Material{constructor(parameters){super();this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.alphaMap=null;this.rotation=0;this.sizeAttenuation=true;this.transparent=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.rotation=source.rotation;this.sizeAttenuation=source.sizeAttenuation;return this;}}SpriteMaterial.prototype.isSpriteMaterial=true;var _geometry;var _intersectPoint=/*@__PURE__*/new Vector3();var _worldScale=/*@__PURE__*/new Vector3();var _mvPosition=/*@__PURE__*/new Vector3();var _alignedPosition=/*@__PURE__*/new Vector2();var _rotatedPosition=/*@__PURE__*/new Vector2();var _viewWorldMatrix=/*@__PURE__*/new Matrix4();var _vA=/*@__PURE__*/new Vector3();var _vB=/*@__PURE__*/new Vector3();var _vC=/*@__PURE__*/new Vector3();var _uvA=/*@__PURE__*/new Vector2();var _uvB=/*@__PURE__*/new Vector2();var _uvC=/*@__PURE__*/new Vector2();class Sprite extends Object3D{constructor(material){super();this.type='Sprite';if(_geometry===undefined){_geometry=new BufferGeometry();var float32Array=new Float32Array([-0.5,-0.5,0,0,0,0.5,-0.5,0,1,0,0.5,0.5,0,1,1,-0.5,0.5,0,0,1]);var interleavedBuffer=new InterleavedBuffer(float32Array,5);_geometry.setIndex([0,1,2,0,2,3]);_geometry.setAttribute('position',new InterleavedBufferAttribute(interleavedBuffer,3,0,false));_geometry.setAttribute('uv',new InterleavedBufferAttribute(interleavedBuffer,2,3,false));}this.geometry=_geometry;this.material=material!==undefined?material:new SpriteMaterial();this.center=new Vector2(0.5,0.5);}raycast(raycaster,intersects){if(raycaster.camera===null){console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');}_worldScale.setFromMatrixScale(this.matrixWorld);_viewWorldMatrix.copy(raycaster.camera.matrixWorld);this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse,this.matrixWorld);_mvPosition.setFromMatrixPosition(this.modelViewMatrix);if(raycaster.camera.isPerspectiveCamera&&this.material.sizeAttenuation===false){_worldScale.multiplyScalar(-_mvPosition.z);}var rotation=this.material.rotation;var sin,cos;if(rotation!==0){cos=Math.cos(rotation);sin=Math.sin(rotation);}var center=this.center;transformVertex(_vA.set(-0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vB.set(0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vC.set(0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvA.set(0,0);_uvB.set(1,0);_uvC.set(1,1);// check first triangle
  var intersect=raycaster.ray.intersectTriangle(_vA,_vB,_vC,false,_intersectPoint);if(intersect===null){// check second triangle
  transformVertex(_vB.set(-0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvB.set(0,1);intersect=raycaster.ray.intersectTriangle(_vA,_vC,_vB,false,_intersectPoint);if(intersect===null){return;}}var distance=raycaster.ray.origin.distanceTo(_intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:_intersectPoint.clone(),uv:Triangle.getUV(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2()),face:null,object:this});}copy(source){super.copy(source);if(source.center!==undefined)this.center.copy(source.center);this.material=source.material;return this;}}Sprite.prototype.isSprite=true;function transformVertex(vertexPosition,mvPosition,center,scale,sin,cos){// compute position in camera space
  _alignedPosition.subVectors(vertexPosition,center).addScalar(0.5).multiply(scale);// to check if rotation is not zero
  if(sin!==undefined){_rotatedPosition.x=cos*_alignedPosition.x-sin*_alignedPosition.y;_rotatedPosition.y=sin*_alignedPosition.x+cos*_alignedPosition.y;}else {_rotatedPosition.copy(_alignedPosition);}vertexPosition.copy(mvPosition);vertexPosition.x+=_rotatedPosition.x;vertexPosition.y+=_rotatedPosition.y;// transform to world space
  vertexPosition.applyMatrix4(_viewWorldMatrix);}var _basePosition=/*@__PURE__*/new Vector3();var _skinIndex=/*@__PURE__*/new Vector4();var _skinWeight=/*@__PURE__*/new Vector4();var _vector$5=/*@__PURE__*/new Vector3();var _matrix=/*@__PURE__*/new Matrix4();class SkinnedMesh extends Mesh{constructor(geometry,material){super(geometry,material);this.type='SkinnedMesh';this.bindMode='attached';this.bindMatrix=new Matrix4();this.bindMatrixInverse=new Matrix4();}copy(source){super.copy(source);this.bindMode=source.bindMode;this.bindMatrix.copy(source.bindMatrix);this.bindMatrixInverse.copy(source.bindMatrixInverse);this.skeleton=source.skeleton;return this;}bind(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.copy(bindMatrix).invert();}pose(){this.skeleton.pose();}normalizeSkinWeights(){var vector=new Vector4();var skinWeight=this.geometry.attributes.skinWeight;for(var _i159=0,l=skinWeight.count;_i159<l;_i159++){vector.x=skinWeight.getX(_i159);vector.y=skinWeight.getY(_i159);vector.z=skinWeight.getZ(_i159);vector.w=skinWeight.getW(_i159);var scale=1.0/vector.manhattanLength();if(scale!==Infinity){vector.multiplyScalar(scale);}else {vector.set(1,0,0,0);// do something reasonable
  }skinWeight.setXYZW(_i159,vector.x,vector.y,vector.z,vector.w);}}updateMatrixWorld(force){super.updateMatrixWorld(force);if(this.bindMode==='attached'){this.bindMatrixInverse.copy(this.matrixWorld).invert();}else if(this.bindMode==='detached'){this.bindMatrixInverse.copy(this.bindMatrix).invert();}else {console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);}}boneTransform(index,target){var skeleton=this.skeleton;var geometry=this.geometry;_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex,index);_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight,index);_basePosition.copy(target).applyMatrix4(this.bindMatrix);target.set(0,0,0);for(var _i160=0;_i160<4;_i160++){var weight=_skinWeight.getComponent(_i160);if(weight!==0){var boneIndex=_skinIndex.getComponent(_i160);_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld,skeleton.boneInverses[boneIndex]);target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix),weight);}}return target.applyMatrix4(this.bindMatrixInverse);}}SkinnedMesh.prototype.isSkinnedMesh=true;class Bone extends Object3D{constructor(){super();this.type='Bone';}}Bone.prototype.isBone=true;class DataTexture extends Texture{constructor(){var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var format=arguments.length>3?arguments[3]:undefined;var type=arguments.length>4?arguments[4]:undefined;var mapping=arguments.length>5?arguments[5]:undefined;var wrapS=arguments.length>6?arguments[6]:undefined;var wrapT=arguments.length>7?arguments[7]:undefined;var magFilter=arguments.length>8&&arguments[8]!==undefined?arguments[8]:NearestFilter;var minFilter=arguments.length>9&&arguments[9]!==undefined?arguments[9]:NearestFilter;var anisotropy=arguments.length>10?arguments[10]:undefined;var encoding=arguments.length>11?arguments[11]:undefined;super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data,width:width,height:height};this.magFilter=magFilter;this.minFilter=minFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.needsUpdate=true;}}DataTexture.prototype.isDataTexture=true;var _offsetMatrix=/*@__PURE__*/new Matrix4();var _identityMatrix=/*@__PURE__*/new Matrix4();class Skeleton{constructor(){var bones=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var boneInverses=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];this.uuid=generateUUID();this.bones=bones.slice(0);this.boneInverses=boneInverses;this.boneMatrices=null;this.boneTexture=null;this.boneTextureSize=0;this.frame=-1;this.init();}init(){var bones=this.bones;var boneInverses=this.boneInverses;this.boneMatrices=new Float32Array(bones.length*16);// calculate inverse bone matrices if necessary
  if(boneInverses.length===0){this.calculateInverses();}else {// handle special case
  if(bones.length!==boneInverses.length){console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');this.boneInverses=[];for(var _i161=0,il=this.bones.length;_i161<il;_i161++){this.boneInverses.push(new Matrix4());}}}}calculateInverses(){this.boneInverses.length=0;for(var _i162=0,il=this.bones.length;_i162<il;_i162++){var inverse=new Matrix4();if(this.bones[_i162]){inverse.copy(this.bones[_i162].matrixWorld).invert();}this.boneInverses.push(inverse);}}pose(){// recover the bind-time world matrices
  for(var _i163=0,il=this.bones.length;_i163<il;_i163++){var bone=this.bones[_i163];if(bone){bone.matrixWorld.copy(this.boneInverses[_i163]).invert();}}// compute the local matrices, positions, rotations and scales
  for(var _i164=0,_il12=this.bones.length;_i164<_il12;_i164++){var _bone=this.bones[_i164];if(_bone){if(_bone.parent&&_bone.parent.isBone){_bone.matrix.copy(_bone.parent.matrixWorld).invert();_bone.matrix.multiply(_bone.matrixWorld);}else {_bone.matrix.copy(_bone.matrixWorld);}_bone.matrix.decompose(_bone.position,_bone.quaternion,_bone.scale);}}}update(){var bones=this.bones;var boneInverses=this.boneInverses;var boneMatrices=this.boneMatrices;var boneTexture=this.boneTexture;// flatten bone matrices to array
  for(var _i165=0,il=bones.length;_i165<il;_i165++){// compute the offset between the current and the original transform
  var matrix=bones[_i165]?bones[_i165].matrixWorld:_identityMatrix;_offsetMatrix.multiplyMatrices(matrix,boneInverses[_i165]);_offsetMatrix.toArray(boneMatrices,_i165*16);}if(boneTexture!==null){boneTexture.needsUpdate=true;}}clone(){return new Skeleton(this.bones,this.boneInverses);}computeBoneTexture(){// layout (1 matrix = 4 pixels)
  //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
  var size=Math.sqrt(this.bones.length*4);// 4 pixels needed for 1 matrix
  size=ceilPowerOfTwo(size);size=Math.max(size,4);var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
  boneMatrices.set(this.boneMatrices);// copy current values
  var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);this.boneMatrices=boneMatrices;this.boneTexture=boneTexture;this.boneTextureSize=size;return this;}getBoneByName(name){for(var _i166=0,il=this.bones.length;_i166<il;_i166++){var bone=this.bones[_i166];if(bone.name===name){return bone;}}return undefined;}dispose(){if(this.boneTexture!==null){this.boneTexture.dispose();this.boneTexture=null;}}fromJSON(json,bones){this.uuid=json.uuid;for(var _i167=0,l=json.bones.length;_i167<l;_i167++){var uuid=json.bones[_i167];var bone=bones[uuid];if(bone===undefined){console.warn('THREE.Skeleton: No bone found with UUID:',uuid);bone=new Bone();}this.bones.push(bone);this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[_i167]));}this.init();return this;}toJSON(){var data={metadata:{version:4.5,type:'Skeleton',generator:'Skeleton.toJSON'},bones:[],boneInverses:[]};data.uuid=this.uuid;var bones=this.bones;var boneInverses=this.boneInverses;for(var _i168=0,l=bones.length;_i168<l;_i168++){var bone=bones[_i168];data.bones.push(bone.uuid);var boneInverse=boneInverses[_i168];data.boneInverses.push(boneInverse.toArray());}return data;}}class InstancedBufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){var meshPerAttribute=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;if(typeof normalized==='number'){meshPerAttribute=normalized;normalized=false;console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');}super(array,itemSize,normalized);this.meshPerAttribute=meshPerAttribute;}copy(source){super.copy(source);this.meshPerAttribute=source.meshPerAttribute;return this;}toJSON(){var data=super.toJSON();data.meshPerAttribute=this.meshPerAttribute;data.isInstancedBufferAttribute=true;return data;}}InstancedBufferAttribute.prototype.isInstancedBufferAttribute=true;var _instanceLocalMatrix=/*@__PURE__*/new Matrix4();var _instanceWorldMatrix=/*@__PURE__*/new Matrix4();var _instanceIntersects=[];var _mesh=/*@__PURE__*/new Mesh();class InstancedMesh extends Mesh{constructor(geometry,material,count){super(geometry,material);this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(count*16),16);this.instanceColor=null;this.count=count;this.frustumCulled=false;}copy(source){super.copy(source);this.instanceMatrix.copy(source.instanceMatrix);if(source.instanceColor!==null)this.instanceColor=source.instanceColor.clone();this.count=source.count;return this;}getColorAt(index,color){color.fromArray(this.instanceColor.array,index*3);}getMatrixAt(index,matrix){matrix.fromArray(this.instanceMatrix.array,index*16);}raycast(raycaster,intersects){var matrixWorld=this.matrixWorld;var raycastTimes=this.count;_mesh.geometry=this.geometry;_mesh.material=this.material;if(_mesh.material===undefined)return;for(var instanceId=0;instanceId<raycastTimes;instanceId++){// calculate the world matrix for each instance
  this.getMatrixAt(instanceId,_instanceLocalMatrix);_instanceWorldMatrix.multiplyMatrices(matrixWorld,_instanceLocalMatrix);// the mesh represents this single instance
  _mesh.matrixWorld=_instanceWorldMatrix;_mesh.raycast(raycaster,_instanceIntersects);// process the result of raycast
  for(var _i169=0,l=_instanceIntersects.length;_i169<l;_i169++){var intersect=_instanceIntersects[_i169];intersect.instanceId=instanceId;intersect.object=this;intersects.push(intersect);}_instanceIntersects.length=0;}}setColorAt(index,color){if(this.instanceColor===null){this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3),3);}color.toArray(this.instanceColor.array,index*3);}setMatrixAt(index,matrix){matrix.toArray(this.instanceMatrix.array,index*16);}updateMorphTargets(){}dispose(){this.dispatchEvent({type:'dispose'});}}InstancedMesh.prototype.isInstancedMesh=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */class LineBasicMaterial extends Material{constructor(parameters){super();this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;}}LineBasicMaterial.prototype.isLineBasicMaterial=true;var _start$1=/*@__PURE__*/new Vector3();var _end$1=/*@__PURE__*/new Vector3();var _inverseMatrix$1=/*@__PURE__*/new Matrix4();var _ray$1=/*@__PURE__*/new Ray();var _sphere$1=/*@__PURE__*/new Sphere();class Line extends Object3D{constructor(){var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new BufferGeometry();var material=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new LineBasicMaterial();super();this.type='Line';this.geometry=geometry;this.material=material;this.updateMorphTargets();}copy(source){super.copy(source);this.material=source.material;this.geometry=source.geometry;return this;}computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
  if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[0];for(var _i170=1,l=positionAttribute.count;_i170<l;_i170++){_start$1.fromBufferAttribute(positionAttribute,_i170-1);_end$1.fromBufferAttribute(positionAttribute,_i170);lineDistances[_i170]=lineDistances[_i170-1];lineDistances[_i170]+=_start$1.distanceTo(_end$1);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else {console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}return this;}raycast(raycaster,intersects){var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Line.threshold;var drawRange=geometry.drawRange;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$1.copy(geometry.boundingSphere);_sphere$1.applyMatrix4(matrixWorld);_sphere$1.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere$1)===false)return;//
  _inverseMatrix$1.copy(matrixWorld).invert();_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positionAttribute=attributes.position;if(index!==null){var start=Math.max(0,drawRange.start);var end=Math.min(index.count,drawRange.start+drawRange.count);for(var _i171=start,l=end-1;_i171<l;_i171+=step){var a=index.getX(_i171);var b=index.getX(_i171+1);vStart.fromBufferAttribute(positionAttribute,a);vEnd.fromBufferAttribute(positionAttribute,b);var distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
  var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
  // point: raycaster.ray.at( distance ),
  point:interSegment.clone().applyMatrix4(this.matrixWorld),index:_i171,face:null,faceIndex:null,object:this});}}else {var _start6=Math.max(0,drawRange.start);var _end5=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(var _i172=_start6,_l6=_end5-1;_i172<_l6;_i172+=step){vStart.fromBufferAttribute(positionAttribute,_i172);vEnd.fromBufferAttribute(positionAttribute,_i172+1);var _distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(_distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
  var _distance=raycaster.ray.origin.distanceTo(interRay);if(_distance<raycaster.near||_distance>raycaster.far)continue;intersects.push({distance:_distance,// What do we want? intersection point on the ray or on the segment??
  // point: raycaster.ray.at( distance ),
  point:interSegment.clone().applyMatrix4(this.matrixWorld),index:_i172,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}updateMorphTargets(){var geometry=this.geometry;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphAttribute.length;m<ml;m++){var name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else {var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');}}}}Line.prototype.isLine=true;var _start=/*@__PURE__*/new Vector3();var _end=/*@__PURE__*/new Vector3();class LineSegments extends Line{constructor(geometry,material){super(geometry,material);this.type='LineSegments';}computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
  if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[];for(var _i173=0,l=positionAttribute.count;_i173<l;_i173+=2){_start.fromBufferAttribute(positionAttribute,_i173);_end.fromBufferAttribute(positionAttribute,_i173+1);lineDistances[_i173]=_i173===0?0:lineDistances[_i173-1];lineDistances[_i173+1]=lineDistances[_i173]+_start.distanceTo(_end);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else {console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}return this;}}LineSegments.prototype.isLineSegments=true;class LineLoop extends Line{constructor(geometry,material){super(geometry,material);this.type='LineLoop';}}LineLoop.prototype.isLineLoop=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   *
   * }
   */class PointsMaterial extends Material{constructor(parameters){super();this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.alphaMap=null;this.size=1;this.sizeAttenuation=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;}}PointsMaterial.prototype.isPointsMaterial=true;var _inverseMatrix=/*@__PURE__*/new Matrix4();var _ray=/*@__PURE__*/new Ray();var _sphere=/*@__PURE__*/new Sphere();var _position$2=/*@__PURE__*/new Vector3();class Points extends Object3D{constructor(){var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new BufferGeometry();var material=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new PointsMaterial();super();this.type='Points';this.geometry=geometry;this.material=material;this.updateMorphTargets();}copy(source){super.copy(source);this.material=source.material;this.geometry=source.geometry;return this;}raycast(raycaster,intersects){var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;var drawRange=geometry.drawRange;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere.copy(geometry.boundingSphere);_sphere.applyMatrix4(matrixWorld);_sphere.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere)===false)return;//
  _inverseMatrix.copy(matrixWorld).invert();_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positionAttribute=attributes.position;if(index!==null){var start=Math.max(0,drawRange.start);var end=Math.min(index.count,drawRange.start+drawRange.count);for(var _i174=start,il=end;_i174<il;_i174++){var a=index.getX(_i174);_position$2.fromBufferAttribute(positionAttribute,a);testPoint(_position$2,a,localThresholdSq,matrixWorld,raycaster,intersects,this);}}else {var _start7=Math.max(0,drawRange.start);var _end6=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(var _i175=_start7,l=_end6;_i175<l;_i175++){_position$2.fromBufferAttribute(positionAttribute,_i175);testPoint(_position$2,_i175,localThresholdSq,matrixWorld,raycaster,intersects,this);}}}else {console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}updateMorphTargets(){var geometry=this.geometry;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphAttribute.length;m<ml;m++){var name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else {var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');}}}}Points.prototype.isPoints=true;function testPoint(point,index,localThresholdSq,matrixWorld,raycaster,intersects,object){var rayPointDistanceSq=_ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){var intersectPoint=new Vector3();_ray.closestPointToPoint(point,intersectPoint);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint,index:index,face:null,object:object});}}class VideoTexture extends Texture{constructor(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){super(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.format=format!==undefined?format:RGBFormat;this.minFilter=minFilter!==undefined?minFilter:LinearFilter;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.generateMipmaps=false;var scope=this;function updateVideo(){scope.needsUpdate=true;video.requestVideoFrameCallback(updateVideo);}if('requestVideoFrameCallback'in video){video.requestVideoFrameCallback(updateVideo);}}clone(){return new this.constructor(this.image).copy(this);}update(){var video=this.image;var hasVideoFrameCallback=('requestVideoFrameCallback'in video);if(hasVideoFrameCallback===false&&video.readyState>=video.HAVE_CURRENT_DATA){this.needsUpdate=true;}}}VideoTexture.prototype.isVideoTexture=true;class CompressedTexture extends Texture{constructor(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={width:width,height:height};this.mipmaps=mipmaps;// no flipping for cube textures
  // (also flipping doesn't work for compressed textures )
  this.flipY=false;// can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files
  this.generateMipmaps=false;}}CompressedTexture.prototype.isCompressedTexture=true;class CanvasTexture extends Texture{constructor(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){super(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=true;}}CanvasTexture.prototype.isCanvasTexture=true;class DepthTexture extends Texture{constructor(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;}}DepthTexture.prototype.isDepthTexture=true;class CircleGeometry extends BufferGeometry{constructor(){var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var segments=arguments.length>1&&arguments[1]!==undefined?arguments[1]:8;var thetaStart=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var thetaLength=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Math.PI*2;super();this.type='CircleGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};segments=Math.max(3,segments);// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var vertex=new Vector3();var uv=new Vector2();// center point
  vertices.push(0,0,0);normals.push(0,0,1);uvs.push(0.5,0.5);for(var s=0,_i176=3;s<=segments;s++,_i176+=3){var segment=thetaStart+s/segments*thetaLength;// vertex
  vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normals.push(0,0,1);// uvs
  uv.x=(vertices[_i176]/radius+1)/2;uv.y=(vertices[_i176+1]/radius+1)/2;uvs.push(uv.x,uv.y);}// indices
  for(var _i177=1;_i177<=segments;_i177++){indices.push(_i177,_i177+1,0);}// build geometry
  this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new CircleGeometry(data.radius,data.segments,data.thetaStart,data.thetaLength);}}class PolyhedronGeometry extends BufferGeometry{constructor(){var vertices=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var indices=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var radius=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var detail=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;super();this.type='PolyhedronGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};// default buffer data
  var vertexBuffer=[];var uvBuffer=[];// the subdivision creates the vertex buffer data
  subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
  applyRadius(radius);// finally, create the uv data
  generateUVs();// build non-indexed geometry
  this.setAttribute('position',new Float32BufferAttribute(vertexBuffer,3));this.setAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));this.setAttribute('uv',new Float32BufferAttribute(uvBuffer,2));if(detail===0){this.computeVertexNormals();// flat normals
  }else {this.normalizeNormals();// smooth normals
  }// helper functions
  function subdivide(detail){var a=new Vector3();var b=new Vector3();var c=new Vector3();// iterate over all faces and apply a subdivison with the given detail value
  for(var _i179=0;_i179<indices.length;_i179+=3){// get the vertices of the face
  getVertexByIndex(indices[_i179+0],a);getVertexByIndex(indices[_i179+1],b);getVertexByIndex(indices[_i179+2],c);// perform subdivision
  subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){var cols=detail+1;// we use this multidimensional array as a data structure for creating the subdivision
  var v=[];// construct all of the vertices for this subdivision
  for(var _i180=0;_i180<=cols;_i180++){v[_i180]=[];var aj=a.clone().lerp(c,_i180/cols);var bj=b.clone().lerp(c,_i180/cols);var rows=cols-_i180;for(var j=0;j<=rows;j++){if(j===0&&_i180===cols){v[_i180][j]=aj;}else {v[_i180][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
  for(var _i181=0;_i181<cols;_i181++){for(var _j5=0;_j5<2*(cols-_i181)-1;_j5++){var k=Math.floor(_j5/2);if(_j5%2===0){pushVertex(v[_i181][k+1]);pushVertex(v[_i181+1][k]);pushVertex(v[_i181][k]);}else {pushVertex(v[_i181][k+1]);pushVertex(v[_i181+1][k+1]);pushVertex(v[_i181+1][k]);}}}}function applyRadius(radius){var vertex=new Vector3();// iterate over the entire buffer and apply the radius to each vertex
  for(var _i182=0;_i182<vertexBuffer.length;_i182+=3){vertex.x=vertexBuffer[_i182+0];vertex.y=vertexBuffer[_i182+1];vertex.z=vertexBuffer[_i182+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[_i182+0]=vertex.x;vertexBuffer[_i182+1]=vertex.y;vertexBuffer[_i182+2]=vertex.z;}}function generateUVs(){var vertex=new Vector3();for(var _i183=0;_i183<vertexBuffer.length;_i183+=3){vertex.x=vertexBuffer[_i183+0];vertex.y=vertexBuffer[_i183+1];vertex.z=vertexBuffer[_i183+2];var u=azimuth(vertex)/2/Math.PI+0.5;var v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
  for(var _i184=0;_i184<uvBuffer.length;_i184+=6){// uv data of a single face
  var x0=uvBuffer[_i184+0];var x1=uvBuffer[_i184+2];var x2=uvBuffer[_i184+4];var max=Math.max(x0,x1,x2);var min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
  if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[_i184+0]+=1;if(x1<0.2)uvBuffer[_i184+2]+=1;if(x2<0.2)uvBuffer[_i184+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){var stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){var a=new Vector3();var b=new Vector3();var c=new Vector3();var centroid=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();for(var _i185=0,j=0;_i185<vertexBuffer.length;_i185+=9,j+=6){a.set(vertexBuffer[_i185+0],vertexBuffer[_i185+1],vertexBuffer[_i185+2]);b.set(vertexBuffer[_i185+3],vertexBuffer[_i185+4],vertexBuffer[_i185+5]);c.set(vertexBuffer[_i185+6],vertexBuffer[_i185+7],vertexBuffer[_i185+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);var azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
  function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
  function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}}static fromJSON(data){return new PolyhedronGeometry(data.vertices,data.indices,data.radius,data.details);}}/**
   * Extensible curve object.
   *
   * Some common of curve methods:
   * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
   * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/class Curve{constructor(){this.type='Curve';this.arcLengthDivisions=200;}// Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint(){console.warn('THREE.Curve: .getPoint() not implemented.');return null;}// Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u,optionalTarget){var t=this.getUtoTmapping(u);return this.getPoint(t,optionalTarget);}// Get sequence of points using getPoint( t )
  getPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;}// Get sequence of points using getPointAt( u )
  getSpacedPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;}// Get total curve arc length
  getLength(){var lengths=this.getLengths();return lengths[lengths.length-1];}// Get list of cumulative segment lengths
  getLengths(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var sum=0;cache.push(0);for(var p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
  }updateArcLengths(){this.needsUpdate=true;this.getLengths();}// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u,distance){var arcLengths=this.getLengths();var i=0;var il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
  if(distance){targetArcLength=distance;}else {targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
  var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
  comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else {high=i;break;// DONE
  }}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
  var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
  var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
  var t=(i+segmentFraction)/(il-1);return t;}// Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t,optionalTarget){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
  if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var tangent=optionalTarget||(pt1.isVector2?new Vector2():new Vector3());tangent.copy(pt2).sub(pt1).normalize();return tangent;}getTangentAt(u,optionalTarget){var t=this.getUtoTmapping(u);return this.getTangent(t,optionalTarget);}computeFrenetFrames(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
  var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4();// compute the tangent vectors for each segment on the curve
  for(var _i187=0;_i187<=segments;_i187++){var u=_i187/segments;tangents[_i187]=this.getTangentAt(u,new Vector3());}// select an initial normal vector perpendicular to the first tangent vector,
  // and in the direction of the minimum tangent xyz component
  normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
  for(var _i188=1;_i188<=segments;_i188++){normals[_i188]=normals[_i188-1].clone();binormals[_i188]=binormals[_i188-1].clone();vec.crossVectors(tangents[_i188-1],tangents[_i188]);if(vec.length()>Number.EPSILON){vec.normalize();var theta=Math.acos(clamp(tangents[_i188-1].dot(tangents[_i188]),-1,1));// clamp for floating pt errors
  normals[_i188].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[_i188].crossVectors(tangents[_i188],normals[_i188]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
  if(closed===true){var _theta=Math.acos(clamp(normals[0].dot(normals[segments]),-1,1));_theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){_theta=-_theta;}for(var _i189=1;_i189<=segments;_i189++){// twist a little...
  normals[_i189].applyMatrix4(mat.makeRotationAxis(tangents[_i189],_theta*_i189));binormals[_i189].crossVectors(tangents[_i189],normals[_i189]);}}return {tangents:tangents,normals:normals,binormals:binormals};}clone(){return new this.constructor().copy(this);}copy(source){this.arcLengthDivisions=source.arcLengthDivisions;return this;}toJSON(){var data={metadata:{version:4.5,type:'Curve',generator:'Curve.toJSON'}};data.arcLengthDivisions=this.arcLengthDivisions;data.type=this.type;return data;}fromJSON(json){this.arcLengthDivisions=json.arcLengthDivisions;return this;}}class EllipseCurve extends Curve{constructor(){var aX=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var aY=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var xRadius=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var yRadius=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var aStartAngle=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var aEndAngle=arguments.length>5&&arguments[5]!==undefined?arguments[5]:Math.PI*2;var aClockwise=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;var aRotation=arguments.length>7&&arguments[7]!==undefined?arguments[7]:0;super();this.type='EllipseCurve';this.aX=aX;this.aY=aY;this.xRadius=xRadius;this.yRadius=yRadius;this.aStartAngle=aStartAngle;this.aEndAngle=aEndAngle;this.aClockwise=aClockwise;this.aRotation=aRotation;}getPoint(t,optionalTarget){var point=optionalTarget||new Vector2();var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
  while(deltaAngle<0){deltaAngle+=twoPi;}while(deltaAngle>twoPi){deltaAngle-=twoPi;}if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else {deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else {deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
  x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return point.set(x,y);}copy(source){super.copy(source);this.aX=source.aX;this.aY=source.aY;this.xRadius=source.xRadius;this.yRadius=source.yRadius;this.aStartAngle=source.aStartAngle;this.aEndAngle=source.aEndAngle;this.aClockwise=source.aClockwise;this.aRotation=source.aRotation;return this;}toJSON(){var data=super.toJSON();data.aX=this.aX;data.aY=this.aY;data.xRadius=this.xRadius;data.yRadius=this.yRadius;data.aStartAngle=this.aStartAngle;data.aEndAngle=this.aEndAngle;data.aClockwise=this.aClockwise;data.aRotation=this.aRotation;return data;}fromJSON(json){super.fromJSON(json);this.aX=json.aX;this.aY=json.aY;this.xRadius=json.xRadius;this.yRadius=json.yRadius;this.aStartAngle=json.aStartAngle;this.aEndAngle=json.aEndAngle;this.aClockwise=json.aClockwise;this.aRotation=json.aRotation;return this;}}EllipseCurve.prototype.isEllipseCurve=true;class ArcCurve extends EllipseCurve{constructor(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){super(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);this.type='ArcCurve';}}ArcCurve.prototype.isArcCurve=true;/**
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */ /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
  	 * Compute coefficients for a cubic polynomial
  	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
  	 * such that
  	 *   p(0) = x0, p(1) = x1
  	 *  and
  	 *   p'(0) = t0, p'(1) = t1.
  	 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return {initCatmullRom:function(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
  var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
  t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
  var tmp=new Vector3();var px=new CubicPoly(),py=new CubicPoly(),pz=new CubicPoly();class CatmullRomCurve3 extends Curve{constructor(){var points=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var closed=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var curveType=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'centripetal';var tension=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0.5;super();this.type='CatmullRomCurve3';this.points=points;this.closed=closed;this.curveType=curveType;this.tension=tension;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;var points=this.points;var l=points.length;var p=(l-(this.closed?0:1))*t;var intPoint=Math.floor(p);var weight=p-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l)+1)*l;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p3;// 4 points (p1 & p2 defined below)
  if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else {// extrapolate first point
  tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}var p1=points[intPoint%l];var p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else {// extrapolate last point
  tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.curveType==='centripetal'||this.curveType==='chordal'){// init Centripetal / Chordal Catmull-Rom
  var pow=this.curveType==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
  if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.curveType==='catmullrom'){px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,this.tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,this.tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,this.tension);}point.set(px.calc(weight),py.calc(weight),pz.calc(weight));return point;}copy(source){super.copy(source);this.points=[];for(var _i190=0,l=source.points.length;_i190<l;_i190++){var point=source.points[_i190];this.points.push(point.clone());}this.closed=source.closed;this.curveType=source.curveType;this.tension=source.tension;return this;}toJSON(){var data=super.toJSON();data.points=[];for(var _i191=0,l=this.points.length;_i191<l;_i191++){var point=this.points[_i191];data.points.push(point.toArray());}data.closed=this.closed;data.curveType=this.curveType;data.tension=this.tension;return data;}fromJSON(json){super.fromJSON(json);this.points=[];for(var _i192=0,l=json.points.length;_i192<l;_i192++){var point=json.points[_i192];this.points.push(new Vector3().fromArray(point));}this.closed=json.closed;this.curveType=json.curveType;this.tension=json.tension;return this;}}CatmullRomCurve3.prototype.isCatmullRomCurve3=true;/**
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/Bzier_curve
   */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return (2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
  function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
  function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}class CubicBezierCurve extends Curve{constructor(){var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector2();var v3=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Vector2();super();this.type='CubicBezierCurve';this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;}toJSON(){var data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;}}CubicBezierCurve.prototype.isCubicBezierCurve=true;class CubicBezierCurve3 extends Curve{constructor(){var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector3();var v3=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Vector3();super();this.type='CubicBezierCurve3';this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;}toJSON(){var data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;}}CubicBezierCurve3.prototype.isCubicBezierCurve3=true;class LineCurve extends Curve{constructor(){var v1=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();var v2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();super();this.type='LineCurve';this.v1=v1;this.v2=v2;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;if(t===1){point.copy(this.v2);}else {point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;}// Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget);}getTangent(t,optionalTarget){var tangent=optionalTarget||new Vector2();tangent.copy(this.v2).sub(this.v1).normalize();return tangent;}copy(source){super.copy(source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){var data=super.toJSON();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}LineCurve.prototype.isLineCurve=true;class LineCurve3 extends Curve{constructor(){var v1=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var v2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();super();this.type='LineCurve3';this.isLineCurve3=true;this.v1=v1;this.v2=v2;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;if(t===1){point.copy(this.v2);}else {point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;}// Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget);}copy(source){super.copy(source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){var data=super.toJSON();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}class QuadraticBezierCurve extends Curve{constructor(){var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector2();super();this.type='QuadraticBezierCurve';this.v0=v0;this.v1=v1;this.v2=v2;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){var data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;class QuadraticBezierCurve3 extends Curve{constructor(){var v0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var v1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var v2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector3();super();this.type='QuadraticBezierCurve3';this.v0=v0;this.v1=v1;this.v2=v2;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var point=optionalTarget;var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));return point;}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;}toJSON(){var data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;}}QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;class SplineCurve extends Curve{constructor(){var points=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];super();this.type='SplineCurve';this.points=points;}getPoint(t){var optionalTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2();var point=optionalTarget;var points=this.points;var p=(points.length-1)*t;var intPoint=Math.floor(p);var weight=p-intPoint;var p0=points[intPoint===0?intPoint:intPoint-1];var p1=points[intPoint];var p2=points[intPoint>points.length-2?points.length-1:intPoint+1];var p3=points[intPoint>points.length-3?points.length-1:intPoint+2];point.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));return point;}copy(source){super.copy(source);this.points=[];for(var _i193=0,l=source.points.length;_i193<l;_i193++){var point=source.points[_i193];this.points.push(point.clone());}return this;}toJSON(){var data=super.toJSON();data.points=[];for(var _i194=0,l=this.points.length;_i194<l;_i194++){var point=this.points[_i194];data.points.push(point.toArray());}return data;}fromJSON(json){super.fromJSON(json);this.points=[];for(var _i195=0,l=json.points.length;_i195<l;_i195++){var point=json.points[_i195];this.points.push(new Vector2().fromArray(point));}return this;}}SplineCurve.prototype.isSplineCurve=true;var Curves=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});/**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/class CurvePath extends Curve{constructor(){super();this.type='CurvePath';this.curves=[];this.autoClose=false;// Automatically closes the path
  }add(curve){this.curves.push(curve);}closePath(){// Add a line curve if start and end of lines are not connected
  var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}}// To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t,optionalTarget){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
  while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u,optionalTarget);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
  }// We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength(){var lens=this.getCurveLengths();return lens[lens.length-1];}// cacheLengths must be recalculated.
  updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();}// Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths(){// We use cache values if curves and cache array are same length
  if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
  // Push sums into cached array
  var lengths=[];var sums=0;for(var _i196=0,l=this.curves.length;_i196<l;_i196++){sums+=this.curves[_i196].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;}getSpacedPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:40;var points=[];for(var _i197=0;_i197<=divisions;_i197++){points.push(this.getPoint(_i197/divisions));}if(this.autoClose){points.push(points[0]);}return points;}getPoints(){var divisions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:12;var points=[];var last;for(var _i198=0,curves=this.curves;_i198<curves.length;_i198++){var curve=curves[_i198];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&(curve.isLineCurve||curve.isLineCurve3)?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
  points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;}copy(source){super.copy(source);this.curves=[];for(var _i199=0,l=source.curves.length;_i199<l;_i199++){var curve=source.curves[_i199];this.curves.push(curve.clone());}this.autoClose=source.autoClose;return this;}toJSON(){var data=super.toJSON();data.autoClose=this.autoClose;data.curves=[];for(var _i200=0,l=this.curves.length;_i200<l;_i200++){var curve=this.curves[_i200];data.curves.push(curve.toJSON());}return data;}fromJSON(json){super.fromJSON(json);this.autoClose=json.autoClose;this.curves=[];for(var _i201=0,l=json.curves.length;_i201<l;_i201++){var curve=json.curves[_i201];this.curves.push(new Curves[curve.type]().fromJSON(curve));}return this;}}class Path extends CurvePath{constructor(points){super();this.type='Path';this.currentPoint=new Vector2();if(points){this.setFromPoints(points);}}setFromPoints(points){this.moveTo(points[0].x,points[0].y);for(var _i202=1,l=points.length;_i202<l;_i202++){this.lineTo(points[_i202].x,points[_i202].y);}return this;}moveTo(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
  return this;}lineTo(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);return this;}quadraticCurveTo(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;}bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;}splineThru(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);return this;}arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);return this;}absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);return this;}ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);return this;}absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
  var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);return this;}copy(source){super.copy(source);this.currentPoint.copy(source.currentPoint);return this;}toJSON(){var data=super.toJSON();data.currentPoint=this.currentPoint.toArray();return data;}fromJSON(json){super.fromJSON(json);this.currentPoint.fromArray(json.currentPoint);return this;}}class Shape extends Path{constructor(points){super(points);this.uuid=generateUUID();this.type='Shape';this.holes=[];}getPointsHoles(divisions){var holesPts=[];for(var _i203=0,l=this.holes.length;_i203<l;_i203++){holesPts[_i203]=this.holes[_i203].getPoints(divisions);}return holesPts;}// get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions){return {shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};}copy(source){super.copy(source);this.holes=[];for(var _i204=0,l=source.holes.length;_i204<l;_i204++){var hole=source.holes[_i204];this.holes.push(hole.clone());}return this;}toJSON(){var data=super.toJSON();data.uuid=this.uuid;data.holes=[];for(var _i205=0,l=this.holes.length;_i205<l;_i205++){var hole=this.holes[_i205];data.holes.push(hole.toJSON());}return data;}fromJSON(json){super.fromJSON(json);this.uuid=json.uuid;this.holes=[];for(var _i206=0,l=json.holes.length;_i206<l;_i206++){var hole=json.holes[_i206];this.holes.push(new Path().fromJSON(hole));}return this;}}/**
   * Port from https://github.com/mapbox/earcut (v2.2.2)
   */var Earcut={triangulate:function(data,holeIndices){var dim=arguments.length>2&&arguments[2]!==undefined?arguments[2]:2;var hasHoles=holeIndices&&holeIndices.length;var outerLen=hasHoles?holeIndices[0]*dim:data.length;var outerNode=linkedList(data,0,outerLen,dim,true);var triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
  if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var _i207=dim;_i207<outerLen;_i207+=dim){x=data[_i207];y=data[_i207+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
  invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}};// create a circular doubly linked list from polygon points in the specified winding order
  function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}}else {for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
  function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else {p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
  if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);var stop=ear,prev,next;// iterate through ears, slicing them one by one
  while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){// cut off the triangle
  triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertex leads to less sliver triangles
  ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
  if(ear===stop){// try filtering points and slicing again
  if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
  }else if(pass===1){ear=cureLocalIntersections(filterPoints(ear),triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
  }else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
  function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear
  var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed
  var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
  var minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);var p=ear.prevZ,n=ear.nextZ;// look for points inside the triangle in both directions
  while(p&&p.z>=minZ&&n&&n.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}// look for remaining points in decreasing z-order
  while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}// look for remaining points in increasing z-order
  while(n&&n.z<=maxZ){if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}return true;}// go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
  removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return filterPoints(p);}// try splitting polygon into two and triangulate them independently
  function splitEarcut(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
  var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
  var c=splitPolygon(a,b);// filter colinear points around the cuts
  a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
  earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[];var i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
  for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);// filter collinear points around the cuts
  filterPoints(outerNode,outerNode.next);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge(hole,outerNode){var p=outerNode;var hx=hole.x;var hy=hole.y;var qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point
  do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m;// hole touches outer segment; pick leftmost endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point
  var stop=m,mx=m.x,my=m.y;var tanMin=Infinity,tan;p=m;do{if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
  if(locallyInside(p,hole)&&(tan<tanMin||tan===tanMin&&(p.x>m.x||p.x===m.x&&sectorContainsSector(m,p)))){m=p;tanMin=tan;}}p=p.next;}while(p!==stop);return m;}// whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector(m,p){return area(m.prev,m,p.prev)<0&&area(p.next,m,m.next)<0;}// interlink polygon nodes in z-order
  function indexCurve(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else {e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
  x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
  function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x||p.x===leftmost.x&&p.y<leftmost.y)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
  function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return (cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&(// dones't intersect other edges
  locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b)&&(// locally visible
  area(a.prev,a,b.prev)||area(a,b.prev,b))||// does not create opposite-facing sectors
  equals(a,b)&&area(a.prev,a,a.next)>0&&area(b.prev,b,b.next)>0);// special zero-length case
  }// signed area of a triangle
  function area(p,q,r){return (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
  function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
  function intersects(p1,q1,p2,q2){var o1=sign(area(p1,q1,p2));var o2=sign(area(p1,q1,q2));var o3=sign(area(p2,q2,p1));var o4=sign(area(p2,q2,q1));if(o1!==o2&&o3!==o4)return true;// general case
  if(o1===0&&onSegment(p1,p2,q1))return true;// p1, q1 and p2 are collinear and p2 lies on p1q1
  if(o2===0&&onSegment(p1,q2,q1))return true;// p1, q1 and q2 are collinear and q2 lies on p1q1
  if(o3===0&&onSegment(p2,p1,q2))return true;// p2, q2 and p1 are collinear and p1 lies on p2q2
  if(o4===0&&onSegment(p2,q1,q2))return true;// p2, q2 and q1 are collinear and q1 lies on p2q2
  return false;}// for collinear points p, q, r, check if point q lies on segment pr
  function onSegment(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y);}function sign(num){return num>0?1:num<0?-1:0;}// check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
  function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
  function middleInside(a,b){var p=a,inside=false;var px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon(a,b){var a2=new Node$1(a.i,a.x,a.y),b2=new Node$1(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode(i,x,y,last){var p=new Node$1(i,x,y);if(!last){p.prev=p;p.next=p;}else {p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node$1(i,x,y){// vertex index in coordinates array
  this.i=i;// vertex coordinates
  this.x=x;this.y=y;// previous and next vertex nodes in a polygon ring
  this.prev=null;this.next=null;// z-order curve value
  this.z=null;// previous and next nodes in z-order
  this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
  this.steiner=false;}function signedArea(data,start,end,dim){var sum=0;for(var _i208=start,j=end-dim;_i208<end;_i208+=dim){sum+=(data[j]-data[_i208])*(data[_i208+1]+data[j+1]);j=_i208;}return sum;}class ShapeUtils{// calculate area of the contour polygon
  static area(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;}static isClockWise(pts){return ShapeUtils.area(pts)<0;}static triangulateShape(contour,holes){var vertices=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
  var holeIndices=[];// array of hole indices
  var faces=[];// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
  removeDupEndPts(contour);addContour(vertices,contour);//
  var holeIndex=contour.length;holes.forEach(removeDupEndPts);for(var _i209=0;_i209<holes.length;_i209++){holeIndices.push(holeIndex);holeIndex+=holes[_i209].length;addContour(vertices,holes[_i209]);}//
  var triangles=Earcut.triangulate(vertices,holeIndices);//
  for(var _i210=0;_i210<triangles.length;_i210+=3){faces.push(triangles.slice(_i210,_i210+3));}return faces;}}function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}function addContour(vertices,contour){for(var _i211=0;_i211<contour.length;_i211++){vertices.push(contour[_i211].x);vertices.push(contour[_i211].y);}}/**
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  depth: <float>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
   *  bevelOffset: <float>, // how far from shape outline does bevel start
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */class ExtrudeGeometry extends BufferGeometry{constructor(){var shapes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Shape([new Vector2(0.5,0.5),new Vector2(-0.5,0.5),new Vector2(-0.5,-0.5),new Vector2(0.5,-0.5)]);var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};super();this.type='ExtrudeGeometry';this.parameters={shapes:shapes,options:options};shapes=Array.isArray(shapes)?shapes:[shapes];var scope=this;var verticesArray=[];var uvArray=[];for(var _i212=0,l=shapes.length;_i212<l;_i212++){var shape=shapes[_i212];addShape(shape);}// build geometry
  this.setAttribute('position',new Float32BufferAttribute(verticesArray,3));this.setAttribute('uv',new Float32BufferAttribute(uvArray,2));this.computeVertexNormals();// functions
  function addShape(shape){var placeholder=[];// options
  var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var depth=options.depth!==undefined?options.depth:1;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:0.2;var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-0.1;var bevelOffset=options.bevelOffset!==undefined?options.bevelOffset:0;var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var extrudePath=options.extrudePath;var uvgen=options.UVGenerator!==undefined?options.UVGenerator:WorldUVGenerator;// deprecated options
  if(options.amount!==undefined){console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');depth=options.amount;}//
  var extrudePts,extrudeByPath=false;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
  // SETUP TNB variables
  // TODO1 - have a .isClosed in spline?
  splineTube=extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
  binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
  if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;bevelOffset=0;}// Variables initialization
  var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
  for(var h=0,hl=holes.length;h<hl;h++){var ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
  for(var _h=0,_hl=holes.length;_h<_hl;_h++){var _ahole=holes[_h];vertices=vertices.concat(_ahole);}function scalePt2(pt,vec,size){if(!vec)console.error('THREE.ExtrudeGeometry: vec does not exist');return vec.clone().multiplyScalar(size).add(pt);}var vlen=vertices.length,flen=faces.length;// Find directions for point movement
  function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
  //   shifted by 1 unit (length of normalized vector) to the left
  // if we walk along contour clockwise, this new contour is outside the old one
  //
  // inPt' is the intersection of the two lines parallel to the two
  //  adjacent edges of inPt at a distance of 1 unit on the left side.
  var v_trans_x,v_trans_y,shrink_by;// resulting translation vector for inPt
  // good reading for geometry algorithms (here: line-line intersection)
  // http://geomalgorithms.com/a05-_intersect-1.html
  var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
  var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){// not collinear
  // length of vectors for normalizing
  var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
  var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
  var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
  v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
  //  but prevent crazy spikes
  var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else {shrink_by=Math.sqrt(v_trans_lensq/2);}}else {// handle special case of collinear edges
  var direction_eq=false;// assumes: opposite
  if(v_prev_x>Number.EPSILON){if(v_next_x>Number.EPSILON){direction_eq=true;}}else {if(v_prev_x<-Number.EPSILON){if(v_next_x<-Number.EPSILON){direction_eq=true;}}else {if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
  v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else {// console.log("Warning: lines are a straight spike");
  v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var _i213=0,il=contour.length,j=il-1,k=_i213+1;_i213<il;_i213++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
  // console.log('i,j,k', i, j , k)
  contourMovements[_i213]=getBevelVec(contour[_i213],contour[j],contour[k]);}var holesMovements=[];var oneHoleMovements,verticesMovements=contourMovements.concat();for(var _h2=0,_hl2=holes.length;_h2<_hl2;_h2++){var _ahole2=holes[_h2];oneHoleMovements=[];for(var _i214=0,_il13=_ahole2.length,_j6=_il13-1,_k=_i214+1;_i214<_il13;_i214++,_j6++,_k++){if(_j6===_il13)_j6=0;if(_k===_il13)_k=0;//  (j)---(i)---(k)
  oneHoleMovements[_i214]=getBevelVec(_ahole2[_i214],_ahole2[_j6],_ahole2[_k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
  for(var b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
  var t=b/bevelSegments;var z=bevelThickness*Math.cos(t*Math.PI/2);var _bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;// contract shape
  for(var _i215=0,_il14=contour.length;_i215<_il14;_i215++){var vert=scalePt2(contour[_i215],contourMovements[_i215],_bs);v(vert.x,vert.y,-z);}// expand holes
  for(var _h3=0,_hl3=holes.length;_h3<_hl3;_h3++){var _ahole3=holes[_h3];oneHoleMovements=holesMovements[_h3];for(var _i216=0,_il15=_ahole3.length;_i216<_il15;_i216++){var _vert=scalePt2(_ahole3[_i216],oneHoleMovements[_i216],_bs);v(_vert.x,_vert.y,-z);}}}var bs=bevelSize+bevelOffset;// Back facing vertices
  for(var _i217=0;_i217<vlen;_i217++){var _vert2=bevelEnabled?scalePt2(vertices[_i217],verticesMovements[_i217],bs):vertices[_i217];if(!extrudeByPath){v(_vert2.x,_vert2.y,0);}else {// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
  normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
  // Including front facing vertices
  for(var s=1;s<=steps;s++){for(var _i218=0;_i218<vlen;_i218++){var _vert3=bevelEnabled?scalePt2(vertices[_i218],verticesMovements[_i218],bs):vertices[_i218];if(!extrudeByPath){v(_vert3.x,_vert3.y,depth/steps*s);}else {// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
  normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for(var _b5=bevelSegments-1;_b5>=0;_b5--){var _t=_b5/bevelSegments;var _z2=bevelThickness*Math.cos(_t*Math.PI/2);var _bs2=bevelSize*Math.sin(_t*Math.PI/2)+bevelOffset;// contract shape
  for(var _i219=0,_il16=contour.length;_i219<_il16;_i219++){var _vert4=scalePt2(contour[_i219],contourMovements[_i219],_bs2);v(_vert4.x,_vert4.y,depth+_z2);}// expand holes
  for(var _h4=0,_hl4=holes.length;_h4<_hl4;_h4++){var _ahole4=holes[_h4];oneHoleMovements=holesMovements[_h4];for(var _i220=0,_il17=_ahole4.length;_i220<_il17;_i220++){var _vert5=scalePt2(_ahole4[_i220],oneHoleMovements[_i220],_bs2);if(!extrudeByPath){v(_vert5.x,_vert5.y,depth+_z2);}else {v(_vert5.x,_vert5.y+extrudePts[steps-1].y,extrudePts[steps-1].x+_z2);}}}}/* Faces */ // Top and bottom faces
  buildLidFaces();// Sides faces
  buildSideFaces();/////  Internal functions
  function buildLidFaces(){var start=verticesArray.length/3;if(bevelEnabled){var layer=0;// steps + 1
  var offset=vlen*layer;// Bottom faces
  for(var _i221=0;_i221<flen;_i221++){var face=faces[_i221];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
  for(var _i222=0;_i222<flen;_i222++){var _face=faces[_i222];f3(_face[0]+offset,_face[1]+offset,_face[2]+offset);}}else {// Bottom faces
  for(var _i223=0;_i223<flen;_i223++){var _face2=faces[_i223];f3(_face2[2],_face2[1],_face2[0]);}// Top faces
  for(var _i224=0;_i224<flen;_i224++){var _face3=faces[_i224];f3(_face3[0]+vlen*steps,_face3[1]+vlen*steps,_face3[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,0);}// Create faces for the z-sides of the shape
  function buildSideFaces(){var start=verticesArray.length/3;var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(var _h5=0,_hl5=holes.length;_h5<_hl5;_h5++){var _ahole5=holes[_h5];sidewalls(_ahole5,layeroffset);//, true
  layeroffset+=_ahole5.length;}scope.addGroup(start,verticesArray.length/3-start,1);}function sidewalls(contour,layeroffset){var i=contour.length;while(--i>=0){var _j7=i;var _k2=i-1;if(_k2<0)_k2=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
  for(var _s4=0,sl=steps+bevelSegments*2;_s4<sl;_s4++){var slen1=vlen*_s4;var slen2=vlen*(_s4+1);var a=layeroffset+_j7+slen1,_b6=layeroffset+_k2+slen1,c=layeroffset+_k2+slen2,d=layeroffset+_j7+slen2;f4(a,_b6,c,d);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}}}toJSON(){var data=super.toJSON();var shapes=this.parameters.shapes;var options=this.parameters.options;return toJSON$1(shapes,options,data);}static fromJSON(data,shapes){var geometryShapes=[];for(var j=0,jl=data.shapes.length;j<jl;j++){var shape=shapes[data.shapes[j]];geometryShapes.push(shape);}var extrudePath=data.options.extrudePath;if(extrudePath!==undefined){data.options.extrudePath=new Curves[extrudePath.type]().fromJSON(extrudePath);}return new ExtrudeGeometry(geometryShapes,data.options);}}var WorldUVGenerator={generateTopUV:function(geometry,vertices,indexA,indexB,indexC){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];return [new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function(geometry,vertices,indexA,indexB,indexC,indexD){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var a_z=vertices[indexA*3+2];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var b_z=vertices[indexB*3+2];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];var c_z=vertices[indexC*3+2];var d_x=vertices[indexD*3];var d_y=vertices[indexD*3+1];var d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<Math.abs(a_x-b_x)){return [new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else {return [new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};function toJSON$1(shapes,options,data){data.shapes=[];if(Array.isArray(shapes)){for(var _i225=0,l=shapes.length;_i225<l;_i225++){var shape=shapes[_i225];data.shapes.push(shape.uuid);}}else {data.shapes.push(shapes.uuid);}if(options.extrudePath!==undefined)data.options.extrudePath=options.extrudePath.toJSON();return data;}class IcosahedronGeometry extends PolyhedronGeometry{constructor(){var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var detail=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var t=(1+Math.sqrt(5))/2;var vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];var indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(vertices,indices,radius,detail);this.type='IcosahedronGeometry';this.parameters={radius:radius,detail:detail};}static fromJSON(data){return new IcosahedronGeometry(data.radius,data.detail);}}class RingGeometry extends BufferGeometry{constructor(){var innerRadius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0.5;var outerRadius=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var thetaSegments=arguments.length>2&&arguments[2]!==undefined?arguments[2]:8;var phiSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var thetaStart=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var thetaLength=arguments.length>5&&arguments[5]!==undefined?arguments[5]:Math.PI*2;super();this.type='RingGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};thetaSegments=Math.max(3,thetaSegments);phiSegments=Math.max(1,phiSegments);// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// some helper variables
  var radius=innerRadius;var radiusStep=(outerRadius-innerRadius)/phiSegments;var vertex=new Vector3();var uv=new Vector2();// generate vertices, normals and uvs
  for(var j=0;j<=phiSegments;j++){for(var _i229=0;_i229<=thetaSegments;_i229++){// values are generate from the inside of the ring to the outside
  var segment=thetaStart+_i229/thetaSegments*thetaLength;// vertex
  vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normals.push(0,0,1);// uv
  uv.x=(vertex.x/outerRadius+1)/2;uv.y=(vertex.y/outerRadius+1)/2;uvs.push(uv.x,uv.y);}// increase the radius for next row of vertices
  radius+=radiusStep;}// indices
  for(var _j10=0;_j10<phiSegments;_j10++){var thetaSegmentLevel=_j10*(thetaSegments+1);for(var _i230=0;_i230<thetaSegments;_i230++){var _segment=_i230+thetaSegmentLevel;var a=_segment;var b=_segment+thetaSegments+1;var c=_segment+thetaSegments+2;var d=_segment+1;// faces
  indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}static fromJSON(data){return new RingGeometry(data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);}}class ShapeGeometry extends BufferGeometry{constructor(){var shapes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Shape([new Vector2(0,0.5),new Vector2(-0.5,-0.5),new Vector2(0.5,-0.5)]);var curveSegments=arguments.length>1&&arguments[1]!==undefined?arguments[1]:12;super();this.type='ShapeGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
  if(Array.isArray(shapes)===false){addShape(shapes);}else {for(var _i231=0;_i231<shapes.length;_i231++){addShape(shapes[_i231]);this.addGroup(groupStart,groupCount,_i231);// enables MultiMaterial support
  groupStart+=groupCount;groupCount=0;}}// build geometry
  this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
  function addShape(shape){var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
  if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();}for(var _i232=0,l=shapeHoles.length;_i232<l;_i232++){var shapeHole=shapeHoles[_i232];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[_i232]=shapeHole.reverse();}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
  for(var _i233=0,_l7=shapeHoles.length;_i233<_l7;_i233++){var _shapeHole=shapeHoles[_i233];shapeVertices=shapeVertices.concat(_shapeHole);}// vertices, normals, uvs
  for(var _i234=0,_l8=shapeVertices.length;_i234<_l8;_i234++){var _vertex=shapeVertices[_i234];vertices.push(_vertex.x,_vertex.y,0);normals.push(0,0,1);uvs.push(_vertex.x,_vertex.y);// world uvs
  }// incides
  for(var _i235=0,_l9=faces.length;_i235<_l9;_i235++){var face=faces[_i235];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}toJSON(){var data=super.toJSON();var shapes=this.parameters.shapes;return toJSON(shapes,data);}static fromJSON(data,shapes){var geometryShapes=[];for(var j=0,jl=data.shapes.length;j<jl;j++){var shape=shapes[data.shapes[j]];geometryShapes.push(shape);}return new ShapeGeometry(geometryShapes,data.curveSegments);}}function toJSON(shapes,data){data.shapes=[];if(Array.isArray(shapes)){for(var _i236=0,l=shapes.length;_i236<l;_i236++){var shape=shapes[_i236];data.shapes.push(shape.uuid);}}else {data.shapes.push(shapes.uuid);}return data;}/**
   * parameters = {
   *  color: <THREE.Color>
   * }
   */class ShadowMaterial extends Material{constructor(parameters){super();this.type='ShadowMaterial';this.color=new Color(0x000000);this.transparent=true;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);return this;}}ShadowMaterial.prototype.isShadowMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  flatShading: <bool>
   * }
   */class MeshStandardMaterial extends Material{constructor(parameters){super();this.defines={'STANDARD':''};this.type='MeshStandardMaterial';this.color=new Color(0xffffff);// diffuse
  this.roughness=1.0;this.metalness=0.0;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.roughnessMap=null;this.metalnessMap=null;this.alphaMap=null;this.envMap=null;this.envMapIntensity=1.0;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.defines={'STANDARD':''};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;return this;}}MeshStandardMaterial.prototype.isMeshStandardMaterial=true;/**
   * parameters = {
   *  clearcoat: <float>,
   *  clearcoatMap: new THREE.Texture( <Image> ),
   *  clearcoatRoughness: <float>,
   *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
   *  clearcoatNormalScale: <Vector2>,
   *  clearcoatNormalMap: new THREE.Texture( <Image> ),
   *
   *  ior: <float>,
   *  reflectivity: <float>,
   *
   *  sheen: <float>,
   *  sheenColor: <Color>,
   *  sheenColorMap: new THREE.Texture( <Image> ),
   *  sheenRoughness: <float>,
   *  sheenRoughnessMap: new THREE.Texture( <Image> ),
   *
   *  transmission: <float>,
   *  transmissionMap: new THREE.Texture( <Image> ),
   *
   *  thickness: <float>,
   *  thicknessMap: new THREE.Texture( <Image> ),
   *  attenuationDistance: <float>,
   *  attenuationColor: <Color>,
   *
   *  specularIntensity: <float>,
   *  specularIntensityMap: new THREE.Texture( <Image> ),
   *  specularColor: <Color>,
   *  specularColorMap: new THREE.Texture( <Image> )
   * }
   */class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(parameters){super();this.defines={'STANDARD':'','PHYSICAL':''};this.type='MeshPhysicalMaterial';this.clearcoatMap=null;this.clearcoatRoughness=0.0;this.clearcoatRoughnessMap=null;this.clearcoatNormalScale=new Vector2(1,1);this.clearcoatNormalMap=null;this.ior=1.5;Object.defineProperty(this,'reflectivity',{get:function(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1);},set:function(reflectivity){this.ior=(1+0.4*reflectivity)/(1-0.4*reflectivity);}});this.sheenColor=new Color(0x000000);this.sheenColorMap=null;this.sheenRoughness=1.0;this.sheenRoughnessMap=null;this.transmissionMap=null;this.thickness=0.01;this.thicknessMap=null;this.attenuationDistance=0.0;this.attenuationColor=new Color(1,1,1);this.specularIntensity=1.0;this.specularIntensityMap=null;this.specularColor=new Color(1,1,1);this.specularColorMap=null;this._sheen=0.0;this._clearcoat=0;this._transmission=0;this.setValues(parameters);}get sheen(){return this._sheen;}set sheen(value){if(this._sheen>0!==value>0){this.version++;}this._sheen=value;}get clearcoat(){return this._clearcoat;}set clearcoat(value){if(this._clearcoat>0!==value>0){this.version++;}this._clearcoat=value;}get transmission(){return this._transmission;}set transmission(value){if(this._transmission>0!==value>0){this.version++;}this._transmission=value;}copy(source){super.copy(source);this.defines={'STANDARD':'','PHYSICAL':''};this.clearcoat=source.clearcoat;this.clearcoatMap=source.clearcoatMap;this.clearcoatRoughness=source.clearcoatRoughness;this.clearcoatRoughnessMap=source.clearcoatRoughnessMap;this.clearcoatNormalMap=source.clearcoatNormalMap;this.clearcoatNormalScale.copy(source.clearcoatNormalScale);this.ior=source.ior;this.sheen=source.sheen;this.sheenColor.copy(source.sheenColor);this.sheenColorMap=source.sheenColorMap;this.sheenRoughness=source.sheenRoughness;this.sheenRoughnessMap=source.sheenRoughnessMap;this.transmission=source.transmission;this.transmissionMap=source.transmissionMap;this.thickness=source.thickness;this.thicknessMap=source.thicknessMap;this.attenuationDistance=source.attenuationDistance;this.attenuationColor.copy(source.attenuationColor);this.specularIntensity=source.specularIntensity;this.specularIntensityMap=source.specularIntensityMap;this.specularColor.copy(source.specularColor);this.specularColorMap=source.specularColorMap;return this;}}MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.MultiplyOperation,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  flatShading: <bool>
   * }
   */class MeshPhongMaterial extends Material{constructor(parameters){super();this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
  this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;return this;}}MeshPhongMaterial.prototype.isMeshPhongMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *
   *  map: new THREE.Texture( <Image> ),
   *  gradientMap: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   * }
   */class MeshToonMaterial extends Material{constructor(parameters){super();this.defines={'TOON':''};this.type='MeshToonMaterial';this.color=new Color(0xffffff);this.map=null;this.gradientMap=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.gradientMap=source.gradientMap;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}MeshToonMaterial.prototype.isMeshToonMaterial=true;/**
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  flatShading: <bool>
   * }
   */class MeshNormalMaterial extends Material{constructor(parameters){super();this.type='MeshNormalMaterial';this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.flatShading=source.flatShading;return this;}}MeshNormalMaterial.prototype.isMeshNormalMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   * }
   */class MeshLambertMaterial extends Material{constructor(parameters){super();this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
  this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.setValues(parameters);}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;return this;}}MeshLambertMaterial.prototype.isMeshLambertMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  matcap: new THREE.Texture( <Image> ),
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalMapType: THREE.TangentSpaceNormalMap,
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  flatShading: <bool>
   * }
   */class MeshMatcapMaterial extends Material{constructor(parameters){super();this.defines={'MATCAP':''};this.type='MeshMatcapMaterial';this.color=new Color(0xffffff);// diffuse
  this.matcap=null;this.map=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.flatShading=false;this.setValues(parameters);}copy(source){super.copy(source);this.defines={'MATCAP':''};this.color.copy(source.color);this.matcap=source.matcap;this.map=source.map;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.flatShading=source.flatShading;return this;}}MeshMatcapMaterial.prototype.isMeshMatcapMaterial=true;/**
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */class LineDashedMaterial extends LineBasicMaterial{constructor(parameters){super();this.type='LineDashedMaterial';this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(parameters);}copy(source){super.copy(source);this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;}}LineDashedMaterial.prototype.isLineDashedMaterial=true;var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
  arraySlice:function(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
  // but array.subarray(from) or array.subarray(from, len) is correct
  return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
  convertArray:function(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
  !forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
  }return Array.prototype.slice.call(array);// create Array
  },isTypedArray:function(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
  getKeyframeOrder:function(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var _i246=0;_i246!==n;++_i246){result[_i246]=_i246;}result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray:function(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var _i247=0,dstOffset=0;dstOffset!==nValues;++_i247){var srcOffset=order[_i247]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
  flattenJSON:function(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
  var value=key[valuePropertyName];if(value===undefined)return;// no data
  if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
  }key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
  do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else {// otherwise push as-is
  do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}},subclip:function(sourceClip,name,startFrame,endFrame){var fps=arguments.length>4&&arguments[4]!==undefined?arguments[4]:30;var clip=sourceClip.clone();clip.name=name;var tracks=[];for(var _i248=0;_i248<clip.tracks.length;++_i248){var track=clip.tracks[_i248];var valueSize=track.getValueSize();var times=[];var values=[];for(var j=0;j<track.times.length;++j){var frame=track.times[j]*fps;if(frame<startFrame||frame>=endFrame)continue;times.push(track.times[j]);for(var k=0;k<valueSize;++k){values.push(track.values[j*valueSize+k]);}}if(times.length===0)continue;track.times=AnimationUtils.convertArray(times,track.times.constructor);track.values=AnimationUtils.convertArray(values,track.values.constructor);tracks.push(track);}clip.tracks=tracks;// find minimum .times value across all tracks in the trimmed clip
  var minStartTime=Infinity;for(var _i249=0;_i249<clip.tracks.length;++_i249){if(minStartTime>clip.tracks[_i249].times[0]){minStartTime=clip.tracks[_i249].times[0];}}// shift all tracks such that clip begins at t=0
  for(var _i250=0;_i250<clip.tracks.length;++_i250){clip.tracks[_i250].shift(-1*minStartTime);}clip.resetDuration();return clip;},makeClipAdditive:function(targetClip){var referenceFrame=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var referenceClip=arguments.length>2&&arguments[2]!==undefined?arguments[2]:targetClip;var fps=arguments.length>3&&arguments[3]!==undefined?arguments[3]:30;if(fps<=0)fps=30;var numTracks=referenceClip.tracks.length;var referenceTime=referenceFrame/fps;// Make each track's values relative to the values at the reference frame
  var _loop=function(_i251){var referenceTrack=referenceClip.tracks[_i251];var referenceTrackType=referenceTrack.ValueTypeName;// Skip this track if it's non-numeric
  if(referenceTrackType==='bool'||referenceTrackType==='string')return "continue";// Find the track in the target clip whose name and type matches the reference track
  var targetTrack=targetClip.tracks.find(function(track){return track.name===referenceTrack.name&&track.ValueTypeName===referenceTrackType;});if(targetTrack===undefined)return "continue";var referenceOffset=0;var referenceValueSize=referenceTrack.getValueSize();if(referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline){referenceOffset=referenceValueSize/3;}var targetOffset=0;var targetValueSize=targetTrack.getValueSize();if(targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline){targetOffset=targetValueSize/3;}var lastIndex=referenceTrack.times.length-1;var referenceValue=void 0;// Find the value to subtract out of the track
  if(referenceTime<=referenceTrack.times[0]){// Reference frame is earlier than the first keyframe, so just use the first keyframe
  var startIndex=referenceOffset;var endIndex=referenceValueSize-referenceOffset;referenceValue=AnimationUtils.arraySlice(referenceTrack.values,startIndex,endIndex);}else if(referenceTime>=referenceTrack.times[lastIndex]){// Reference frame is after the last keyframe, so just use the last keyframe
  var _startIndex=lastIndex*referenceValueSize+referenceOffset;var _endIndex=_startIndex+referenceValueSize-referenceOffset;referenceValue=AnimationUtils.arraySlice(referenceTrack.values,_startIndex,_endIndex);}else {// Interpolate to the reference value
  var interpolant=referenceTrack.createInterpolant();var _startIndex2=referenceOffset;var _endIndex2=referenceValueSize-referenceOffset;interpolant.evaluate(referenceTime);referenceValue=AnimationUtils.arraySlice(interpolant.resultBuffer,_startIndex2,_endIndex2);}// Conjugate the quaternion
  if(referenceTrackType==='quaternion'){var referenceQuat=new Quaternion().fromArray(referenceValue).normalize().conjugate();referenceQuat.toArray(referenceValue);}// Subtract the reference value from all of the track values
  var numTimes=targetTrack.times.length;for(var j=0;j<numTimes;++j){var valueStart=j*targetValueSize+targetOffset;if(referenceTrackType==='quaternion'){// Multiply the conjugate for quaternion track types
  Quaternion.multiplyQuaternionsFlat(targetTrack.values,valueStart,referenceValue,0,targetTrack.values,valueStart);}else {var valueEnd=targetValueSize-targetOffset*2;// Subtract each value for all other numeric track types
  for(var k=0;k<valueEnd;++k){targetTrack.values[valueStart+k]-=referenceValue[k];}}}};for(var _i251=0;_i251<numTracks;++_i251){var _ret=_loop(_i251);if(_ret==="continue")continue;}targetClip.blendMode=AdditiveAnimationBlendMode;return targetClip;}};/**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   */class Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;this.settings=null;this.DefaultSettings_={};}evaluate(t){var pp=this.parameterPositions;var i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
  //- slower code:
  //-
  //- 				if ( t >= t1 || t1 === undefined ) {
  forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
  i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
  t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the right side of the index
  right=pp.length;break linear_scan;}//- slower code:
  //-					if ( t < t0 || t0 === undefined ) {
  if(!(t>=t0)){// looping?
  var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
  t0=t1global;}// linear reverse scan
  for(var _giveUpAt=i1-2;;){if(t0===undefined){// before start
  this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===_giveUpAt)break;// this loop
  t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the left side of the index
  right=i1;i1=0;break linear_scan;}// the interval is valid
  break validate_interval;}// linear scan
  // binary search
  while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else {i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
  if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
  this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
  return this.interpolate_(i1,t0,t,t1);}getSettings_(){return this.settings||this.DefaultSettings_;}copySampleValue_(index){// copies a sample value to the result buffer
  var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var _i252=0;_i252!==stride;++_i252){result[_i252]=values[offset+_i252];}return result;}// Template methods for derived classes:
  interpolate_(){throw new Error('call to abstract method');// implementations shall return this.resultBuffer
  }intervalChanged_(){// empty
  }}// ALIAS DEFINITIONS
  Interpolant.prototype.beforeStart_=Interpolant.prototype.copySampleValue_;Interpolant.prototype.afterEnd_=Interpolant.prototype.copySampleValue_;/**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   */class CubicInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};}intervalChanged_(i1,t0,t1){var pp=this.parameterPositions;var iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
  iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
  iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
  // f''(t0) = 0 a.k.a. Natural Spline
  iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
  iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
  iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
  // f''(tN) = 0, a.k.a. Natural Spline
  iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;}interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
  var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
  for(var _i253=0;_i253!==stride;++_i253){result[_i253]=sP*values[oP+_i253]+s0*values[o0+_i253]+s1*values[o1+_i253]+sN*values[oN+_i253];}return result;}}class LinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);}interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var _i254=0;_i254!==stride;++_i254){result[_i254]=values[offset0+_i254]*weight0+values[offset1+_i254]*weight1;}return result;}}/**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   */class DiscreteInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);}interpolate_(i1/*, t0, t, t1 */){return this.copySampleValue_(i1-1);}}class KeyframeTrack{constructor(name,times,values,interpolation){if(name===undefined)throw new Error('THREE.KeyframeTrack: track name is undefined');if(times===undefined||times.length===0)throw new Error('THREE.KeyframeTrack: no keyframes in track named '+name);this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);}// Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
  if(trackType.toJSON!==this.toJSON){json=trackType.toJSON(track);}else {// by default, we assume the data can be serialized as-is
  json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
  return json;}InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);}InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);}InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);}setInterpolation(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message='unsupported interpolation for '+this.ValueTypeName+' keyframe track named '+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
  if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else {throw new Error(message);// fatal, in this case
  }}console.warn('THREE.KeyframeTrack:',message);return this;}this.createInterpolant=factoryMethod;return this;}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}}getValueSize(){return this.values.length/this.times.length;}// move all keyframes either forwards or backwards in time
  shift(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var _i255=0,n=times.length;_i255!==n;++_i255){times[_i255]+=timeOffset;}}return this;}// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale){if(timeScale!==1.0){var times=this.times;for(var _i256=0,n=times.length;_i256!==n;++_i256){times[_i256]*=timeScale;}}return this;}// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime,endTime){var times=this.times,nKeys=times.length;var from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
  if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
  if(from>=to){to=Math.max(to,1);from=to-1;}var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;}// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error('THREE.KeyframeTrack: Invalid value size in track.',this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error('THREE.KeyframeTrack: Track is empty.',this);valid=false;}var prevTime=null;for(var _i257=0;_i257!==nKeys;_i257++){var currTime=times[_i257];if(typeof currTime==='number'&&isNaN(currTime)){console.error('THREE.KeyframeTrack: Time is not a valid number.',this,_i257,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error('THREE.KeyframeTrack: Out of order keys.',this,_i257,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var _i258=0,n=values.length;_i258!==n;++_i258){var value=values[_i258];if(isNaN(value)){console.error('THREE.KeyframeTrack: Value is not a valid number.',this,_i258,value);valid=false;break;}}}}return valid;}// removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
  var times=AnimationUtils.arraySlice(this.times),values=AnimationUtils.arraySlice(this.values),stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,lastIndex=times.length-1;var writeIndex=1;for(var _i259=1;_i259<lastIndex;++_i259){var keep=false;var time=times[_i259];var timeNext=times[_i259+1];// remove adjacent keyframes scheduled at the same time
  if(time!==timeNext&&(_i259!==1||time!==times[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
  var offset=_i259*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else {keep=true;}}// in-place compaction
  if(keep){if(_i259!==writeIndex){times[writeIndex]=times[_i259];var readOffset=_i259*stride,writeOffset=writeIndex*stride;for(var _j14=0;_j14!==stride;++_j14){values[writeOffset+_j14]=values[readOffset+_j14];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
  if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var _readOffset=lastIndex*stride,_writeOffset=writeIndex*stride,_j15=0;_j15!==stride;++_j15){values[_writeOffset+_j15]=values[_readOffset+_j15];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}else {this.times=times;this.values=values;}return this;}clone(){var times=AnimationUtils.arraySlice(this.times,0);var values=AnimationUtils.arraySlice(this.values,0);var TypedKeyframeTrack=this.constructor;var track=new TypedKeyframeTrack(this.name,times,values);// Interpolant argument to constructor is not saved, so copy the factory method directly.
  track.createInterpolant=this.createInterpolant;return track;}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;/**
   * A Track of Boolean keyframe values.
   */class BooleanKeyframeTrack extends KeyframeTrack{}BooleanKeyframeTrack.prototype.ValueTypeName='bool';BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track of keyframe values that represent color.
   */class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName='color';/**
   * A Track of numeric keyframe values.
   */class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName='number';/**
   * Spherical linear unit quaternion interpolant.
   */class QuaternionLinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);}interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,alpha=(t-t0)/(t1-t0);var offset=i1*stride;for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}}/**
   * A Track of quaternion keyframe values.
   */class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);}}QuaternionKeyframeTrack.prototype.ValueTypeName='quaternion';// ValueBufferType is inherited
  QuaternionKeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track that interpolates Strings
   */class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName='string';StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track of vectored keyframe values.
   */class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName='vector';class AnimationClip{constructor(name){var duration=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-1;var tracks=arguments.length>2?arguments[2]:undefined;var blendMode=arguments.length>3&&arguments[3]!==undefined?arguments[3]:NormalAnimationBlendMode;this.name=name;this.tracks=tracks;this.duration=duration;this.blendMode=blendMode;this.uuid=generateUUID();// this means it should figure out its duration by scanning the tracks
  if(this.duration<0){this.resetDuration();}}static parse(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var _i260=0,n=jsonTracks.length;_i260!==n;++_i260){tracks.push(parseKeyframeTrack(jsonTracks[_i260]).scale(frameTime));}var clip=new this(json.name,json.duration,tracks,json.blendMode);clip.uuid=json.uuid;return clip;}static toJSON(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks,'uuid':clip.uuid,'blendMode':clip.blendMode};for(var _i261=0,n=clipTracks.length;_i261!==n;++_i261){tracks.push(KeyframeTrack.toJSON(clipTracks[_i261]));}return json;}static CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var _i262=0;_i262<numMorphTargets;_i262++){var times=[];var values=[];times.push((_i262+numMorphTargets-1)%numMorphTargets,_i262,(_i262+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
  // last frame as well for perfect loop.
  if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[_i262].name+']',times,values).scale(1.0/fps));}return new this(name,-1,tracks);}static findByName(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var _i263=0;_i263<clipArray.length;_i263++){if(clipArray[_i263].name===name){return clipArray[_i263];}}return null;}static CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
  // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
  // patterns like Walk_001, Walk_002, Run_001, Run_002
  for(var _i264=0,il=morphTargets.length;_i264<il;_i264++){var morphTarget=morphTargets[_i264];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var _name4 in animationToMorphTargets){clips.push(this.CreateFromMorphTargetSequence(_name4,animationToMorphTargets[_name4],fps,noLoop));}return clips;}// parse the animation.hierarchy format
  static parseAnimation(animation,bones){if(!animation){console.error('THREE.AnimationClip: No animation in JSONLoader data.');return null;}var addNonemptyTrack=function(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
  if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
  if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';var fps=animation.fps||30;var blendMode=animation.blendMode;// automatic length determination in AnimationClip.
  var duration=animation.length||-1;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
  if(!animationKeys||animationKeys.length===0)continue;// process morph targets
  if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
  var morphTargetNames={};var k=void 0;for(k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
  // morphTargetInfluences except for the keys in which
  // the morphTarget is named.
  for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var _m=0;_m!==animationKeys[k].morphTargets.length;++_m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else {// ...assume skeletal animation
  var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new this(clipName,duration,tracks,blendMode);return clip;}resetDuration(){var tracks=this.tracks;var duration=0;for(var _i265=0,n=tracks.length;_i265!==n;++_i265){var track=this.tracks[_i265];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;return this;}trim(){for(var _i266=0;_i266<this.tracks.length;_i266++){this.tracks[_i266].trim(0,this.duration);}return this;}validate(){var valid=true;for(var _i267=0;_i267<this.tracks.length;_i267++){valid=valid&&this.tracks[_i267].validate();}return valid;}optimize(){for(var _i268=0;_i268<this.tracks.length;_i268++){this.tracks[_i268].optimize();}return this;}clone(){var tracks=[];for(var _i269=0;_i269<this.tracks.length;_i269++){tracks.push(this.tracks[_i269].clone());}return new this.constructor(this.name,this.duration,tracks,this.blendMode);}toJSON(){return this.constructor.toJSON(this);}}function getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case'scalar':case'double':case'float':case'number':case'integer':return NumberKeyframeTrack;case'vector':case'vector2':case'vector3':case'vector4':return VectorKeyframeTrack;case'color':return ColorKeyframeTrack;case'quaternion':return QuaternionKeyframeTrack;case'bool':case'boolean':return BooleanKeyframeTrack;case'string':return StringKeyframeTrack;}throw new Error('THREE.KeyframeTrack: Unsupported typeName: '+typeName);}function parseKeyframeTrack(json){if(json.type===undefined){throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');}var trackType=getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
  if(trackType.parse!==undefined){return trackType.parse(json);}else {// by default, we assume a constructor compatible with the base
  return new trackType(json.name,json.times,json.values,json.interpolation);}}var Cache={enabled:false,files:{},add:function(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
  this.files[key]=file;},get:function(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
  return this.files[key];},remove:function(key){delete this.files[key];},clear:function(){this.files={};}};class LoadingManager{constructor(onLoad,onProgress,onError){var scope=this;var isLoading=false;var itemsLoaded=0;var itemsTotal=0;var urlModifier=undefined;var handlers=[];// Refer to #5689 for the reason why we don't set .onStart
  // in the constructor
  this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};this.resolveURL=function(url){if(urlModifier){return urlModifier(url);}return url;};this.setURLModifier=function(transform){urlModifier=transform;return this;};this.addHandler=function(regex,loader){handlers.push(regex,loader);return this;};this.removeHandler=function(regex){var index=handlers.indexOf(regex);if(index!==-1){handlers.splice(index,2);}return this;};this.getHandler=function(file){for(var _i270=0,l=handlers.length;_i270<l;_i270+=2){var regex=handlers[_i270];var loader=handlers[_i270+1];if(regex.global)regex.lastIndex=0;// see #17920
  if(regex.test(file)){return loader;}}return null;};}}var DefaultLoadingManager=new LoadingManager();class Loader{constructor(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.crossOrigin='anonymous';this.withCredentials=false;this.path='';this.resourcePath='';this.requestHeader={};}load(){}loadAsync(url,onProgress){var scope=this;return new Promise(function(resolve,reject){scope.load(url,resolve,onProgress,reject);});}parse(){}setCrossOrigin(crossOrigin){this.crossOrigin=crossOrigin;return this;}setWithCredentials(value){this.withCredentials=value;return this;}setPath(path){this.path=path;return this;}setResourcePath(resourcePath){this.resourcePath=resourcePath;return this;}setRequestHeader(requestHeader){this.requestHeader=requestHeader;return this;}}var loading={};class FileLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var cached=Cache.get(url);if(cached!==undefined){this.manager.itemStart(url);setTimeout(()=>{if(onLoad)onLoad(cached);this.manager.itemEnd(url);},0);return cached;}// Check if request is duplicate
  if(loading[url]!==undefined){loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});return;}// Initialise array for duplicate requests
  loading[url]=[];loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});// create request
  var req=new Request(url,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?'include':'same-origin'// An abort controller could be added within a future PR
  });// start the fetch
  fetch(req).then(response=>{if(response.status===200||response.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
  // e.g. 'file://' or 'data://'. Handle as success.
  if(response.status===0){console.warn('THREE.FileLoader: HTTP Status 0 received.');}var callbacks=loading[url];var reader=response.body.getReader();var contentLength=response.headers.get('Content-Length');var total=contentLength?parseInt(contentLength):0;var lengthComputable=total!==0;var loaded=0;// periodically read data into the new stream tracking while download progress
  return new ReadableStream({start(controller){readData();function readData(){reader.read().then(_ref2=>{var{done,value}=_ref2;if(done){controller.close();}else {loaded+=value.byteLength;var event=new ProgressEvent('progress',{lengthComputable,loaded,total});for(var _i271=0,il=callbacks.length;_i271<il;_i271++){var callback=callbacks[_i271];if(callback.onProgress)callback.onProgress(event);}controller.enqueue(value);readData();}});}}});}else {throw Error("fetch for \"".concat(response.url,"\" responded with ").concat(response.status,": ").concat(response.statusText));}}).then(stream=>{var response=new Response(stream);switch(this.responseType){case'arraybuffer':return response.arrayBuffer();case'blob':return response.blob();case'document':return response.text().then(text=>{var parser=new DOMParser();return parser.parseFromString(text,this.mimeType);});case'json':return response.json();default:return response.text();}}).then(data=>{// Add to cache only on HTTP success, so that we do not cache
  // error response bodies as proper responses to requests.
  Cache.add(url,data);var callbacks=loading[url];delete loading[url];for(var _i272=0,il=callbacks.length;_i272<il;_i272++){var callback=callbacks[_i272];if(callback.onLoad)callback.onLoad(data);}this.manager.itemEnd(url);}).catch(err=>{// Abort errors and other errors are handled the same
  var callbacks=loading[url];delete loading[url];for(var _i273=0,il=callbacks.length;_i273<il;_i273++){var callback=callbacks[_i273];if(callback.onError)callback.onError(err);}this.manager.itemError(url);this.manager.itemEnd(url);});this.manager.itemStart(url);}setResponseType(value){this.responseType=value;return this;}setMimeType(value){this.mimeType=value;return this;}}class ImageLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=createElementNS('img');function onImageLoad(){removeEventListeners();Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);}function onImageError(event){removeEventListeners();if(onError)onError(event);scope.manager.itemError(url);scope.manager.itemEnd(url);}function removeEventListeners(){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);}image.addEventListener('load',onImageLoad,false);image.addEventListener('error',onImageError,false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;}}class CubeTextureLoader extends Loader{constructor(manager){super(manager);}load(urls,onLoad,onProgress,onError){var texture=new CubeTexture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(var _i277=0;_i277<urls.length;++_i277){loadTexture(_i277);}return texture;}}/**
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */class DataTextureLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){var scope=this;var texture=new DataTexture();var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.setRequestHeader(this.requestHeader);loader.setPath(this.path);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(buffer){var texData=scope.parse(buffer);if(!texData)return;if(texData.image!==undefined){texture.image=texData.image;}else if(texData.data!==undefined){texture.image.width=texData.width;texture.image.height=texData.height;texture.image.data=texData.data;}texture.wrapS=texData.wrapS!==undefined?texData.wrapS:ClampToEdgeWrapping;texture.wrapT=texData.wrapT!==undefined?texData.wrapT:ClampToEdgeWrapping;texture.magFilter=texData.magFilter!==undefined?texData.magFilter:LinearFilter;texture.minFilter=texData.minFilter!==undefined?texData.minFilter:LinearFilter;texture.anisotropy=texData.anisotropy!==undefined?texData.anisotropy:1;if(texData.encoding!==undefined){texture.encoding=texData.encoding;}if(texData.flipY!==undefined){texture.flipY=texData.flipY;}if(texData.format!==undefined){texture.format=texData.format;}if(texData.type!==undefined){texture.type=texData.type;}if(texData.mipmaps!==undefined){texture.mipmaps=texData.mipmaps;texture.minFilter=LinearMipmapLinearFilter;// presumably...
  }if(texData.mipmapCount===1){texture.minFilter=LinearFilter;}if(texData.generateMipmaps!==undefined){texture.generateMipmaps=texData.generateMipmaps;}texture.needsUpdate=true;if(onLoad)onLoad(texture,texData);},onProgress,onError);return texture;}}class TextureLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){var texture=new Texture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){texture.image=image;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;}}class Light extends Object3D{constructor(color){var intensity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;super();this.type='Light';this.color=new Color(color);this.intensity=intensity;}dispose(){// Empty here in base class; some subclasses override.
  }copy(source){super.copy(source);this.color.copy(source.color);this.intensity=source.intensity;return this;}toJSON(meta){var data=super.toJSON(meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}}Light.prototype.isLight=true;class HemisphereLight extends Light{constructor(skyColor,groundColor,intensity){super(skyColor,intensity);this.type='HemisphereLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}copy(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}}HemisphereLight.prototype.isHemisphereLight=true;var _projScreenMatrix$1=/*@__PURE__*/new Matrix4();var _lightPositionWorld$1=/*@__PURE__*/new Vector3();var _lookTarget$1=/*@__PURE__*/new Vector3();class LightShadow{constructor(camera){this.camera=camera;this.bias=0;this.normalBias=0;this.radius=1;this.blurSamples=8;this.mapSize=new Vector2(512,512);this.map=null;this.mapPass=null;this.matrix=new Matrix4();this.autoUpdate=true;this.needsUpdate=false;this._frustum=new Frustum();this._frameExtents=new Vector2(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)];}getViewportCount(){return this._viewportCount;}getFrustum(){return this._frustum;}updateMatrices(light){var shadowCamera=this.camera;var shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld$1);_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget$1);shadowCamera.updateMatrixWorld();_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);}getViewport(viewportIndex){return this._viewports[viewportIndex];}getFrameExtents(){return this._frameExtents;}dispose(){if(this.map){this.map.dispose();}if(this.mapPass){this.mapPass.dispose();}}copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;}clone(){return new this.constructor().copy(this);}toJSON(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.normalBias!==0)object.normalBias=this.normalBias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,0.5,500));this.focus=1;}updateMatrices(light){var camera=this.camera;var fov=RAD2DEG*2*light.angle*this.focus;var aspect=this.mapSize.width/this.mapSize.height;var far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}super.updateMatrices(light);}copy(source){super.copy(source);this.focus=source.focus;return this;}}SpotLightShadow.prototype.isSpotLightShadow=true;class SpotLight extends Light{constructor(color,intensity){var distance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var angle=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Math.PI/3;var penumbra=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var decay=arguments.length>5&&arguments[5]!==undefined?arguments[5]:1;super(color,intensity);this.type='SpotLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.distance=distance;this.angle=angle;this.penumbra=penumbra;this.decay=decay;// for physically correct lights, should be 2.
  this.shadow=new SpotLightShadow();}get power(){// compute the light's luminous power (in lumens) from its intensity (in candela)
  // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
  return this.intensity*Math.PI;}set power(power){// set the light's intensity (in candela) from the desired luminous power (in lumens)
  this.intensity=power/Math.PI;}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}SpotLight.prototype.isSpotLight=true;var _projScreenMatrix=/*@__PURE__*/new Matrix4();var _lightPositionWorld=/*@__PURE__*/new Vector3();var _lookTarget=/*@__PURE__*/new Vector3();class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,0.5,500));this._frameExtents=new Vector2(4,2);this._viewportCount=6;this._viewports=[// These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction
  // positive X
  new Vector4(2,1,1,1),// negative X
  new Vector4(0,1,1,1),// positive Z
  new Vector4(3,1,1,1),// negative Z
  new Vector4(1,1,1,1),// positive Y
  new Vector4(3,0,1,1),// negative Y
  new Vector4(1,0,1,1)];this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];}updateMatrices(light){var viewportIndex=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var camera=this.camera;var shadowMatrix=this.matrix;var far=light.distance||camera.far;if(far!==camera.far){camera.far=far;camera.updateProjectionMatrix();}_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);camera.position.copy(_lightPositionWorld);_lookTarget.copy(camera.position);_lookTarget.add(this._cubeDirections[viewportIndex]);camera.up.copy(this._cubeUps[viewportIndex]);camera.lookAt(_lookTarget);camera.updateMatrixWorld();shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix);}}PointLightShadow.prototype.isPointLightShadow=true;class PointLight extends Light{constructor(color,intensity){var distance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var decay=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;super(color,intensity);this.type='PointLight';this.distance=distance;this.decay=decay;// for physically correct lights, should be 2.
  this.shadow=new PointLightShadow();}get power(){// compute the light's luminous power (in lumens) from its intensity (in candela)
  // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
  return this.intensity*4*Math.PI;}set power(power){// set the light's intensity (in candela) from the desired luminous power (in lumens)
  this.intensity=power/(4*Math.PI);}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}}PointLight.prototype.isPointLight=true;class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,0.5,500));}}DirectionalLightShadow.prototype.isDirectionalLightShadow=true;class DirectionalLight extends Light{constructor(color,intensity){super(color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.shadow=new DirectionalLightShadow();}dispose(){this.shadow.dispose();}copy(source){super.copy(source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}DirectionalLight.prototype.isDirectionalLight=true;class AmbientLight extends Light{constructor(color,intensity){super(color,intensity);this.type='AmbientLight';}}AmbientLight.prototype.isAmbientLight=true;class RectAreaLight extends Light{constructor(color,intensity){var width=arguments.length>2&&arguments[2]!==undefined?arguments[2]:10;var height=arguments.length>3&&arguments[3]!==undefined?arguments[3]:10;super(color,intensity);this.type='RectAreaLight';this.width=width;this.height=height;}get power(){// compute the light's luminous power (in lumens) from its intensity (in nits)
  return this.intensity*this.width*this.height*Math.PI;}set power(power){// set the light's intensity (in nits) from the desired luminous power (in lumens)
  this.intensity=power/(this.width*this.height*Math.PI);}copy(source){super.copy(source);this.width=source.width;this.height=source.height;return this;}toJSON(meta){var data=super.toJSON(meta);data.object.width=this.width;data.object.height=this.height;return data;}}RectAreaLight.prototype.isRectAreaLight=true;/**
   * Primary reference:
   *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
   *
   * Secondary reference:
   *   https://www.ppsloan.org/publications/StupidSH36.pdf
   */ // 3-band SH defined by 9 coefficients
  class SphericalHarmonics3{constructor(){this.coefficients=[];for(var _i278=0;_i278<9;_i278++){this.coefficients.push(new Vector3());}}set(coefficients){for(var _i279=0;_i279<9;_i279++){this.coefficients[_i279].copy(coefficients[_i279]);}return this;}zero(){for(var _i280=0;_i280<9;_i280++){this.coefficients[_i280].set(0,0,0);}return this;}// get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal,target){// normal is assumed to be unit length
  var x=normal.x,y=normal.y,z=normal.z;var coeff=this.coefficients;// band 0
  target.copy(coeff[0]).multiplyScalar(0.282095);// band 1
  target.addScaledVector(coeff[1],0.488603*y);target.addScaledVector(coeff[2],0.488603*z);target.addScaledVector(coeff[3],0.488603*x);// band 2
  target.addScaledVector(coeff[4],1.092548*(x*y));target.addScaledVector(coeff[5],1.092548*(y*z));target.addScaledVector(coeff[6],0.315392*(3.0*z*z-1.0));target.addScaledVector(coeff[7],1.092548*(x*z));target.addScaledVector(coeff[8],0.546274*(x*x-y*y));return target;}// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal,target){// normal is assumed to be unit length
  var x=normal.x,y=normal.y,z=normal.z;var coeff=this.coefficients;// band 0
  target.copy(coeff[0]).multiplyScalar(0.886227);//  * 0.282095
  // band 1
  target.addScaledVector(coeff[1],2.0*0.511664*y);// ( 2 *  / 3 ) * 0.488603
  target.addScaledVector(coeff[2],2.0*0.511664*z);target.addScaledVector(coeff[3],2.0*0.511664*x);// band 2
  target.addScaledVector(coeff[4],2.0*0.429043*x*y);// (  / 4 ) * 1.092548
  target.addScaledVector(coeff[5],2.0*0.429043*y*z);target.addScaledVector(coeff[6],0.743125*z*z-0.247708);// (  / 4 ) * 0.315392 * 3
  target.addScaledVector(coeff[7],2.0*0.429043*x*z);target.addScaledVector(coeff[8],0.429043*(x*x-y*y));// (  / 4 ) * 0.546274
  return target;}add(sh){for(var _i281=0;_i281<9;_i281++){this.coefficients[_i281].add(sh.coefficients[_i281]);}return this;}addScaledSH(sh,s){for(var _i282=0;_i282<9;_i282++){this.coefficients[_i282].addScaledVector(sh.coefficients[_i282],s);}return this;}scale(s){for(var _i283=0;_i283<9;_i283++){this.coefficients[_i283].multiplyScalar(s);}return this;}lerp(sh,alpha){for(var _i284=0;_i284<9;_i284++){this.coefficients[_i284].lerp(sh.coefficients[_i284],alpha);}return this;}equals(sh){for(var _i285=0;_i285<9;_i285++){if(!this.coefficients[_i285].equals(sh.coefficients[_i285])){return false;}}return true;}copy(sh){return this.set(sh.coefficients);}clone(){return new this.constructor().copy(this);}fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var coefficients=this.coefficients;for(var _i286=0;_i286<9;_i286++){coefficients[_i286].fromArray(array,offset+_i286*3);}return this;}toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var coefficients=this.coefficients;for(var _i287=0;_i287<9;_i287++){coefficients[_i287].toArray(array,offset+_i287*3);}return array;}// evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal,shBasis){// normal is assumed to be unit length
  var x=normal.x,y=normal.y,z=normal.z;// band 0
  shBasis[0]=0.282095;// band 1
  shBasis[1]=0.488603*y;shBasis[2]=0.488603*z;shBasis[3]=0.488603*x;// band 2
  shBasis[4]=1.092548*x*y;shBasis[5]=1.092548*y*z;shBasis[6]=0.315392*(3*z*z-1);shBasis[7]=1.092548*x*z;shBasis[8]=0.546274*(x*x-y*y);}}SphericalHarmonics3.prototype.isSphericalHarmonics3=true;class LightProbe extends Light{constructor(){var sh=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new SphericalHarmonics3();var intensity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;super(undefined,intensity);this.sh=sh;}copy(source){super.copy(source);this.sh.copy(source.sh);return this;}fromJSON(json){this.intensity=json.intensity;// TODO: Move this bit to Light.fromJSON();
  this.sh.fromArray(json.sh);return this;}toJSON(meta){var data=super.toJSON(meta);data.object.sh=this.sh.toArray();return data;}}LightProbe.prototype.isLightProbe=true;class LoaderUtils{static decodeText(array){if(typeof TextDecoder!=='undefined'){return new TextDecoder().decode(array);}// Avoid the String.fromCharCode.apply(null, array) shortcut, which
  // throws a "maximum call stack size exceeded" error for large arrays.
  var s='';for(var _i288=0,il=array.length;_i288<il;_i288++){// Implicitly assumes little-endian.
  s+=String.fromCharCode(array[_i288]);}try{// merges multi-byte utf-8 characters.
  return decodeURIComponent(escape(s));}catch(e){// see #16358
  return s;}}static extractUrlBase(url){var index=url.lastIndexOf('/');if(index===-1)return './';return url.substr(0,index+1);}static resolveURL(url,path){// Invalid URL
  if(typeof url!=='string'||url==='')return '';// Host Relative URL
  if(/^https?:\/\//i.test(path)&&/^\//.test(url)){path=path.replace(/(^https?:\/\/[^\/]+).*/i,'$1');}// Absolute URL http://,https://,//
  if(/^(https?:)?\/\//i.test(url))return url;// Data URI
  if(/^data:.*,.*$/i.test(url))return url;// Blob URL
  if(/^blob:.*$/i.test(url))return url;// Relative URL
  return path+url;}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super();this.type='InstancedBufferGeometry';this.instanceCount=Infinity;}copy(source){super.copy(source);this.instanceCount=source.instanceCount;return this;}clone(){return new this.constructor().copy(this);}toJSON(){var data=super.toJSON(this);data.instanceCount=this.instanceCount;data.isInstancedBufferGeometry=true;return data;}}InstancedBufferGeometry.prototype.isInstancedBufferGeometry=true;class ImageBitmapLoader extends Loader{constructor(manager){super(manager);if(typeof createImageBitmap==='undefined'){console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');}if(typeof fetch==='undefined'){console.warn('THREE.ImageBitmapLoader: fetch() not supported.');}this.options={premultiplyAlpha:'none'};}setOptions(options){this.options=options;return this;}load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var fetchOptions={};fetchOptions.credentials=this.crossOrigin==='anonymous'?'same-origin':'include';fetchOptions.headers=this.requestHeader;fetch(url,fetchOptions).then(function(res){return res.blob();}).then(function(blob){return createImageBitmap(blob,Object.assign(scope.options,{colorSpaceConversion:'none'}));}).then(function(imageBitmap){Cache.add(url,imageBitmap);if(onLoad)onLoad(imageBitmap);scope.manager.itemEnd(url);}).catch(function(e){if(onError)onError(e);scope.manager.itemError(url);scope.manager.itemEnd(url);});scope.manager.itemStart(url);}}ImageBitmapLoader.prototype.isImageBitmapLoader=true;var _context;var AudioContext={getContext:function(){if(_context===undefined){_context=new(window.AudioContext||window.webkitAudioContext)();}return _context;},setContext:function(value){_context=value;}};class AudioLoader extends Loader{constructor(manager){super(manager);}load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(buffer){try{// Create a copy of the buffer. The `decodeAudioData` method
  // detaches the buffer when complete, preventing reuse.
  var bufferCopy=buffer.slice(0);var context=AudioContext.getContext();context.decodeAudioData(bufferCopy,function(audioBuffer){onLoad(audioBuffer);});}catch(e){if(onError){onError(e);}else {console.error(e);}scope.manager.itemError(url);}},onProgress,onError);}}class HemisphereLightProbe extends LightProbe{constructor(skyColor,groundColor){var intensity=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;super(undefined,intensity);var color1=new Color().set(skyColor);var color2=new Color().set(groundColor);var sky=new Vector3(color1.r,color1.g,color1.b);var ground=new Vector3(color2.r,color2.g,color2.b);// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
  var c0=Math.sqrt(Math.PI);var c1=c0*Math.sqrt(0.75);this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);}}HemisphereLightProbe.prototype.isHemisphereLightProbe=true;class AmbientLightProbe extends LightProbe{constructor(color){var intensity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;super(undefined,intensity);var color1=new Color().set(color);// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
  this.sh.coefficients[0].set(color1.r,color1.g,color1.b).multiplyScalar(2*Math.sqrt(Math.PI));}}AmbientLightProbe.prototype.isAmbientLightProbe=true;class Clock{constructor(){var autoStart=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.autoStart=autoStart;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}start(){this.startTime=now();this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;}stop(){this.getElapsedTime();this.running=false;this.autoStart=false;}getElapsedTime(){this.getDelta();return this.elapsedTime;}getDelta(){var diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){var newTime=now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}}function now(){return (typeof performance==='undefined'?Date:performance).now();// see #10732
  }class Audio extends Object3D{constructor(listener){super();this.type='Audio';this.listener=listener;this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());this.autoplay=false;this.buffer=null;this.detune=0;this.loop=false;this.loopStart=0;this.loopEnd=0;this.offset=0;this.duration=undefined;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.source=null;this.sourceType='empty';this._startedAt=0;this._progress=0;this._connected=false;this.filters=[];}getOutput(){return this.gain;}setNodeSource(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;}setMediaElementSource(mediaElement){this.hasPlaybackControl=false;this.sourceType='mediaNode';this.source=this.context.createMediaElementSource(mediaElement);this.connect();return this;}setMediaStreamSource(mediaStream){this.hasPlaybackControl=false;this.sourceType='mediaStreamNode';this.source=this.context.createMediaStreamSource(mediaStream);this.connect();return this;}setBuffer(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;}play(){var delay=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._startedAt=this.context.currentTime+delay;var source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.loopStart=this.loopStart;source.loopEnd=this.loopEnd;source.onended=this.onEnded.bind(this);source.start(this._startedAt,this._progress+this.offset,this.duration);this.isPlaying=true;this.source=source;this.setDetune(this.detune);this.setPlaybackRate(this.playbackRate);return this.connect();}pause(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}if(this.isPlaying===true){// update current progress
  this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate;if(this.loop===true){// ensure _progress does not exceed duration with looped audios
  this._progress=this._progress%(this.duration||this.buffer.duration);}this.source.stop();this.source.onended=null;this.isPlaying=false;}return this;}stop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._progress=0;this.source.stop();this.source.onended=null;this.isPlaying=false;return this;}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var _i302=1,l=this.filters.length;_i302<l;_i302++){this.filters[_i302-1].connect(this.filters[_i302]);}this.filters[this.filters.length-1].connect(this.getOutput());}else {this.source.connect(this.getOutput());}this._connected=true;return this;}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var _i303=1,l=this.filters.length;_i303<l;_i303++){this.filters[_i303-1].disconnect(this.filters[_i303]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else {this.source.disconnect(this.getOutput());}this._connected=false;return this;}getFilters(){return this.filters;}setFilters(value){if(!value)value=[];if(this._connected===true){this.disconnect();this.filters=value.slice();this.connect();}else {this.filters=value.slice();}return this;}setDetune(value){this.detune=value;if(this.source.detune===undefined)return;// only set detune when available
  if(this.isPlaying===true){this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,0.01);}return this;}getDetune(){return this.detune;}getFilter(){return this.getFilters()[0];}setFilter(filter){return this.setFilters(filter?[filter]:[]);}setPlaybackRate(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,0.01);}return this;}getPlaybackRate(){return this.playbackRate;}onEnded(){this.isPlaying=false;}getLoop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;}setLoop(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;}setLoopStart(value){this.loopStart=value;return this;}setLoopEnd(value){this.loopEnd=value;return this;}getVolume(){return this.gain.gain.value;}setVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);return this;}}class AudioAnalyser{constructor(audio){var fftSize=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2048;this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser);}getFrequencyData(){this.analyser.getByteFrequencyData(this.data);return this.data;}getAverageFrequency(){var value=0;var data=this.getFrequencyData();for(var _i304=0;_i304<data.length;_i304++){value+=data[_i304];}return value/data.length;}}class PropertyMixer{constructor(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;var mixFunction,mixFunctionAdditive,setIdentity;// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property
  //
  // 'add' is used for additive cumulative results
  //
  // 'work' is optional and is only present for quaternion types. It is used
  // to store intermediate quaternion multiplication results
  switch(typeName){case'quaternion':mixFunction=this._slerp;mixFunctionAdditive=this._slerpAdditive;setIdentity=this._setAdditiveIdentityQuaternion;this.buffer=new Float64Array(valueSize*6);this._workIndex=5;break;case'string':case'bool':mixFunction=this._select;// Use the regular mix function and for additive on these types,
  // additive is not relevant for non-numeric types
  mixFunctionAdditive=this._select;setIdentity=this._setAdditiveIdentityOther;this.buffer=new Array(valueSize*5);break;default:mixFunction=this._lerp;mixFunctionAdditive=this._lerpAdditive;setIdentity=this._setAdditiveIdentityNumeric;this.buffer=new Float64Array(valueSize*5);}this._mixBufferRegion=mixFunction;this._mixBufferRegionAdditive=mixFunctionAdditive;this._setIdentity=setIdentity;this._origIndex=3;this._addIndex=4;this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;this.useCount=0;this.referenceCount=0;}// accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(accuIndex,weight){// note: happily accumulating nothing when weight = 0, the caller knows
  // the weight and shouldn't have made the call in the first place
  var buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride;var currentWeight=this.cumulativeWeight;if(currentWeight===0){// accuN := incoming * weight
  for(var _i305=0;_i305!==stride;++_i305){buffer[offset+_i305]=buffer[_i305];}currentWeight=weight;}else {// accuN := accuN + incoming * weight
  currentWeight+=weight;var mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride);}this.cumulativeWeight=currentWeight;}// accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(weight){var buffer=this.buffer,stride=this.valueSize,offset=stride*this._addIndex;if(this.cumulativeWeightAdditive===0){// add = identity
  this._setIdentity();}// add := add + incoming * weight
  this._mixBufferRegionAdditive(buffer,offset,0,weight,stride);this.cumulativeWeightAdditive+=weight;}// apply the state of 'accu<i>' to the binding when accus differ
  apply(accuIndex){var stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,weightAdditive=this.cumulativeWeightAdditive,binding=this.binding;this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;if(weight<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
  var originalValueOffset=stride*this._origIndex;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride);}if(weightAdditive>0){// accuN := accuN + additive accuN
  this._mixBufferRegionAdditive(buffer,offset,this._addIndex*stride,1,stride);}for(var _i306=stride,e=stride+stride;_i306!==e;++_i306){if(buffer[_i306]!==buffer[_i306+stride]){// value has changed -> update scene graph
  binding.setValue(buffer,offset);break;}}}// remember the state of the bound property and copy it to both accus
  saveOriginalState(){var binding=this.binding;var buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*this._origIndex;binding.getValue(buffer,originalValueOffset);// accu[0..1] := orig -- initially detect changes against the original
  for(var _i307=stride,e=originalValueOffset;_i307!==e;++_i307){buffer[_i307]=buffer[originalValueOffset+_i307%stride];}// Add to identity for additive
  this._setIdentity();this.cumulativeWeight=0;this.cumulativeWeightAdditive=0;}// apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState(){var originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset);}_setAdditiveIdentityNumeric(){var startIndex=this._addIndex*this.valueSize;var endIndex=startIndex+this.valueSize;for(var _i308=startIndex;_i308<endIndex;_i308++){this.buffer[_i308]=0;}}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric();this.buffer[this._addIndex*this.valueSize+3]=1;}_setAdditiveIdentityOther(){var startIndex=this._origIndex*this.valueSize;var targetIndex=this._addIndex*this.valueSize;for(var _i309=0;_i309<this.valueSize;_i309++){this.buffer[targetIndex+_i309]=this.buffer[startIndex+_i309];}}// mix functions
  _select(buffer,dstOffset,srcOffset,t,stride){if(t>=0.5){for(var _i310=0;_i310!==stride;++_i310){buffer[dstOffset+_i310]=buffer[srcOffset+_i310];}}}_slerp(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);}_slerpAdditive(buffer,dstOffset,srcOffset,t,stride){var workOffset=this._workIndex*stride;// Store result in intermediate buffer offset
  Quaternion.multiplyQuaternionsFlat(buffer,workOffset,buffer,dstOffset,buffer,srcOffset);// Slerp to the intermediate result
  Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,workOffset,t);}_lerp(buffer,dstOffset,srcOffset,t,stride){var s=1-t;for(var _i311=0;_i311!==stride;++_i311){var j=dstOffset+_i311;buffer[j]=buffer[j]*s+buffer[srcOffset+_i311]*t;}}_lerpAdditive(buffer,dstOffset,srcOffset,t,stride){for(var _i312=0;_i312!==stride;++_i312){var j=dstOffset+_i312;buffer[j]=buffer[j]+buffer[srcOffset+_i312]*t;}}}// Characters [].:/ are reserved for track binding syntax.
  var _RESERVED_CHARS_RE='\\[\\]\\.:\\/';var _reservedRe=new RegExp('['+_RESERVED_CHARS_RE+']','g');// Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  var _wordChar='[^'+_RESERVED_CHARS_RE+']';var _wordCharOrDot='[^'+_RESERVED_CHARS_RE.replace('\\.','')+']';// Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  var _directoryRe=/((?:WC+[\/:])*)/.source.replace('WC',_wordChar);// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  var _nodeRe=/(WCOD+)?/.source.replace('WCOD',_wordCharOrDot);// Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  var _objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC',_wordChar);// Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  var _propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace('WC',_wordChar);var _trackRe=new RegExp(''+'^'+_directoryRe+_nodeRe+_objectRe+_propertyRe+'$');var _supportedObjectNames=['material','materials','bones'];class Composite{constructor(targetGroup,path,optionalParsedPath){var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);}getValue(array,offset){this.bind();// bind all binding
  var firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
  if(binding!==undefined)binding.getValue(array,offset);}setValue(array,offset){var bindings=this._bindings;for(var _i313=this._targetGroup.nCachedObjects_,n=bindings.length;_i313!==n;++_i313){bindings[_i313].setValue(array,offset);}}bind(){var bindings=this._bindings;for(var _i314=this._targetGroup.nCachedObjects_,n=bindings.length;_i314!==n;++_i314){bindings[_i314].bind();}}unbind(){var bindings=this._bindings;for(var _i315=this._targetGroup.nCachedObjects_,n=bindings.length;_i315!==n;++_i315){bindings[_i315].unbind();}}}// Note: This class uses a State pattern on a per-method basis:
  // 'bind' sets 'this.getValue' / 'setValue' and shadows the
  // prototype version of these methods with one that represents
  // the bound state. When the property is not found, the methods
  // become no-ops.
  class PropertyBinding{constructor(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;// initial state of these methods that calls 'bind'
  this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}static create(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else {return new PropertyBinding.Composite(root,path,parsedPath);}}/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param {string} name Node name to be sanitized.
  	 * @return {string}
  	 */static sanitizeNodeName(name){return name.replace(/\s/g,'_').replace(_reservedRe,'');}static parseTrackName(trackName){var matches=_trackRe.exec(trackName);if(!matches){throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);}var results={// directoryName: matches[ 1 ], // (tschw) currently unused
  nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],// required
  propertyIndex:matches[6]};var lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');if(lastDot!==undefined&&lastDot!==-1){var objectName=results.nodeName.substring(lastDot+1);// Object names must be checked against an allowlist. Otherwise, there
  // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  // 'bar' could be the objectName, or part of a nodeName (which can
  // include '.' characters).
  if(_supportedObjectNames.indexOf(objectName)!==-1){results.nodeName=results.nodeName.substring(0,lastDot);results.objectName=objectName;}}if(results.propertyName===null||results.propertyName.length===0){throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);}return results;}static findNode(root,nodeName){if(!nodeName||nodeName===''||nodeName==='.'||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
  if(root.skeleton){var bone=root.skeleton.getBoneByName(nodeName);if(bone!==undefined){return bone;}}// search into node subtree.
  if(root.children){var searchNodeSubtree=function(children){for(var _i316=0;_i316<children.length;_i316++){var childNode=children[_i316];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}var result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};var subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;}// these are used to "bind" a nonexistent property
  _getValue_unavailable(){}_setValue_unavailable(){}// Getters
  _getValue_direct(buffer,offset){buffer[offset]=this.targetObject[this.propertyName];}_getValue_array(buffer,offset){var source=this.resolvedProperty;for(var _i317=0,n=source.length;_i317!==n;++_i317){buffer[offset++]=source[_i317];}}_getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];}_getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}// Direct
  _setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];}_setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;}_setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}// EntireArray
  _setValue_array(buffer,offset){var dest=this.resolvedProperty;for(var _i318=0,n=dest.length;_i318!==n;++_i318){dest[_i318]=buffer[offset++];}}_setValue_array_setNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var _i319=0,n=dest.length;_i319!==n;++_i319){dest[_i319]=buffer[offset++];}this.targetObject.needsUpdate=true;}_setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var _i320=0,n=dest.length;_i320!==n;++_i320){dest[_i320]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}// ArrayElement
  _setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];}_setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;}_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}// HasToFromArray
  _setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);}_setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;}_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}_getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);}_setValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);}// create getter / setter pair for a property in the scene graph
  bind(){var targetObject=this.node;var parsedPath=this.parsedPath;var objectName=parsedPath.objectName;var propertyName=parsedPath.propertyName;var propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
  this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
  if(!targetObject){console.error('THREE.PropertyBinding: Trying to update node for track: '+this.path+' but it wasn\'t found.');return;}if(objectName){var objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
  switch(objectName){case'materials':if(!targetObject.material){console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.',this);return;}if(!targetObject.material.materials){console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
  // and convert the integer string to a true integer.
  targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
  for(var _i321=0;_i321<targetObject.length;_i321++){if(targetObject[_i321].name===objectIndex){objectIndex=_i321;break;}}break;default:if(targetObject[objectName]===undefined){console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
  var nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){var nodeName=parsedPath.nodeName;console.error('THREE.PropertyBinding: Trying to update property for track: '+nodeName+'.'+propertyName+' but it wasn\'t found.',targetObject);return;}// determine versioning scheme
  var versioning=this.Versioning.None;this.targetObject=targetObject;if(targetObject.needsUpdate!==undefined){// material
  versioning=this.Versioning.NeedsUpdate;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
  versioning=this.Versioning.MatrixWorldNeedsUpdate;}// determine how the property gets bound
  var bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
  if(propertyName==='morphTargetInfluences'){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
  // support resolving morphTarget names into indices.
  if(!targetObject.geometry){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',this);return;}if(targetObject.geometry.isBufferGeometry){if(!targetObject.geometry.morphAttributes){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',this);return;}if(targetObject.morphTargetDictionary[propertyIndex]!==undefined){propertyIndex=targetObject.morphTargetDictionary[propertyIndex];}}else {console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',this);return;}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
  bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if(Array.isArray(nodeProperty)){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else {this.propertyName=propertyName;}// select getter / setter
  this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];}unbind(){this.node=null;// back to the prototype version of getValue / setValue
  // note: avoiding to mutate the shape of 'this' via 'delete'
  this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[// Direct
  PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[// EntireArray
  PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[// ArrayElement
  PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[// HasToFromArray
  PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];/**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   *  - Add objects you would otherwise pass as 'root' to the
   *    constructor or the .clipAction method of AnimationMixer.
   *
   *  - Instead pass this object as 'root'.
   *
   *  - You can also add and remove objects later when the mixer
   *    is running.
   *
   * Note:
   *
   *    Objects of this class appear as one object to the mixer,
   *    so cache control of the individual objects must be done
   *    on the group.
   *
   * Limitation:
   *
   *  - The animated properties must be compatible among the
   *    all objects in the group.
   *
   *  - A single property can either be controlled through a
   *    target group or directly, but not both.
   */class AnimationObjectGroup{constructor(){this.uuid=generateUUID();// cached objects followed by the active ones
  this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;// threshold
  // note: read by PropertyBinding.Composite
  var indices={};this._indicesByUUID=indices;// for bookkeeping
  for(var _i322=0,n=arguments.length;_i322!==n;++_i322){indices[arguments[_i322].uuid]=_i322;}this._paths=[];// inside: string
  this._parsedPaths=[];// inside: { we don't care, here }
  this._bindings=[];// inside: Array< PropertyBinding >
  this._bindingsIndicesByPath={};// inside: indices in these arrays
  var scope=this;this.stats={objects:{get total(){return scope._objects.length;},get inUse(){return this.total-scope.nCachedObjects_;}},get bindingsPerObject(){return scope._bindings.length;}};}add(){var objects=this._objects,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;var knownObject=undefined,nObjects=objects.length,nCachedObjects=this.nCachedObjects_;for(var _i323=0,n=arguments.length;_i323!==n;++_i323){var object=arguments[_i323],uuid=object.uuid;var index=indicesByUUID[uuid];if(index===undefined){// unknown object -> add it to the ACTIVE region
  index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));}}else if(index<nCachedObjects){knownObject=objects[index];// move existing object to the ACTIVE region
  var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;// accounting is done, now do the same for all bindings
  for(var _j16=0,_m2=nBindings;_j16!==_m2;++_j16){var bindingsForPath=bindings[_j16],lastCached=bindingsForPath[firstActiveIndex];var binding=bindingsForPath[index];bindingsForPath[index]=lastCached;if(binding===undefined){// since we do not bother to create new bindings
  // for objects that are cached, the binding may
  // or may not exist
  binding=new PropertyBinding(object,paths[_j16],parsedPaths[_j16]);}bindingsForPath[firstActiveIndex]=binding;}}else if(objects[index]!==knownObject){console.error('THREE.AnimationObjectGroup: Different objects with the same UUID '+'detected. Clean the caches or recreate your infrastructure when reloading scenes.');}// else the object is already where we want it to be
  }// for arguments
  this.nCachedObjects_=nCachedObjects;}remove(){var objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;var nCachedObjects=this.nCachedObjects_;for(var _i324=0,n=arguments.length;_i324!==n;++_i324){var object=arguments[_i324],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined&&index>=nCachedObjects){// move existing object into the CACHED region
  var lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive;bindingsForPath[lastCachedIndex]=binding;}}}// for arguments
  this.nCachedObjects_=nCachedObjects;}// remove & forget
  uncache(){var objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;var nCachedObjects=this.nCachedObjects_,nObjects=objects.length;for(var _i325=0,n=arguments.length;_i325!==n;++_i325){var object=arguments[_i325],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined){delete indicesByUUID[uuid];if(index<nCachedObjects){// object is cached, shrink the CACHED region
  var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];// last cached object takes this object's place
  indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;// last object goes to the activated slot and pop
  indicesByUUID[lastObject.uuid]=firstActiveIndex;objects[firstActiveIndex]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached;bindingsForPath[firstActiveIndex]=last;bindingsForPath.pop();}}else {// object is active, just swap with the last and pop
  var _lastIndex=--nObjects,_lastObject=objects[_lastIndex];if(_lastIndex>0){indicesByUUID[_lastObject.uuid]=index;}objects[index]=_lastObject;objects.pop();// accounting is done, now do the same for all bindings
  for(var _j17=0,_m3=nBindings;_j17!==_m3;++_j17){var _bindingsForPath=bindings[_j17];_bindingsForPath[index]=_bindingsForPath[_lastIndex];_bindingsForPath.pop();}}// cached or active
  }// if object is known
  }// for arguments
  this.nCachedObjects_=nCachedObjects;}// Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(path,parsedPath){// returns an array of bindings for the given path that is changed
  // according to the contained objects in the group
  var indicesByPath=this._bindingsIndicesByPath;var index=indicesByPath[path];var bindings=this._bindings;if(index!==undefined)return bindings[index];var paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length;indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(var _i326=nCachedObjects,n=objects.length;_i326!==n;++_i326){var object=objects[_i326];bindingsForPath[_i326]=new PropertyBinding(object,path,parsedPath);}return bindingsForPath;}unsubscribe_(path){// tells the group to forget about a property path and no longer
  // update the array previously obtained with 'subscribe_'
  var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(index!==undefined){var paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path[lastBindingsIndex];indicesByPath[lastBindingsPath]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop();}}}AnimationObjectGroup.prototype.isAnimationObjectGroup=true;class AnimationAction{constructor(mixer,clip){var localRoot=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var blendMode=arguments.length>3&&arguments[3]!==undefined?arguments[3]:clip.blendMode;this._mixer=mixer;this._clip=clip;this._localRoot=localRoot;this.blendMode=blendMode;var tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks);var interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(var _i327=0;_i327!==nTracks;++_i327){var interpolant=tracks[_i327].createInterpolant(null);interpolants[_i327]=interpolant;interpolant.settings=interpolantSettings;}this._interpolantSettings=interpolantSettings;this._interpolants=interpolants;// bound by the mixer
  // inside: PropertyMixer (managed by the mixer)
  this._propertyBindings=new Array(nTracks);this._cacheIndex=null;// for the memory manager
  this._byClipCacheIndex=null;// for the memory manager
  this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=LoopRepeat;this._loopCount=-1;// global mixer time when the action is to be started
  // it's set back to 'null' upon start of the action
  this._startTime=null;// scaled local time of the action
  // gets clamped or wrapped to 0..clip.duration according to loop
  this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;// no. of repetitions when looping
  this.paused=false;// true -> zero effective time scale
  this.enabled=true;// false -> zero effective weight
  this.clampWhenFinished=false;// keep feeding the last frame?
  this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
  this.zeroSlopeAtEnd=true;// clips for start, loop and end
  }// State & Scheduling
  play(){this._mixer._activateAction(this);return this;}stop(){this._mixer._deactivateAction(this);return this.reset();}reset(){this.paused=false;this.enabled=true;this.time=0;// restart clip
  this._loopCount=-1;// forget previous loops
  this._startTime=null;// forget scheduling
  return this.stopFading().stopWarping();}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this);}// return true when play has been called
  isScheduled(){return this._mixer._isActiveAction(this);}startAt(time){this._startTime=time;return this;}setLoop(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this;}// Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight){this.weight=weight;// note: same logic as when updated at runtime
  this._effectiveWeight=this.enabled?weight:0;return this.stopFading();}// return the weight considering fading and .enabled
  getEffectiveWeight(){return this._effectiveWeight;}fadeIn(duration){return this._scheduleFading(duration,0,1);}fadeOut(duration){return this._scheduleFading(duration,1,0);}crossFadeFrom(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){var fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1.0,startEndRatio,duration);this.warp(endStartRatio,1.0,duration);}return this;}crossFadeTo(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp);}stopFading(){var weightInterpolant=this._weightInterpolant;if(weightInterpolant!==null){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(weightInterpolant);}return this;}// Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale){this.timeScale=timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping();}// return the time scale considering warping and .paused
  getEffectiveTimeScale(){return this._effectiveTimeScale;}setDuration(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping();}syncWith(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping();}halt(duration){return this.warp(this._effectiveTimeScale,0,duration);}warp(startTimeScale,endTimeScale,duration){var mixer=this._mixer,now=mixer.time,timeScale=this.timeScale;var interpolant=this._timeScaleInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._timeScaleInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;times[1]=now+duration;values[0]=startTimeScale/timeScale;values[1]=endTimeScale/timeScale;return this;}stopWarping(){var timeScaleInterpolant=this._timeScaleInterpolant;if(timeScaleInterpolant!==null){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(timeScaleInterpolant);}return this;}// Object Accessors
  getMixer(){return this._mixer;}getClip(){return this._clip;}getRoot(){return this._localRoot||this._mixer._root;}// Interna
  _update(time,deltaTime,timeDirection,accuIndex){// called by the mixer
  if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
  this._updateWeight(time);return;}var startTime=this._startTime;if(startTime!==null){// check for scheduled start of action
  var timeRunning=(time-startTime)*timeDirection;if(timeRunning<0||timeDirection===0){return;// yet to come / don't decide when delta = 0
  }// start
  this._startTime=null;// unschedule
  deltaTime=timeDirection*timeRunning;}// apply time scale and advance time
  deltaTime*=this._updateTimeScale(time);var clipTime=this._updateTime(deltaTime);// note: _updateTime may disable the action resulting in
  // an effective weight of 0
  var weight=this._updateWeight(time);if(weight>0){var interpolants=this._interpolants;var propertyMixers=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(var j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulateAdditive(weight);}break;case NormalAnimationBlendMode:default:for(var _j18=0,_m4=interpolants.length;_j18!==_m4;++_j18){interpolants[_j18].evaluate(clipTime);propertyMixers[_j18].accumulate(accuIndex,weight);}}}}_updateWeight(time){var weight=0;if(this.enabled){weight=this.weight;var interpolant=this._weightInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopFading();if(interpolantValue===0){// faded out, disable
  this.enabled=false;}}}}this._effectiveWeight=weight;return weight;}_updateTimeScale(time){var timeScale=0;if(!this.paused){timeScale=this.timeScale;var interpolant=this._timeScaleInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopWarping();if(timeScale===0){// motion has halted, pause
  this.paused=true;}else {// warp done - apply final time scale
  this.timeScale=timeScale;}}}}this._effectiveTimeScale=timeScale;return timeScale;}_updateTime(deltaTime){var duration=this._clip.duration;var loop=this.loop;var time=this.time+deltaTime;var loopCount=this._loopCount;var pingPong=loop===LoopPingPong;if(deltaTime===0){if(loopCount===-1)return time;return pingPong&&(loopCount&1)===1?duration-time:time;}if(loop===LoopOnce){if(loopCount===-1){// just started
  this._loopCount=0;this._setEndings(true,true,false);}handle_stop:{if(time>=duration){time=duration;}else if(time<0){time=0;}else {this.time=time;break handle_stop;}if(this.clampWhenFinished)this.paused=true;else this.enabled=false;this.time=time;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime<0?-1:1});}}else {// repetitive Repeat or PingPong
  if(loopCount===-1){// just started
  if(deltaTime>=0){loopCount=0;this._setEndings(true,this.repetitions===0,pingPong);}else {// when looping in reverse direction, the initial
  // transition through zero counts as a repetition,
  // so leave loopCount at -1
  this._setEndings(this.repetitions===0,true,pingPong);}}if(time>=duration||time<0){// wrap around
  var loopDelta=Math.floor(time/duration);// signed
  time-=duration*loopDelta;loopCount+=Math.abs(loopDelta);var pending=this.repetitions-loopCount;if(pending<=0){// have to stop (switch state, clamp time, fire event)
  if(this.clampWhenFinished)this.paused=true;else this.enabled=false;time=deltaTime>0?duration:0;this.time=time;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime>0?1:-1});}else {// keep running
  if(pending===1){// entering the last round
  var atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong);}else {this._setEndings(false,false,pingPong);}this._loopCount=loopCount;this.time=time;this._mixer.dispatchEvent({type:'loop',action:this,loopDelta:loopDelta});}}else {this.time=time;}if(pingPong&&(loopCount&1)===1){// invert time for the "pong round"
  return duration-time;}}return time;}_setEndings(atStart,atEnd,pingPong){var settings=this._interpolantSettings;if(pingPong){settings.endingStart=ZeroSlopeEnding;settings.endingEnd=ZeroSlopeEnding;}else {// assuming for LoopOnce atStart == atEnd == true
  if(atStart){settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;}else {settings.endingStart=WrapAroundEnding;}if(atEnd){settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;}else {settings.endingEnd=WrapAroundEnding;}}}_scheduleFading(duration,weightNow,weightThen){var mixer=this._mixer,now=mixer.time;var interpolant=this._weightInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._weightInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;values[0]=weightNow;times[1]=now+duration;values[1]=weightThen;return this;}}class AnimationMixer extends EventDispatcher{constructor(root){super();this._root=root;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1.0;}_bindAction(action,prototypeAction){var root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName;var bindingsByName=bindingsByRoot[rootUuid];if(bindingsByName===undefined){bindingsByName={};bindingsByRoot[rootUuid]=bindingsByName;}for(var _i328=0;_i328!==nTracks;++_i328){var track=tracks[_i328],trackName=track.name;var binding=bindingsByName[trackName];if(binding!==undefined){bindings[_i328]=binding;}else {binding=bindings[_i328];if(binding!==undefined){// existing binding, make sure the cache knows
  if(binding._cacheIndex===null){++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);}continue;}var path=prototypeAction&&prototypeAction._propertyBindings[_i328].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);bindings[_i328]=binding;}interpolants[_i328].resultBuffer=binding.buffer;}}_activateAction(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){// this action has been forgotten by the cache, but the user
  // appears to be still using it -> rebind
  var rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid);}var bindings=action._propertyBindings;// increment reference counts / sort out state
  for(var _i329=0,n=bindings.length;_i329!==n;++_i329){var binding=bindings[_i329];if(binding.useCount++===0){this._lendBinding(binding);binding.saveOriginalState();}}this._lendAction(action);}}_deactivateAction(action){if(this._isActiveAction(action)){var bindings=action._propertyBindings;// decrement reference counts / sort out state
  for(var _i330=0,n=bindings.length;_i330!==n;++_i330){var binding=bindings[_i330];if(--binding.useCount===0){binding.restoreOriginalState();this._takeBackBinding(binding);}}this._takeBackAction(action);}}// Memory manager
  _initMemoryManager(){this._actions=[];// 'nActiveActions' followed by inactive ones
  this._nActiveActions=0;this._actionsByClip={};// inside:
  // {
  // 	knownActions: Array< AnimationAction > - used as prototypes
  // 	actionByRoot: AnimationAction - lookup
  // }
  this._bindings=[];// 'nActiveBindings' followed by inactive ones
  this._nActiveBindings=0;this._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >
  this._controlInterpolants=[];// same game as above
  this._nActiveControlInterpolants=0;var scope=this;this.stats={actions:{get total(){return scope._actions.length;},get inUse(){return scope._nActiveActions;}},bindings:{get total(){return scope._bindings.length;},get inUse(){return scope._nActiveBindings;}},controlInterpolants:{get total(){return scope._controlInterpolants.length;},get inUse(){return scope._nActiveControlInterpolants;}}};}// Memory management for AnimationAction objects
  _isActiveAction(action){var index=action._cacheIndex;return index!==null&&index<this._nActiveActions;}_addInactiveAction(action,clipUuid,rootUuid){var actions=this._actions,actionsByClip=this._actionsByClip;var actionsForClip=actionsByClip[clipUuid];if(actionsForClip===undefined){actionsForClip={knownActions:[action],actionByRoot:{}};action._byClipCacheIndex=0;actionsByClip[clipUuid]=actionsForClip;}else {var knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length;knownActions.push(action);}action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action;}_removeInactiveAction(action){var actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();action._cacheIndex=null;var clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;var actionByRoot=actionsForClip.actionByRoot,rootUuid=(action._localRoot||this._root).uuid;delete actionByRoot[rootUuid];if(knownActionsForClip.length===0){delete actionsByClip[clipUuid];}this._removeInactiveBindingsForAction(action);}_removeInactiveBindingsForAction(action){var bindings=action._propertyBindings;for(var _i331=0,n=bindings.length;_i331!==n;++_i331){var binding=bindings[_i331];if(--binding.referenceCount===0){this._removeInactiveBinding(binding);}}}_lendAction(action){// [ active actions |  inactive actions  ]
  // [  active actions >| inactive actions ]
  //                 s        a
  //                  <-swap->
  //                 a        s
  var actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction;}_takeBackAction(action){// [  active actions  | inactive actions ]
  // [ active actions |< inactive actions  ]
  //        a        s
  //         <-swap->
  //        s        a
  var actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction;}// Memory management for PropertyMixer objects
  _addInactiveBinding(binding,rootUuid,trackName){var bindingsByRoot=this._bindingsByRootAndName,bindings=this._bindings;var bindingByName=bindingsByRoot[rootUuid];if(bindingByName===undefined){bindingByName={};bindingsByRoot[rootUuid]=bindingByName;}bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding);}_removeInactiveBinding(binding){var bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex;bindings[cacheIndex]=lastInactiveBinding;bindings.pop();delete bindingByName[trackName];if(Object.keys(bindingByName).length===0){delete bindingsByRoot[rootUuid];}}_lendBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding;}_takeBackBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding;}// Memory management of Interpolants for weight and time scale
  _lendControlInterpolant(){var interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++;var interpolant=interpolants[lastActiveIndex];if(interpolant===undefined){interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);interpolant.__cacheIndex=lastActiveIndex;interpolants[lastActiveIndex]=interpolant;}return interpolant;}_takeBackControlInterpolant(interpolant){var interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant;}// return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(clip,optionalRoot,blendMode){var root=optionalRoot||this._root,rootUuid=root.uuid;var clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip;var clipUuid=clipObject!==null?clipObject.uuid:clip;var actionsForClip=this._actionsByClip[clipUuid];var prototypeAction=null;if(blendMode===undefined){if(clipObject!==null){blendMode=clipObject.blendMode;}else {blendMode=NormalAnimationBlendMode;}}if(actionsForClip!==undefined){var existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==undefined&&existingAction.blendMode===blendMode){return existingAction;}// we know the clip, so we don't have to parse all
  // the bindings again but can just copy
  prototypeAction=actionsForClip.knownActions[0];// also, take the clip from the prototype action
  if(clipObject===null)clipObject=prototypeAction._clip;}// clip must be known when specified via string
  if(clipObject===null)return null;// allocate all resources required to run it
  var newAction=new AnimationAction(this,clipObject,optionalRoot,blendMode);this._bindAction(newAction,prototypeAction);// and make the action known to the memory manager
  this._addInactiveAction(newAction,clipUuid,rootUuid);return newAction;}// get an existing action
  existingAction(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];if(actionsForClip!==undefined){return actionsForClip.actionByRoot[rootUuid]||null;}return null;}// deactivates all previously scheduled actions
  stopAllAction(){var actions=this._actions,nActions=this._nActiveActions;for(var _i332=nActions-1;_i332>=0;--_i332){actions[_i332].stop();}return this;}// advance the time and update apply the animation
  update(deltaTime){deltaTime*=this.timeScale;var actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;// run active actions
  for(var _i333=0;_i333!==nActions;++_i333){var action=actions[_i333];action._update(time,deltaTime,timeDirection,accuIndex);}// update scene graph
  var bindings=this._bindings,nBindings=this._nActiveBindings;for(var _i334=0;_i334!==nBindings;++_i334){bindings[_i334].apply(accuIndex);}return this;}// Allows you to seek to a specific time in an animation.
  setTime(timeInSeconds){this.time=0;// Zero out time attribute for AnimationMixer object;
  for(var _i335=0;_i335<this._actions.length;_i335++){this._actions[_i335].time=0;// Zero out time attribute for all associated AnimationAction objects.
  }return this.update(timeInSeconds);// Update used to set exact time. Returns "this" AnimationMixer object.
  }// return this mixer's root target object
  getRoot(){return this._root;}// free all resources specific to a particular clip
  uncacheClip(clip){var actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==undefined){// note: just calling _removeInactiveAction would mess up the
  // iteration state and also require updating the state we can
  // just throw away
  var actionsToRemove=actionsForClip.knownActions;for(var _i336=0,n=actionsToRemove.length;_i336!==n;++_i336){var action=actionsToRemove[_i336];this._deactivateAction(action);var cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();this._removeInactiveBindingsForAction(action);}delete actionsByClip[clipUuid];}}// free all resources specific to a particular root target object
  uncacheRoot(root){var rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(var clipUuid in actionsByClip){var actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];if(action!==undefined){this._deactivateAction(action);this._removeInactiveAction(action);}}var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==undefined){for(var trackName in bindingByName){var binding=bindingByName[trackName];binding.restoreOriginalState();this._removeInactiveBinding(binding);}}}// remove a targeted clip from the cache
  uncacheAction(clip,optionalRoot){var action=this.existingAction(clip,optionalRoot);if(action!==null){this._deactivateAction(action);this._removeInactiveAction(action);}}}AnimationMixer.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Uniform{constructor(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}clone(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(array,stride){var meshPerAttribute=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;super(array,stride);this.meshPerAttribute=meshPerAttribute;}copy(source){super.copy(source);this.meshPerAttribute=source.meshPerAttribute;return this;}clone(data){var ib=super.clone(data);ib.meshPerAttribute=this.meshPerAttribute;return ib;}toJSON(data){var json=super.toJSON(data);json.isInstancedInterleavedBuffer=true;json.meshPerAttribute=this.meshPerAttribute;return json;}}InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer=true;class GLBufferAttribute{constructor(buffer,type,itemSize,elementSize,count){this.buffer=buffer;this.type=type;this.itemSize=itemSize;this.elementSize=elementSize;this.count=count;this.version=0;}set needsUpdate(value){if(value===true)this.version++;}setBuffer(buffer){this.buffer=buffer;return this;}setType(type,elementSize){this.type=type;this.elementSize=elementSize;return this;}setItemSize(itemSize){this.itemSize=itemSize;return this;}setCount(count){this.count=count;return this;}}GLBufferAttribute.prototype.isGLBufferAttribute=true;var _vector$4=/*@__PURE__*/new Vector2();class Box2{constructor(){var min=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2(+Infinity,+Infinity);var max=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector2(-Infinity,-Infinity);this.min=min;this.max=max;}set(min,max){this.min.copy(min);this.max.copy(max);return this;}setFromPoints(points){this.makeEmpty();for(var _i339=0,il=points.length;_i339<il;_i339++){this.expandByPoint(points[_i339]);}return this;}setFromCenterAndSize(center,size){var halfSize=_vector$4.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}clone(){return new this.constructor().copy(this);}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
  return this.max.x<this.min.x||this.max.y<this.min.y;}getCenter(target){return this.isEmpty()?target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}getSize(target){return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min);}expandByPoint(point){this.min.min(point);this.max.max(point);return this;}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;}getParameter(point,target){// This can potentially have a divide by zero if the box
  // has a size dimension of 0.
  return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));}intersectsBox(box){// using 4 splitting planes to rule out intersections
  return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}distanceToPoint(point){var clampedPoint=_vector$4.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();}intersect(box){this.min.max(box.min);this.max.min(box.max);return this;}union(box){this.min.min(box.min);this.max.max(box.max);return this;}translate(offset){this.min.add(offset);this.max.add(offset);return this;}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}}Box2.prototype.isBox2=true;var _startP=/*@__PURE__*/new Vector3();var _startEnd=/*@__PURE__*/new Vector3();class Line3{constructor(){var start=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var end=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();this.start=start;this.end=end;}set(start,end){this.start.copy(start);this.end.copy(end);return this;}copy(line){this.start.copy(line.start);this.end.copy(line.end);return this;}getCenter(target){return target.addVectors(this.start,this.end).multiplyScalar(0.5);}delta(target){return target.subVectors(this.end,this.start);}distanceSq(){return this.start.distanceToSquared(this.end);}distance(){return this.start.distanceTo(this.end);}at(t,target){return this.delta(target).multiplyScalar(t).add(this.start);}closestPointToPointParameter(point,clampToLine){_startP.subVectors(point,this.start);_startEnd.subVectors(this.end,this.start);var startEnd2=_startEnd.dot(_startEnd);var startEnd_startP=_startEnd.dot(_startP);var t=startEnd_startP/startEnd2;if(clampToLine){t=clamp(t,0,1);}return t;}closestPointToPoint(point,clampToLine,target){var t=this.closestPointToPointParameter(point,clampToLine);return this.delta(target).multiplyScalar(t).add(this.start);}applyMatrix4(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;}equals(line){return line.start.equals(this.start)&&line.end.equals(this.end);}clone(){return new this.constructor().copy(this);}}var _vector$2=/*@__PURE__*/new Vector3();var _boneMatrix=/*@__PURE__*/new Matrix4();var _matrixWorldInv=/*@__PURE__*/new Matrix4();class SkeletonHelper extends LineSegments{constructor(object){var bones=getBoneList(object);var geometry=new BufferGeometry();var vertices=[];var colors=[];var color1=new Color(0,0,1);var color2=new Color(0,1,0);for(var _i341=0;_i341<bones.length;_i341++){var bone=bones[_i341];if(bone.parent&&bone.parent.isBone){vertices.push(0,0,0);vertices.push(0,0,0);colors.push(color1.r,color1.g,color1.b);colors.push(color2.r,color2.g,color2.b);}}geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:true,depthTest:false,depthWrite:false,toneMapped:false,transparent:true});super(geometry,material);this.type='SkeletonHelper';this.isSkeletonHelper=true;this.root=object;this.bones=bones;this.matrix=object.matrixWorld;this.matrixAutoUpdate=false;}updateMatrixWorld(force){var bones=this.bones;var geometry=this.geometry;var position=geometry.getAttribute('position');_matrixWorldInv.copy(this.root.matrixWorld).invert();for(var _i342=0,j=0;_i342<bones.length;_i342++){var bone=bones[_i342];if(bone.parent&&bone.parent.isBone){_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.matrixWorld);_vector$2.setFromMatrixPosition(_boneMatrix);position.setXYZ(j,_vector$2.x,_vector$2.y,_vector$2.z);_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.parent.matrixWorld);_vector$2.setFromMatrixPosition(_boneMatrix);position.setXYZ(j+1,_vector$2.x,_vector$2.y,_vector$2.z);j+=2;}}geometry.getAttribute('position').needsUpdate=true;super.updateMatrixWorld(force);}}function getBoneList(object){var boneList=[];if(object&&object.isBone){boneList.push(object);}for(var _i343=0;_i343<object.children.length;_i343++){boneList.push.apply(boneList,getBoneList(object.children[_i343]));}return boneList;}class GridHelper extends LineSegments{constructor(){var size=arguments.length>0&&arguments[0]!==undefined?arguments[0]:10;var divisions=arguments.length>1&&arguments[1]!==undefined?arguments[1]:10;var color1=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0x444444;var color2=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0x888888;color1=new Color(color1);color2=new Color(color2);var center=divisions/2;var step=size/divisions;var halfSize=size/2;var vertices=[],colors=[];for(var _i345=0,j=0,k=-halfSize;_i345<=divisions;_i345++,k+=step){vertices.push(-halfSize,0,k,halfSize,0,k);vertices.push(k,0,-halfSize,k,0,halfSize);var color=_i345===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}var geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:true,toneMapped:false});super(geometry,material);this.type='GridHelper';}}var _floatView=new Float32Array(1);var _int32View=new Int32Array(_floatView.buffer);class DataUtils{// Converts float32 to float16 (stored as uint16 value).
  static toHalfFloat(val){if(val>65504){console.warn('THREE.DataUtils.toHalfFloat(): value exceeds 65504.');val=65504;// maximum representable value in float16
  }// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
  /* This method is faster than the OpenEXR implementation (very often
  		* used, eg. in Ogre), with the additional benefit of rounding, inspired
  		* by James Tursa?s half-precision code. */_floatView[0]=val;var x=_int32View[0];var bits=x>>16&0x8000;/* Get the sign */var m=x>>12&0x07ff;/* Keep one extra bit for rounding */var e=x>>23&0xff;/* Using int is faster here */ /* If zero, or denormal, or exponent underflows too much for a denormal
  			* half, return signed zero. */if(e<103)return bits;/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */if(e>142){bits|=0x7c00;/* If exponent was 0xff and one mantissa bit was set, it means NaN,
  						* not Inf, so make sure we set one mantissa bit too. */bits|=(e==255?0:1)&&x&0x007fffff;return bits;}/* If exponent underflows but not too much, return a denormal */if(e<113){m|=0x0800;/* Extra rounding may overflow and set mantissa to 0 and exponent
  				* to 1, which is OK. */bits|=(m>>114-e)+(m>>113-e&1);return bits;}bits|=e-112<<10|m>>1;/* Extra rounding. An overflow will set mantissa to 0 and increment
  			* the exponent, which is OK. */bits+=m&1;return bits;}}Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=Object.create(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
  Path.prototype.fromPoints=function(points){console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');return this.setFromPoints(points);};//
  GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};SkeletonHelper.prototype.update=function(){console.error('THREE.SkeletonHelper: update() no longer needs to be called.');};Loader.prototype.extractUrlBase=function(url){console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');return LoaderUtils.extractUrlBase(url);};Loader.Handlers={add:function/* regex, loader */(){console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');},get:function/* file */(){console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');}};Box2.prototype.center=function(optionalTarget){console.warn('THREE.Box2: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};Box2.prototype.empty=function(){console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');return this.isEmpty();};Box2.prototype.isIntersectionBox=function(box){console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Box2.prototype.size=function(optionalTarget){console.warn('THREE.Box2: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);};//
  Box3.prototype.center=function(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};Box3.prototype.empty=function(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();};Box3.prototype.isIntersectionBox=function(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Box3.prototype.isIntersectionSphere=function(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);};Box3.prototype.size=function(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);};//
  Sphere.prototype.empty=function(){console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');return this.isEmpty();};//
  Frustum.prototype.setFromMatrix=function(m){console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');return this.setFromProjectionMatrix(m);};//
  Line3.prototype.center=function(optionalTarget){console.warn('THREE.Line3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};//
  Matrix3.prototype.flattenToArrayOffset=function(array,offset){console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');return this.toArray(array,offset);};Matrix3.prototype.multiplyVector3=function(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);};Matrix3.prototype.multiplyVector3Array=function/* a */(){console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');};Matrix3.prototype.applyToBufferAttribute=function(attribute){console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');return attribute.applyMatrix3(this);};Matrix3.prototype.applyToVector3Array=function/* array, offset, length */(){console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');};Matrix3.prototype.getInverse=function(matrix){console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');return this.copy(matrix).invert();};//
  Matrix4.prototype.extractPosition=function(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);};Matrix4.prototype.flattenToArrayOffset=function(array,offset){console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');return this.toArray(array,offset);};Matrix4.prototype.getPosition=function(){console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return new Vector3().setFromMatrixColumn(this,3);};Matrix4.prototype.setRotationFromQuaternion=function(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);};Matrix4.prototype.multiplyToArray=function(){console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');};Matrix4.prototype.multiplyVector3=function(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4.prototype.multiplyVector4=function(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4.prototype.multiplyVector3Array=function/* a */(){console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');};Matrix4.prototype.rotateAxis=function(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);};Matrix4.prototype.crossVector=function(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);};Matrix4.prototype.translate=function(){console.error('THREE.Matrix4: .translate() has been removed.');};Matrix4.prototype.rotateX=function(){console.error('THREE.Matrix4: .rotateX() has been removed.');};Matrix4.prototype.rotateY=function(){console.error('THREE.Matrix4: .rotateY() has been removed.');};Matrix4.prototype.rotateZ=function(){console.error('THREE.Matrix4: .rotateZ() has been removed.');};Matrix4.prototype.rotateByAxis=function(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');};Matrix4.prototype.applyToBufferAttribute=function(attribute){console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');return attribute.applyMatrix4(this);};Matrix4.prototype.applyToVector3Array=function/* array, offset, length */(){console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');};Matrix4.prototype.makeFrustum=function(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);};Matrix4.prototype.getInverse=function(matrix){console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');return this.copy(matrix).invert();};//
  Plane.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};//
  Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};Quaternion.prototype.inverse=function(){console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');return this.invert();};//
  Ray.prototype.isIntersectionBox=function(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);};Ray.prototype.isIntersectionPlane=function(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);};Ray.prototype.isIntersectionSphere=function(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);};//
  Triangle.prototype.area=function(){console.warn('THREE.Triangle: .area() has been renamed to .getArea().');return this.getArea();};Triangle.prototype.barycoordFromPoint=function(point,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return this.getBarycoord(point,target);};Triangle.prototype.midpoint=function(target){console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');return this.getMidpoint(target);};Triangle.prototypenormal=function(target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return this.getNormal(target);};Triangle.prototype.plane=function(target){console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');return this.getPlane(target);};Triangle.barycoordFromPoint=function(point,a,b,c,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return Triangle.getBarycoord(point,a,b,c,target);};Triangle.normal=function(a,b,c,target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return Triangle.getNormal(a,b,c,target);};//
  Shape.prototype.extractAllPoints=function(divisions){console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');return this.extractPoints(divisions);};Shape.prototype.extrude=function(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);};Shape.prototype.makeGeometry=function(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);};//
  Vector2.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector2.prototype.distanceToManhattan=function(v){console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);};Vector2.prototype.lengthManhattan=function(){console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
  Vector3.prototype.setEulerFromRotationMatrix=function(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');};Vector3.prototype.setEulerFromQuaternion=function(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');};Vector3.prototype.getPositionFromMatrix=function(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);};Vector3.prototype.getScaleFromMatrix=function(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);};Vector3.prototype.getColumnFromMatrix=function(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);};Vector3.prototype.applyProjection=function(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);};Vector3.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector3.prototype.distanceToManhattan=function(v){console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);};Vector3.prototype.lengthManhattan=function(){console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
  Vector4.prototype.fromAttribute=function(attribute,index,offset){console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);};Vector4.prototype.lengthManhattan=function(){console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();};//
  Object3D.prototype.getChildByName=function(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);};Object3D.prototype.renderDepth=function(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');};Object3D.prototype.translate=function(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);};Object3D.prototype.getWorldRotation=function(){console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');};Object3D.prototype.applyMatrix=function(matrix){console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);};Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});Mesh.prototype.setDrawMode=function(){console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');};Object.defineProperties(Mesh.prototype,{drawMode:{get:function(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');return TrianglesDrawMode;},set:function(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');}}});SkinnedMesh.prototype.initBones=function(){console.error('THREE.SkinnedMesh: initBones() has been removed.');};//
  PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn('THREE.PerspectiveCamera.setLens is deprecated. '+'Use .setFocalLength and .filmGauge for a photographic setup.');if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
  Object.defineProperties(Light.prototype,{onlyShadow:{set:function(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
  Object.defineProperties(BufferAttribute.prototype,{length:{get:function(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}},dynamic:{get:function(){console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');return this.usage===DynamicDrawUsage;},set:function/* value */(){console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');this.setUsage(DynamicDrawUsage);}}});BufferAttribute.prototype.setDynamic=function(value){console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;};BufferAttribute.prototype.copyIndicesArray=function/* indices */(){console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');},BufferAttribute.prototype.setArray=function/* array */(){console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');};//
  BufferGeometry.prototype.addIndex=function(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);};BufferGeometry.prototype.addAttribute=function(name,attribute){console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');if(!(attribute&&attribute.isBufferAttribute)&&!(attribute&&attribute.isInterleavedBufferAttribute)){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');return this.setAttribute(name,new BufferAttribute(arguments[1],arguments[2]));}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return this;}return this.setAttribute(name,attribute);};BufferGeometry.prototype.addDrawCall=function(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);};BufferGeometry.prototype.clearDrawCalls=function(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();};BufferGeometry.prototype.computeOffsets=function(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');};BufferGeometry.prototype.removeAttribute=function(name){console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');return this.deleteAttribute(name);};BufferGeometry.prototype.applyMatrix=function(matrix){console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);};Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});InterleavedBuffer.prototype.setDynamic=function(value){console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;};InterleavedBuffer.prototype.setArray=function/* array */(){console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');};//
  ExtrudeGeometry.prototype.getArrays=function(){console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');};ExtrudeGeometry.prototype.addShapeList=function(){console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');};ExtrudeGeometry.prototype.addShape=function(){console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');};//
  Scene.prototype.dispose=function(){console.error('THREE.Scene: .dispose() has been removed.');};//
  Uniform.prototype.onUpdate=function(){console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');return this;};//
  Object.defineProperties(Material.prototype,{wrapAround:{get:function(){console.warn('THREE.Material: .wrapAround has been removed.');},set:function(){console.warn('THREE.Material: .wrapAround has been removed.');}},overdraw:{get:function(){console.warn('THREE.Material: .overdraw has been removed.');},set:function(){console.warn('THREE.Material: .overdraw has been removed.');}},wrapRGB:{get:function(){console.warn('THREE.Material: .wrapRGB has been removed.');return new Color();}},shading:{get:function(){console.error('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');},set:function(value){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=value===FlatShading;}},stencilMask:{get:function(){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');return this.stencilFuncMask;},set:function(value){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');this.stencilFuncMask=value;}},vertexTangents:{get:function(){console.warn('THREE.'+this.type+': .vertexTangents has been removed.');},set:function(){console.warn('THREE.'+this.type+': .vertexTangents has been removed.');}}});Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
  WebGLRenderer.prototype.clearTarget=function(renderTarget,color,depth,stencil){console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};WebGLRenderer.prototype.animate=function(callback){console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');this.setAnimationLoop(callback);};WebGLRenderer.prototype.getCurrentRenderTarget=function(){console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');return this.getRenderTarget();};WebGLRenderer.prototype.getMaxAnisotropy=function(){console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');return this.capabilities.getMaxAnisotropy();};WebGLRenderer.prototype.getPrecision=function(){console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');return this.capabilities.precision;};WebGLRenderer.prototype.resetGLState=function(){console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');return this.state.reset();};WebGLRenderer.prototype.supportsFloatTextures=function(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');};WebGLRenderer.prototype.supportsHalfFloatTextures=function(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');};WebGLRenderer.prototype.supportsStandardDerivatives=function(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');};WebGLRenderer.prototype.supportsCompressedTextureS3TC=function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');};WebGLRenderer.prototype.supportsCompressedTexturePVRTC=function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');};WebGLRenderer.prototype.supportsBlendMinMax=function(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');};WebGLRenderer.prototype.supportsVertexTextures=function(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;};WebGLRenderer.prototype.supportsInstancedArrays=function(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');};WebGLRenderer.prototype.enableScissorTest=function(boolean){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(boolean);};WebGLRenderer.prototype.initMaterial=function(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');};WebGLRenderer.prototype.addPrePlugin=function(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');};WebGLRenderer.prototype.addPostPlugin=function(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');};WebGLRenderer.prototype.updateShadowMap=function(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');};WebGLRenderer.prototype.setFaceCulling=function(){console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');};WebGLRenderer.prototype.allocTextureUnit=function(){console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');};WebGLRenderer.prototype.setTexture=function(){console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');};WebGLRenderer.prototype.setTexture2D=function(){console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');};WebGLRenderer.prototype.setTextureCube=function(){console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');};WebGLRenderer.prototype.getActiveMipMapLevel=function(){console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');return this.getActiveMipmapLevel();};Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function(){return this.shadowMap.type;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function/* value */(){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');}},context:{get:function(){console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');return this.getContext();}},vr:{get:function(){console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');return this.xr;}},gammaInput:{get:function(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');return false;},set:function(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');}},gammaOutput:{get:function(){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');return false;},set:function(value){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');this.outputEncoding=value===true?sRGBEncoding:LinearEncoding;}},toneMappingWhitePoint:{get:function(){console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');return 1.0;},set:function(){console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');}}});Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function/* cullFace */(){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');}},renderReverseSided:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');}},renderSingleSided:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');}}});Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
  Audio.prototype.load=function(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');var scope=this;var audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;};AudioAnalyser.prototype.getData=function(){console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');return this.getFrequencyData();};//
  CubeCamera.prototype.updateCubeMap=function(renderer,scene){console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');return this.update(renderer,scene);};CubeCamera.prototype.clear=function(renderer,color,depth,stencil){console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');return this.renderTarget.clear(renderer,color,depth,stencil);};ImageUtils.crossOrigin=undefined;ImageUtils.loadTexture=function(url,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');var loader=new TextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(url,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadTextureCube=function(urls,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');var loader=new CubeTextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(urls,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadCompressedTexture=function(){console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');};ImageUtils.loadCompressedTextureCube=function(){console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');};//
  if(typeof __THREE_DEVTOOLS__!=='undefined'){/* eslint-disable no-undef */__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{detail:{revision:REVISION}}));/* eslint-enable no-undef */}if(typeof window!=='undefined'){if(window.__THREE__){console.warn('WARNING: Multiple instances of Three.js being imported.');}else {window.__THREE__=REVISION;}}

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  /**
   * Error thrown by View3D
   */
  class View3DError extends Error {
    /**
     * Create new instance of View3DError
     */
    constructor(message, code) {
      super(message);
      Object.setPrototypeOf(this, View3DError.prototype);
      this.name = "View3DError";
      this.code = code;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  /**
   * Error codes of {@link View3DError}
   * @type object
   * @property {number} WRONG_TYPE 0
   * @property {number} ELEMENT_NOT_FOUND 1
   * @property {number} CANVAS_NOT_FOUND 2
   * @property {number} WEBGL_NOT_SUPPORTED 3
   * @property {number} PROVIDE_SRC_FIRST 4
   * @property {number} PROVIDE_WIDTH_OR_HEIGHT 5
   * @property {number} FORMAT_NOT_SUPPORTED 6
   * @property {number} FILE_NOT_SUPPORTED 7
   * @property {number} NOT_INITIALIZED 8
   */
  const ERROR_CODES = {
    WRONG_TYPE: 0,
    ELEMENT_NOT_FOUND: 1,
    CANVAS_NOT_FOUND: 2,
    WEBGL_NOT_SUPPORTED: 3,
    PROVIDE_SRC_FIRST: 4,
    PROVIDE_WIDTH_OR_HEIGHT: 5,
    FORMAT_NOT_SUPPORTED: 6,
    FILE_NOT_SUPPORTED: 7,
    NOT_INITIALIZED: 8
  };
  const MESSAGES = {
    WRONG_TYPE: (val, types) => `${typeof val} is not a ${types.map(type => `"${type}"`).join(" or ")}.`,
    ELEMENT_NOT_FOUND: query => `Element with selector "${query}" not found.`,
    CANVAS_NOT_FOUND: "The canvas element was not found inside the given root element",
    WEBGL_NOT_SUPPORTED: "WebGL is not supported on this browser.",
    PROVIDE_SRC_FIRST: "\"src\" should be provided before initialization",
    PROVIDE_WIDTH_OR_HEIGHT: "Either width or height should be given.",
    FORMAT_NOT_SUPPORTED: format => `Given format "${format}" is not supported or invalid`,
    FILE_NOT_SUPPORTED: src => `Given file "${src}" is not supported.`,
    NOT_INITIALIZED: "View3D is not initialized yet"
  };
  var ERROR = {
    CODES: ERROR_CODES,
    MESSAGES
  };

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  const getNullableElement = (el, parent) => {
    let targetEl = null;

    if (typeof el === "string") {
      const parentEl = parent ? parent : document;
      const queryResult = parentEl.querySelector(el);

      if (!queryResult) {
        throw new View3DError(ERROR.MESSAGES.ELEMENT_NOT_FOUND(el), ERROR.CODES.ELEMENT_NOT_FOUND);
      }

      targetEl = queryResult;
    } else if (el && el.nodeType === Node.ELEMENT_NODE) {
      targetEl = el;
    }

    return targetEl;
  };
  const getElement = (el, parent) => {
    const targetEl = getNullableElement(el, parent);

    if (!targetEl) {
      throw new View3DError(ERROR.MESSAGES.WRONG_TYPE(el, ["HTMLElement", "string"]), ERROR.CODES.WRONG_TYPE);
    }

    return targetEl;
  };
  const findCanvas = (root, selector) => {
    const canvas = root.querySelector(selector);

    if (!canvas) {
      throw new View3DError(ERROR.MESSAGES.CANVAS_NOT_FOUND, ERROR.CODES.CANVAS_NOT_FOUND);
    }

    return canvas;
  };
  const toRadian = x => {
    return x * Math.PI / 180;
  };
  const toDegree = x => {
    return x * 180 / Math.PI;
  };
  const clamp$1 = (x, min, max) => {
    return Math.max(Math.min(x, max), min);
  };

  const mix = (a, b, t) => {
    return a * (1 - t) + b * t;
  };
  const circulate = (val, min, max) => {
    const size = Math.abs(max - min);

    if (val < min) {
      const offset = (min - val) % size;
      val = max - offset;
    } else if (val > max) {
      const offset = (val - max) % size;
      val = min + offset;
    }

    return val;
  }; // eslint-disable-next-line @typescript-eslint/ban-types

  const merge = (target, ...srcs) => {
    srcs.forEach(source => {
      Object.keys(source).forEach(key => {
        const value = source[key];

        if (Array.isArray(target[key]) && Array.isArray(value)) {
          target[key] = [...target[key], ...value];
        } else {
          target[key] = value;
        }
      });
    });
    return target;
  };
  const toPowerOfTwo = val => {
    let result = 1;

    while (result < val) {
      result *= 2;
    }

    return result;
  };

  const getRotationAngle = (center, v1, v2) => {
    const centerToV1 = new Vector2().subVectors(v1, center).normalize();
    const centerToV2 = new Vector2().subVectors(v2, center).normalize(); // Get the rotation angle with the model's NDC coordinates as the center.

    const deg = centerToV2.angle() - centerToV1.angle();
    const compDeg = -Math.sign(deg) * (2 * Math.PI - Math.abs(deg)); // Take the smaller deg

    const rotationAngle = Math.abs(deg) < Math.abs(compDeg) ? deg : compDeg;
    return rotationAngle;
  };
  const getObjectOption = val => typeof val === "object" ? val : {};
  const toBooleanString = val => val ? "true" : "false";
  const getRotatedPosition = (distance, yawDeg, pitchDeg) => {
    const yaw = toRadian(yawDeg);
    const pitch = toRadian(pitchDeg);
    const newPos = new Vector3(0, 0, 0);
    newPos.y = distance * Math.sin(pitch);
    newPos.z = distance * Math.cos(pitch);
    newPos.x = newPos.z * Math.sin(-yaw);
    newPos.z = newPos.z * Math.cos(-yaw);
    return newPos;
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  function __rest(s, e) {
    var t = {};

    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  /*
  Copyright (c) NAVER Corp.
  name: @egjs/component
  license: MIT
  author: NAVER Corp.
  repository: https://github.com/naver/egjs-component
  version: 3.0.2
  */
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function () {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;

    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }

    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

    return ar;
  }

  /*
   * Copyright (c) 2015 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  var isUndefined = function (value) {
    return typeof value === "undefined";
  };

  /**
   * Event class to provide additional properties
   * @ko Component     
   */

  var ComponentEvent =
  /*#__PURE__*/
  function () {
    /**
     * Create a new instance of ComponentEvent.
     * @ko ComponentEvent   .
     * @param eventType The name of the event.<ko> .</ko>
     * @param props An object that contains additional event properties.<ko>   .</ko>
     */
    function ComponentEvent(eventType, props) {
      var e_1, _a;

      this._canceled = false;

      if (props) {
        try {
          for (var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

            this[key] = props[key];
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }

      this.eventType = eventType;
    }
    /**
     * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.
     * @ko  .  {@link ComponentEvent#isCanceled} `true` .
     */


    var __proto = ComponentEvent.prototype;

    __proto.stop = function () {
      this._canceled = true;
    };
    /**
     * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.
     * @ko {@link ComponentEvent#stop}   .
     * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko> {@link ComponentEvent#stop}   .</ko>
     */


    __proto.isCanceled = function () {
      return this._canceled;
    };

    return ComponentEvent;
  }();

  /**
   * A class used to manage events in a component
   * @ko       
   */

  var Component =
  /*#__PURE__*/
  function () {
    /**
     * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}
     */
    function Component() {
      this._eventHandler = {};
    }
    /**
     * Trigger a custom event.
     * @ko   
     * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>     ComponentEvent </ko>
     * @param {any[]} params Event data to be sent when triggering a custom event <ko>     </ko>
     * @return An instance of the component itself<ko>  </ko>
     * @example
     * ```ts
     * import Component, { ComponentEvent } from "@egjs/component";
     *
     * class Some extends Component<{
     *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;
     *   hi: { foo: { a: number; b: boolean } };
     *   someEvent: (foo: number, bar: string) => void;
     *   someOtherEvent: void; // When there's no event argument
     * }> {
     *   some(){
     *     if(this.trigger("beforeHi")){ // When event call to stop return false.
     *       this.trigger("hi");// fire hi event.
     *     }
     *   }
     * }
     *
     * const some = new Some();
     * some.on("beforeHi", e => {
     *   if(condition){
     *     e.stop(); // When event call to stop, `hi` event not call.
     *   }
     *   // `currentTarget` is component instance.
     *   console.log(some === e.currentTarget); // true
     *
     *   typeof e.foo; // number
     *   typeof e.bar; // string
     * });
     * some.on("hi", e => {
     *   typeof e.foo.b; // boolean
     * });
     * // If you want to more know event design. You can see article.
     * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F
     * ```
     */


    var __proto = Component.prototype;

    __proto.trigger = function (event) {
      var params = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        params[_i - 1] = arguments[_i];
      }

      var eventName = event instanceof ComponentEvent ? event.eventType : event;

      var handlers = __spread(this._eventHandler[eventName] || []);

      if (handlers.length <= 0) {
        return this;
      }

      if (event instanceof ComponentEvent) {
        event.currentTarget = this;
        handlers.forEach(function (handler) {
          handler(event);
        });
      } else {
        handlers.forEach(function (handler) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-call
          handler.apply(void 0, __spread(params));
        });
      }

      return this;
    };
    /**
     * Executed event just one time.
     * @ko   .
     * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>     - </ko>
     * @param {function} handlerToAttach The handler function of the event to be attached <ko>   </ko>
     * @return An instance of the component itself<ko>  </ko>
     * @example
     * ```ts
     * import Component, { ComponentEvent } from "@egjs/component";
     *
     * class Some extends Component<{
     *   hi: ComponentEvent;
     * }> {
     *   hi() {
     *     alert("hi");
     *   }
     *   thing() {
     *     this.once("hi", this.hi);
     *   }
     * }
     *
     * var some = new Some();
     * some.thing();
     * some.trigger(new ComponentEvent("hi"));
     * // fire alert("hi");
     * some.trigger(new ComponentEvent("hi"));
     * // Nothing happens
     * ```
     */


    __proto.once = function (eventName, handlerToAttach) {
      var _this = this;

      if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
        var eventHash = eventName;

        for (var key in eventHash) {
          this.once(key, eventHash[key]);
        }

        return this;
      } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
        var listener_1 = function () {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          } // eslint-disable-next-line @typescript-eslint/no-unsafe-call


          handlerToAttach.apply(void 0, __spread(args));

          _this.off(eventName, listener_1);
        };

        this.on(eventName, listener_1);
      }

      return this;
    };
    /**
     * Checks whether an event has been attached to a component.
     * @ko    .
     * @param {string} eventName The name of the event to be attached <ko>    </ko>
     * @return {boolean} Indicates whether the event is attached. <ko>  </ko>
     * @example
     * ```ts
     * import Component from "@egjs/component";
     *
     * class Some extends Component<{
     *   hi: void;
     * }> {
     *   some() {
     *     this.hasOn("hi");// check hi event.
     *   }
     * }
     * ```
     */


    __proto.hasOn = function (eventName) {
      return !!this._eventHandler[eventName];
    };
    /**
     * Attaches an event to a component.
     * @ko   .
     * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>     - </ko>
     * @param {function} handlerToAttach The handler function of the event to be attached <ko>   </ko>
     * @return An instance of a component itself<ko>  </ko>
     * @example
     * ```ts
     * import Component, { ComponentEvent } from "@egjs/component";
     *
     * class Some extends Component<{
     *   hi: void;
     * }> {
     *   hi() {
     *     console.log("hi");
     *   }
     *   some() {
     *     this.on("hi",this.hi); //attach event
     *   }
     * }
     * ```
     */


    __proto.on = function (eventName, handlerToAttach) {
      if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
        var eventHash = eventName;

        for (var name in eventHash) {
          this.on(name, eventHash[name]);
        }

        return this;
      } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
        var handlerList = this._eventHandler[eventName];

        if (isUndefined(handlerList)) {
          this._eventHandler[eventName] = [];
          handlerList = this._eventHandler[eventName];
        }

        handlerList.push(handlerToAttach);
      }

      return this;
    };
    /**
     * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.
     * @ko    .<br/>`eventName`       .<br/>`handlerToAttach`    `eventName`     .
     * @param {string?} eventName The name of the event to be detached <ko>  </ko>
     * @param {function?} handlerToDetach The handler function of the event to be detached <ko>   </ko>
     * @return An instance of a component itself <ko>  </ko>
     * @example
     * ```ts
     * import Component, { ComponentEvent } from "@egjs/component";
     *
     * class Some extends Component<{
     *   hi: void;
     * }> {
     *   hi() {
     *     console.log("hi");
     *   }
     *   some() {
     *     this.off("hi",this.hi); //detach event
     *   }
     * }
     * ```
     */


    __proto.off = function (eventName, handlerToDetach) {
      var e_1, _a; // Detach all event handlers.


      if (isUndefined(eventName)) {
        this._eventHandler = {};
        return this;
      } // Detach all handlers for eventname or detach event handlers by object.


      if (isUndefined(handlerToDetach)) {
        if (typeof eventName === "string") {
          delete this._eventHandler[eventName];
          return this;
        } else {
          var eventHash = eventName;

          for (var name in eventHash) {
            this.off(name, eventHash[name]);
          }

          return this;
        }
      } // Detach single event handler


      var handlerList = this._eventHandler[eventName];

      if (handlerList) {
        var idx = 0;

        try {
          for (var handlerList_1 = __values(handlerList), handlerList_1_1 = handlerList_1.next(); !handlerList_1_1.done; handlerList_1_1 = handlerList_1.next()) {
            var handlerFunction = handlerList_1_1.value;

            if (handlerFunction === handlerToDetach) {
              handlerList.splice(idx, 1);

              if (handlerList.length <= 0) {
                delete this._eventHandler[eventName];
              }

              break;
            }

            idx++;
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (handlerList_1_1 && !handlerList_1_1.done && (_a = handlerList_1.return)) _a.call(handlerList_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }

      return this;
    };
    /**
     * Version info string
     * @ko  
     * @name VERSION
     * @static
     * @example
     * Component.VERSION;  // ex) 3.0.0
     * @memberof Component
     */


    Component.VERSION = "3.0.2";
    return Component;
  }();

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  const AUTO = "auto";
  /**
   * Event type object with event name strings of {@link View3D}
   * @type {object}
   * @property {"ready"} READY {@link /docs/events/ready Ready event}
   * @property {"loadStart"} LOAD_START {@link /docs/events/loadStart Load start event}
   * @property {"load"} LOAD {@link /docs/events/load Load event}
   * @property {"resize"} RESIZE {@link /docs/events/resize Resize event}
   * @property {"beforeRender"} BEFORE_RENDER {@link /docs/events/beforeRender Before render event}
   * @property {"render"} RENDER {@link /docs/events/render Render event}
   * @property {"progress"} PROGRESS {@link /docs/events/progress Progress event}
   * @property {"quickLookTap"} QUICK_LOOK_TAP {@link /docs/events/quickLookTap Quick Look Tap event}
   * @property {"arStart"} AR_START {@link /docs/events/arStart AR start evemt}
   * @property {"arEnd"} AR_END {@link /docs/events/arEnd AR end event}
   * @property {"arModelPlaced"} AR_MODEL_PLACED {@link /docs/events/arModelPlaced AR model placed event}
   * @example
   * ```ts
   * import { EVENTS } from "@egjs/view3d";
   * EVENTS.RESIZE; // "resize"
   * ```
   */

  const EVENTS = {
    READY: "ready",
    LOAD_START: "loadStart",
    LOAD: "load",
    MODEL_CHANGE: "modelChange",
    RESIZE: "resize",
    BEFORE_RENDER: "beforeRender",
    RENDER: "render",
    PROGRESS: "progress",
    QUICK_LOOK_TAP: "quickLookTap",
    AR_START: "arStart",
    AR_END: "arEnd",
    AR_MODEL_PLACED: "arModelPlaced"
  };
  /**
   * Collection of predefined easing functions
   * @type {object}
   * @property {function} SINE_WAVE
   * @property {function} EASE_OUT_CUBIC
   * @property {function} EASE_OUT_BOUNCE
   * @example
   * ```ts
   * import View3D, { EASING } from "@egjs/view3d";
   *
   * new RotateControl({
   *  easing: EASING.EASE_OUT_CUBIC,
   * });
   * ```
   */

  const EASING = {
    SINE_WAVE: x => Math.sin(x * Math.PI * 2),
    EASE_OUT_CUBIC: x => 1 - Math.pow(1 - x, 3),
    EASE_OUT_BOUNCE: x => {
      const n1 = 7.5625;
      const d1 = 2.75;

      if (x < 1 / d1) {
        return n1 * x * x;
      } else if (x < 2 / d1) {
        return n1 * (x -= 1.5 / d1) * x + 0.75;
      } else if (x < 2.5 / d1) {
        return n1 * (x -= 2.25 / d1) * x + 0.9375;
      } else {
        return n1 * (x -= 2.625 / d1) * x + 0.984375;
      }
    }
  };
  const DEFAULT_CLASS = {
    POSTER: "view3d-poster"
  };
  /**
   * Available AR session types
   * @type {object}
   * @property {"WebXR"} WEBXR An AR session based on {@link https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API WebXR Device API}
   * @property {"SceneViewer"} SCENE_VIEWER An AR session based on {@link https://developers.google.com/ar/develop/java/scene-viewer Google SceneViewer}, which is only available in Android
   * @property {"QuickLook"} QUICK_LOOK An AR session based on Apple {@link https://developer.apple.com/augmented-reality/quick-look/ AR Quick Look}, which is only available in iOS
   */

  const AR_SESSION_TYPE = {
    WEBXR: "webAR",
    SCENE_VIEWER: "sceneViewer",
    QUICK_LOOK: "quickLook"
  };
  /**
   * @type {object}
   * @property {"ar_only"} ONLY_AR
   * @property {"3d_only"} ONLY_3D
   * @property {"ar_preferred"} PREFER_AR
   * @property {"3d_preferred"} PREFER_3D
   */

  const SCENE_VIEWER_MODE = {
    ONLY_AR: "ar_only",
    ONLY_3D: "3d_only",
    PREFER_AR: "ar_preferred",
    PREFER_3D: "3d_preferred"
  };
  /**
   * <img src="https://docs-assets.developer.apple.com/published/b122cc68df/10cb0534-e1f6-42ed-aadb-5390c55ad3ff.png" />
   * @see https://developer.apple.com/documentation/arkit/adding_an_apple_pay_button_or_a_custom_action_in_ar_quick_look
   * @property {"plain"} PLAIN
   * @property {"pay"} PAY
   * @property {"buy"} BUY
   * @property {"check-out"} CHECK_OUT
   * @property {"book"} BOOK
   * @property {"donate"} DONATE
   * @property {"subscribe"} SUBSCRIBE
   */

  const QUICK_LOOK_APPLE_PAY_BUTTON_TYPE = {
    PLAIN: "plain",
    PAY: "pay",
    BUY: "buy",
    CHECK_OUT: "check-out",
    BOOK: "book",
    DONATE: "donate",
    SUBSCRIBE: "subscribe"
  };
  /**
   * Available size of the custom banner
   * @type {object}
   * @property {"small"} SMALL 81pt
   * @property {"medium"} MEDIUM 121pt
   * @property {"large"} LARGE 161pt
   */

  const QUICK_LOOK_CUSTOM_BANNER_SIZE = {
    SMALL: "small",
    MEDIUM: "medium",
    LARGE: "large"
  };

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Renderer that renders View3D's Scene
   */

  class Renderer {
    /**
     * Create new Renderer instance
     * @param canvas \<canvas\> element to render 3d model
     */
    constructor(view3D) {
      this._defaultRenderLoop = delta => {
        const view3D = this._view3D;
        const threeRenderer = this._renderer;
        const {
          scene,
          camera,
          control,
          autoPlayer,
          animator
        } = view3D;
        const deltaMiliSec = delta * 1000;
        animator.update(delta);
        control.update(deltaMiliSec);
        autoPlayer.update(deltaMiliSec);
        view3D.trigger(EVENTS.BEFORE_RENDER, {
          type: EVENTS.BEFORE_RENDER,
          target: view3D,
          delta: deltaMiliSec
        });
        camera.updatePosition();
        threeRenderer.autoClear = false;
        threeRenderer.clear();

        if (scene.skybox) {
          scene.skybox.updateCamera();
          threeRenderer.render(scene.skybox.scene, scene.skybox.camera);
        }

        threeRenderer.render(scene.root, camera.threeCamera);
        threeRenderer.autoClear = true;
        view3D.trigger(EVENTS.RENDER, {
          type: EVENTS.RENDER,
          target: view3D,
          delta: deltaMiliSec
        });
      };

      this._view3D = view3D;
      this._canvas = findCanvas(view3D.rootEl, view3D.canvasSelector);
      const renderer = new WebGLRenderer({
        canvas: this._canvas,
        alpha: true,
        antialias: true,
        preserveDrawingBuffer: true
      });
      renderer.toneMapping = LinearToneMapping;
      renderer.toneMappingExposure = view3D.exposure;
      renderer.outputEncoding = sRGBEncoding;
      renderer.setClearColor(0x000000, 0);
      this._renderer = renderer;
      this._clock = new Clock(false);
      this.enableShadow();
    }
    /**
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement HTMLCanvasElement} given when creating View3D instance
     * @type HTMLCanvasElement
     * @readonly
     */


    get canvas() {
      return this._canvas;
    }
    /**
     * Current {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext WebGLRenderingContext}
     * @type WebGLRenderingContext
     * @readonly
     */


    get context() {
      return this._renderer.context;
    }
    /**
     * Three.js {@link https://threejs.org/docs/#api/en/renderers/WebGLRenderer WebGLRenderer} instance
     * @type THREE.WebGLRenderer
     * @readonly
     */


    get threeRenderer() {
      return this._renderer;
    }
    /**
     * Default render loop of View3D
     * @type {function}
     * @readonly
     */


    get defaultRenderLoop() {
      return this._defaultRenderLoop;
    }
    /**
     * The width and height of the renderer's output canvas
     * @type {object}
     * @param {number} width Width of the canvas
     * @param {number} height Height of the canvas
     * @readonly
     */


    get size() {
      const canvasSize = this._renderer.getSize(new Vector2());

      return {
        width: canvasSize.width,
        height: canvasSize.y
      };
    }
    /**
     * Resize the renderer based on current canvas width / height
     * @returns {void}
     */


    resize() {
      const renderer = this._renderer;
      const canvas = this._canvas;
      if (renderer.xr.isPresenting) return;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight, false);
    }

    setAnimationLoop(callback) {
      this._clock.start();

      this._renderer.setAnimationLoop((timestamp, frame) => {
        const delta = this._clock.getDelta();

        callback(delta, frame);
      });
    }

    stopAnimationLoop() {
      this._clock.stop(); // See https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setAnimationLoop


      this._renderer.setAnimationLoop(null);
    }
    /**
     * Enable shadow map
     */


    enableShadow() {
      const threeRenderer = this._renderer;
      threeRenderer.shadowMap.enabled = true;
      threeRenderer.shadowMap.type = PCFSoftShadowMap;
    }
    /**
     * Disable shadow map
     */


    disableShadow() {
      const threeRenderer = this._renderer;
      threeRenderer.shadowMap.enabled = false;
    }

  }

  // http://en.wikipedia.org/wiki/RGBE_image_format

  class RGBELoader extends DataTextureLoader {
    constructor(manager) {
      super(manager);
      this.type = HalfFloatType;
    } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html


    parse(buffer) {
      var
      /* return codes for rgbe routines */
      //RGBE_RETURN_SUCCESS = 0,
      RGBE_RETURN_FAILURE = -1,

      /* default error routine.  change this to change error handling */
      rgbe_read_error = 1,
          rgbe_write_error = 2,
          rgbe_format_error = 3,
          rgbe_memory_error = 4,
          rgbe_error = function (rgbe_error_code, msg) {
        switch (rgbe_error_code) {
          case rgbe_read_error:
            console.error('THREE.RGBELoader Read Error: ' + (msg || ''));
            break;

          case rgbe_write_error:
            console.error('THREE.RGBELoader Write Error: ' + (msg || ''));
            break;

          case rgbe_format_error:
            console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));
            break;

          default:
          case rgbe_memory_error:
            console.error('THREE.RGBELoader: Error: ' + (msg || ''));
        }

        return RGBE_RETURN_FAILURE;
      },

      /* offsets to red, green, and blue components in a data (float) pixel */
      //RGBE_DATA_RED = 0,
      //RGBE_DATA_GREEN = 1,
      //RGBE_DATA_BLUE = 2,

      /* number of floats per pixel, use 4 since stored in rgba image format */
      //RGBE_DATA_SIZE = 4,

      /* flags indicating which fields in an rgbe_header_info are valid */
      RGBE_VALID_PROGRAMTYPE = 1,
          RGBE_VALID_FORMAT = 2,
          RGBE_VALID_DIMENSIONS = 4,
          NEWLINE = '\n',
          fgets = function (buffer, lineLimit, consume) {
        var chunkSize = 128;
        lineLimit = !lineLimit ? 1024 : lineLimit;
        var p = buffer.pos,
            i = -1,
            len = 0,
            s = '',
            chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));

        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {
          s += chunk;
          len += chunk.length;
          p += chunkSize;
          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
        }

        if (-1 < i) {
          /*for (i=l-1; i>=0; i--) {
          	byteCode = m.charCodeAt(i);
          	if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
          	else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
          	if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
          }*/
          if (false !== consume) buffer.pos += len + i + 1;
          return s + chunk.slice(0, i);
        }

        return false;
      },

      /* minimal header reading.  modify if you want to parse more information */
      RGBE_ReadHeader = function (buffer) {
        // regexes to parse header info fields
        var magic_token_re = /^#\?(\S+)/,
            gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
            exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
            format_re = /^\s*FORMAT=(\S+)\s*$/,
            dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
            // RGBE format header struct
        header = {
          valid: 0,

          /* indicate which fields are valid */
          string: '',

          /* the actual header string */
          comments: '',

          /* comments found in header */
          programtype: 'RGBE',

          /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
          format: '',

          /* RGBE format, default 32-bit_rle_rgbe */
          gamma: 1.0,

          /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
          exposure: 1.0,

          /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
          width: 0,
          height: 0
          /* image dimensions, width/height */

        };
        var line, match;

        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {
          return rgbe_error(rgbe_read_error, 'no header found');
        }
        /* if you want to require the magic token then uncomment the next line */


        if (!(match = line.match(magic_token_re))) {
          return rgbe_error(rgbe_format_error, 'bad initial token');
        }

        header.valid |= RGBE_VALID_PROGRAMTYPE;
        header.programtype = match[1];
        header.string += line + '\n';

        while (true) {
          line = fgets(buffer);
          if (false === line) break;
          header.string += line + '\n';

          if ('#' === line.charAt(0)) {
            header.comments += line + '\n';
            continue; // comment line
          }

          if (match = line.match(gamma_re)) {
            header.gamma = parseFloat(match[1], 10);
          }

          if (match = line.match(exposure_re)) {
            header.exposure = parseFloat(match[1], 10);
          }

          if (match = line.match(format_re)) {
            header.valid |= RGBE_VALID_FORMAT;
            header.format = match[1]; //'32-bit_rle_rgbe';
          }

          if (match = line.match(dimensions_re)) {
            header.valid |= RGBE_VALID_DIMENSIONS;
            header.height = parseInt(match[1], 10);
            header.width = parseInt(match[2], 10);
          }

          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
        }

        if (!(header.valid & RGBE_VALID_FORMAT)) {
          return rgbe_error(rgbe_format_error, 'missing format specifier');
        }

        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
          return rgbe_error(rgbe_format_error, 'missing image size specifier');
        }

        return header;
      },
          RGBE_ReadPixels_RLE = function (buffer, w, h) {
        var scanline_width = w;

        if ( // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded
        2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {
          // return the flat buffer
          return new Uint8Array(buffer);
        }

        if (scanline_width !== (buffer[2] << 8 | buffer[3])) {
          return rgbe_error(rgbe_format_error, 'wrong scanline width');
        }

        var data_rgba = new Uint8Array(4 * w * h);

        if (!data_rgba.length) {
          return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');
        }

        var offset = 0,
            pos = 0;
        var ptr_end = 4 * scanline_width;
        var rgbeStart = new Uint8Array(4);
        var scanline_buffer = new Uint8Array(ptr_end);
        var num_scanlines = h; // read in each successive scanline

        while (num_scanlines > 0 && pos < buffer.byteLength) {
          if (pos + 4 > buffer.byteLength) {
            return rgbe_error(rgbe_read_error);
          }

          rgbeStart[0] = buffer[pos++];
          rgbeStart[1] = buffer[pos++];
          rgbeStart[2] = buffer[pos++];
          rgbeStart[3] = buffer[pos++];

          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');
          } // read each of the four channels for the scanline into the buffer
          // first red, then green, then blue, then exponent


          var ptr = 0,
              count = void 0;

          while (ptr < ptr_end && pos < buffer.byteLength) {
            count = buffer[pos++];
            var isEncodedRun = count > 128;
            if (isEncodedRun) count -= 128;

            if (0 === count || ptr + count > ptr_end) {
              return rgbe_error(rgbe_format_error, 'bad scanline data');
            }

            if (isEncodedRun) {
              // a (encoded) run of the same value
              var byteValue = buffer[pos++];

              for (var i = 0; i < count; i++) {
                scanline_buffer[ptr++] = byteValue;
              } //ptr += count;

            } else {
              // a literal-run
              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
              ptr += count;
              pos += count;
            }
          } // now convert data from buffer into rgba
          // first red, then green, then blue, then exponent (alpha)


          var l = scanline_width; //scanline_buffer.byteLength;

          for (var _i = 0; _i < l; _i++) {
            var off = 0;
            data_rgba[offset] = scanline_buffer[_i + off];
            off += scanline_width; //1;

            data_rgba[offset + 1] = scanline_buffer[_i + off];
            off += scanline_width; //1;

            data_rgba[offset + 2] = scanline_buffer[_i + off];
            off += scanline_width; //1;

            data_rgba[offset + 3] = scanline_buffer[_i + off];
            offset += 4;
          }

          num_scanlines--;
        }

        return data_rgba;
      };

      var RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {
        var e = sourceArray[sourceOffset + 3];
        var scale = Math.pow(2.0, e - 128.0) / 255.0;
        destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
        destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
        destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      };

      var RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {
        var e = sourceArray[sourceOffset + 3];
        var scale = Math.pow(2.0, e - 128.0) / 255.0; // clamping to 65504, the maximum representable value in float16

        destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
        destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
        destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      };

      var byteArray = new Uint8Array(buffer);
      byteArray.pos = 0;
      var rgbe_header_info = RGBE_ReadHeader(byteArray);

      if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
        var w = rgbe_header_info.width,
            h = rgbe_header_info.height,
            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);

        if (RGBE_RETURN_FAILURE !== image_rgba_data) {
          var data, format, type;
          var numElements;

          switch (this.type) {
            case UnsignedByteType:
              data = image_rgba_data;
              format = RGBEFormat; // handled as THREE.RGBAFormat in shaders

              type = UnsignedByteType;
              break;

            case FloatType:
              numElements = image_rgba_data.length / 4;
              var floatArray = new Float32Array(numElements * 3);

              for (var j = 0; j < numElements; j++) {
                RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);
              }

              data = floatArray;
              format = RGBFormat;
              type = FloatType;
              break;

            case HalfFloatType:
              numElements = image_rgba_data.length / 4;
              var halfArray = new Uint16Array(numElements * 3);

              for (var _j = 0; _j < numElements; _j++) {
                RGBEByteToRGBHalf(image_rgba_data, _j * 4, halfArray, _j * 3);
              }

              data = halfArray;
              format = RGBFormat;
              type = HalfFloatType;
              break;

            default:
              console.error('THREE.RGBELoader: unsupported type: ', this.type);
              break;
          }

          return {
            width: w,
            height: h,
            data: data,
            header: rgbe_header_info.string,
            gamma: rgbe_header_info.gamma,
            exposure: rgbe_header_info.exposure,
            format: format,
            type: type
          };
        }
      }

      return null;
    }

    setDataType(value) {
      this.type = value;
      return this;
    }

    load(url, onLoad, onProgress, onError) {
      function onLoadCallback(texture, texData) {
        switch (texture.type) {
          case UnsignedByteType:
            texture.encoding = RGBEEncoding;
            texture.minFilter = NearestFilter;
            texture.magFilter = NearestFilter;
            texture.generateMipmaps = false;
            texture.flipY = true;
            break;

          case FloatType:
            texture.encoding = LinearEncoding;
            texture.minFilter = LinearFilter;
            texture.magFilter = LinearFilter;
            texture.generateMipmaps = false;
            texture.flipY = true;
            break;

          case HalfFloatType:
            texture.encoding = LinearEncoding;
            texture.minFilter = LinearFilter;
            texture.magFilter = LinearFilter;
            texture.generateMipmaps = false;
            texture.flipY = true;
            break;
        }

        if (onLoad) onLoad(texture, texData);
      }

      return super.load(url, onLoadCallback, onProgress, onError);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Texture loader
   */

  class TextureLoader$1 {
    /**
     * Create new TextureLoader instance
     * @param renderer {@link Renderer} instance of View3D
     */
    constructor(renderer) {
      this._renderer = renderer;
    }
    /**
     * Create new {@link https://threejs.org/docs/index.html#api/en/textures/Texture Texture} with given url
     * Texture's {@link https://threejs.org/docs/index.html#api/en/textures/Texture.flipY flipY} property is `true` by Three.js's policy, so be careful when using it as a map texture.
     * @param url url to fetch image
     */


    load(url) {
      return new Promise((resolve, reject) => {
        const loader = new TextureLoader();
        loader.load(url, resolve, undefined, reject);
      });
    }
    /**
     * Create new {@link https://threejs.org/docs/#api/en/renderers/WebGLCubeRenderTarget WebGLCubeRenderTarget} with given equirectangular image url
     * Be sure that equirectangular image has height of power of 2, as it will be resized if it isn't
     * @param url url to fetch equirectangular image
     * @returns WebGLCubeRenderTarget created
     */


    loadEquirectagularTexture(url) {
      return new Promise((resolve, reject) => {
        const loader = new TextureLoader();
        loader.load(url, texture => {
          texture.mapping = EquirectangularReflectionMapping;
          resolve(texture);
        }, undefined, reject);
      });
    }
    /**
     * Create new {@link https://threejs.org/docs/#api/en/textures/CubeTexture CubeTexture} with given cubemap image urls
     * Image order should be: px, nx, py, ny, pz, nz
     * @param urls cubemap image urls
     * @returns CubeTexture created
     */


    loadCubeTexture(urls) {
      return new Promise((resolve, reject) => {
        const loader = new CubeTextureLoader();
        loader.load(urls, resolve, undefined, reject);
      });
    }
    /**
     * Create new texture with given HDR(RGBE) image url
     * @param url image url
     */


    loadHDRTexture(url) {
      return new Promise((resolve, reject) => {
        const loader = new RGBELoader();
        loader.setCrossOrigin("anonymous");
        loader.load(url, texture => {
          texture.mapping = EquirectangularReflectionMapping;
          resolve(texture);
        }, undefined, reject);
      });
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  // Constants that used internally
  // Texture map names that used in THREE#MeshStandardMaterial
  const STANDARD_MAPS = ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "envMap", "lightMap", "map", "metalnessMap", "normalMap", "roughnessMap"];
  const CONTROL_EVENTS = {
    HOLD: "hold",
    RELEASE: "release",
    ENABLE: "enable",
    DISABLE: "disable"
  };
  var GESTURE;

  (function (GESTURE) {
    GESTURE[GESTURE["NONE"] = 0] = "NONE";
    GESTURE[GESTURE["ONE_FINGER_HORIZONTAL"] = 1] = "ONE_FINGER_HORIZONTAL";
    GESTURE[GESTURE["ONE_FINGER_VERTICAL"] = 2] = "ONE_FINGER_VERTICAL";
    GESTURE[GESTURE["ONE_FINGER"] = 3] = "ONE_FINGER";
    GESTURE[GESTURE["TWO_FINGER_HORIZONTAL"] = 4] = "TWO_FINGER_HORIZONTAL";
    GESTURE[GESTURE["TWO_FINGER_VERTICAL"] = 8] = "TWO_FINGER_VERTICAL";
    GESTURE[GESTURE["TWO_FINGER"] = 12] = "TWO_FINGER";
    GESTURE[GESTURE["PINCH"] = 16] = "PINCH";
  })(GESTURE || (GESTURE = {}));

  const CUSTOM_TEXTURE_LOD_EXTENSION = "EXT_View3D_texture_LOD";

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  // Browser related constants
  const IS_IOS = () => /iPad|iPhone|iPod/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  const IS_ANDROID = () => /android/i.test(navigator.userAgent);
  const EVENTS$1 = {
    MOUSE_DOWN: "mousedown",
    MOUSE_MOVE: "mousemove",
    MOUSE_UP: "mouseup",
    TOUCH_START: "touchstart",
    TOUCH_MOVE: "touchmove",
    TOUCH_END: "touchend",
    WHEEL: "wheel",
    RESIZE: "resize",
    CONTEXT_MENU: "contextmenu",
    MOUSE_ENTER: "mouseenter",
    MOUSE_LEAVE: "mouseleave",
    LOAD: "load",
    ERROR: "error"
  };
  const CURSOR = {
    GRAB: "grab",
    GRABBING: "grabbing",
    NONE: ""
  }; // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

  var MOUSE_BUTTON;

  (function (MOUSE_BUTTON) {
    MOUSE_BUTTON[MOUSE_BUTTON["LEFT"] = 0] = "LEFT";
    MOUSE_BUTTON[MOUSE_BUTTON["MIDDLE"] = 1] = "MIDDLE";
    MOUSE_BUTTON[MOUSE_BUTTON["RIGHT"] = 2] = "RIGHT";
  })(MOUSE_BUTTON || (MOUSE_BUTTON = {}));

  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Helper class to easily add shadow plane under your 3D model
   */

  class ShadowPlane {
    /**
     * Create new shadow plane
     * @param {object} options Options
     * @param {number} [options.opacity=0.3] Opacity of the shadow.
     * @param {number} [options.hardness=6] Hardness of the shadow. Should be integer greater than 0, and lower the softer the shadow is.
     * @param {number} [options.yaw=0] Y-axis rotation of the light that casts shadow.
     * @param {number} [options.pitch=0] X-axis rotation of the light that casts shadow.
     */
    constructor(view3D, {
      opacity = 0.3,
      hardness = 6,
      yaw = 0,
      pitch = 0
    } = {}) {
      this._hardness = hardness;
      this._yaw = yaw;
      this._pitch = pitch;
      this._geometry = new PlaneGeometry(2, 2);
      this._material = new ShadowMaterial({
        opacity,
        fog: false
      });
      this._mesh = new Mesh(this._geometry, this._material);
      this._light = new DirectionalLight();
      this._baseLightPos = new Vector3();
      this._modelRadius = 0;
      const mesh = this._mesh;
      mesh.rotateX(-Math.PI / 2);
      mesh.scale.setScalar(Math.pow(2, 32) - 1);
      mesh.receiveShadow = true;
      mesh.castShadow = false;
      mesh.name = "ShadowPlane-Mesh";
      const light = this._light;
      light.intensity = 0;
      light.target = mesh;
      light.castShadow = true;
      light.name = "ShadowPlane-Light";
      const maxTexSize = view3D.renderer.threeRenderer.capabilities.maxTextureSize;
      this._maxHardness = Math.round(Math.log(maxTexSize) / Math.log(2));

      this._updateSoftnessLevel();
    }
    /**
     * Shadow plane mesh
     * @type {THREE.Mesh}
     * @readonly
     */


    get mesh() {
      return this._mesh;
    }
    /**
     * Shadow light
     * @type {THREE.DirectionalLight}
     * @readonly
     */


    get light() {
      return this._light;
    }
    /**
     * Shadow opacity, value can be between 0(invisible) and 1(solid)
     * @type {number}
     * @default 0.3
     */


    get opacity() {
      return this._material.opacity;
    }
    /**
     * Hardness of the shadow. Should be integer greater than 0, and lower the softer the shadow is.
     * @type {number}
     * @default 6
     */


    get hardness() {
      return this._hardness;
    }
    /**
     * Y-axis rotation of the shadow.
     * @type {number}
     * @default 0
     */


    get yaw() {
      return this._yaw;
    }
    /**
     * X-axis rotation of the shadow.
     * @type {number}
     * @default 0
     */


    get pitch() {
      return this._pitch;
    }

    get radius() {
      return this._light.shadow.radius;
    }

    set opacity(val) {
      this._material.opacity = val;
    }

    set hardness(val) {
      this._hardness = Math.min(val, this._maxHardness);

      this._updateSoftnessLevel();
    }

    set radius(val) {
      this._light.shadow.radius = val;
      this._light.shadow.needsUpdate = true;
    }

    update(model) {
      this._updatePlane(model);

      this._updateLightPosition(model);

      this.updateShadow();
    }

    updateShadow(worldScale = 1) {
      const light = this._light;
      const scale = 1.5;
      const shadowCam = light.shadow.camera;
      const radius = this._modelRadius;
      light.position.copy(this._baseLightPos.clone().multiplyScalar(worldScale));
      const camSize = scale * worldScale * radius;
      shadowCam.near = 0;
      shadowCam.far = MAX_SAFE_INTEGER;
      shadowCam.left = -camSize;
      shadowCam.right = camSize;
      shadowCam.top = camSize;
      shadowCam.bottom = -camSize;
      shadowCam.updateProjectionMatrix();
    }

    _updateSoftnessLevel() {
      var _a;

      const light = this._light;
      const hardness = clamp$1(Math.floor(this._hardness), 1, this._maxHardness);
      const shadowSize = Math.pow(2, Math.floor(hardness));
      light.shadow.mapSize.set(shadowSize, shadowSize);
      (_a = light.shadow.map) === null || _a === void 0 ? void 0 : _a.dispose();
      light.shadow.map = null;
    }

    _updatePlane(model) {
      const mesh = this._mesh;
      const modelBbox = model.bbox;
      const boxPoints = [modelBbox.min.x, modelBbox.min.z, modelBbox.max.x, modelBbox.max.z].map(val => Math.abs(val));
      const maxXZ = Math.max(...boxPoints);
      mesh.scale.setScalar(100 * maxXZ);
    }

    _updateLightPosition(model) {
      const yaw = this._yaw;
      const pitch = this._pitch;
      const boundingSphere = model.bbox.getBoundingSphere(new Sphere());
      const radius = boundingSphere.radius; // Added AR hover height(0.1) as offset

      const newPosition = getRotatedPosition(2 * radius + 0.1, yaw, 90 - pitch);

      this._baseLightPos.copy(newPosition);

      this._modelRadius = radius;
    }

  }

  class LightProbeGenerator {
    // https://www.ppsloan.org/publications/StupidSH36.pdf
    static fromCubeTexture(cubeTexture) {
      var totalWeight = 0;
      var coord = new Vector3();
      var dir = new Vector3();
      var color = new Color();
      var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      var sh = new SphericalHarmonics3();
      var shCoefficients = sh.coefficients;

      for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
        var image = cubeTexture.image[faceIndex];
        var width = image.width;
        var height = image.height;
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        var imageData = context.getImageData(0, 0, width, height);
        var data = imageData.data;
        var imageWidth = imageData.width; // assumed to be square

        var pixelSize = 2 / imageWidth;

        for (var i = 0, il = data.length; i < il; i += 4) {
          // RGBA assumed
          // pixel color
          color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space

          convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube

          var pixelIndex = i / 4;
          var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;
          var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;

          switch (faceIndex) {
            case 0:
              coord.set(-1, row, -col);
              break;

            case 1:
              coord.set(1, row, col);
              break;

            case 2:
              coord.set(-col, 1, -row);
              break;

            case 3:
              coord.set(-col, -1, row);
              break;

            case 4:
              coord.set(-col, row, 1);
              break;

            case 5:
              coord.set(col, row, -1);
              break;
          } // weight assigned to this pixel


          var lengthSq = coord.lengthSq();
          var weight = 4 / (Math.sqrt(lengthSq) * lengthSq);
          totalWeight += weight; // direction vector to this pixel

          dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir

          SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate

          for (var j = 0; j < 9; j++) {
            shCoefficients[j].x += shBasis[j] * color.r * weight;
            shCoefficients[j].y += shBasis[j] * color.g * weight;
            shCoefficients[j].z += shBasis[j] * color.b * weight;
          }
        }
      } // normalize


      var norm = 4 * Math.PI / totalWeight;

      for (var _j = 0; _j < 9; _j++) {
        shCoefficients[_j].x *= norm;
        shCoefficients[_j].y *= norm;
        shCoefficients[_j].z *= norm;
      }

      return new LightProbe(sh);
    }

    static fromCubeRenderTarget(renderer, cubeRenderTarget) {
      // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works
      var totalWeight = 0;
      var coord = new Vector3();
      var dir = new Vector3();
      var color = new Color();
      var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      var sh = new SphericalHarmonics3();
      var shCoefficients = sh.coefficients;

      for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
        var imageWidth = cubeRenderTarget.width; // assumed to be square

        var data = new Uint8Array(imageWidth * imageWidth * 4);
        renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);
        var pixelSize = 2 / imageWidth;

        for (var i = 0, il = data.length; i < il; i += 4) {
          // RGBA assumed
          // pixel color
          color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space

          convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube

          var pixelIndex = i / 4;
          var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;
          var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;

          switch (faceIndex) {
            case 0:
              coord.set(1, row, -col);
              break;

            case 1:
              coord.set(-1, row, col);
              break;

            case 2:
              coord.set(col, 1, -row);
              break;

            case 3:
              coord.set(col, -1, row);
              break;

            case 4:
              coord.set(col, row, 1);
              break;

            case 5:
              coord.set(-col, row, -1);
              break;
          } // weight assigned to this pixel


          var lengthSq = coord.lengthSq();
          var weight = 4 / (Math.sqrt(lengthSq) * lengthSq);
          totalWeight += weight; // direction vector to this pixel

          dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir

          SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate

          for (var j = 0; j < 9; j++) {
            shCoefficients[j].x += shBasis[j] * color.r * weight;
            shCoefficients[j].y += shBasis[j] * color.g * weight;
            shCoefficients[j].z += shBasis[j] * color.b * weight;
          }
        }
      } // normalize


      var norm = 4 * Math.PI / totalWeight;

      for (var _j2 = 0; _j2 < 9; _j2++) {
        shCoefficients[_j2].x *= norm;
        shCoefficients[_j2].y *= norm;
        shCoefficients[_j2].z *= norm;
      }

      return new LightProbe(sh);
    }

  }

  function convertColorToLinear(color, encoding) {
    switch (encoding) {
      case sRGBEncoding:
        color.convertSRGBToLinear();
        break;

      case LinearEncoding:
        break;

      default:
        console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');
        break;
    }

    return color;
  }

  /**
   * Skybox that can renders background in a different scene.
   */

  class Skybox {
    /** */
    constructor(view3D) {
      this._view3D = view3D;
      this._scene = new Scene();
      this._camera = new PerspectiveCamera();
    }

    get scene() {
      return this._scene;
    }

    get camera() {
      return this._camera;
    }
    /**
     * Destroy skybox and release all memories
     */


    destroy() {
      this._disposeOldSkybox();
    }
    /**
     * Update current skybox camera to match main camera & apply rotation
     */


    updateCamera() {
      const view3D = this._view3D;
      const bgCam = this._camera;
      const camera = view3D.camera;
      const pivot = camera.currentPose.pivot;
      bgCam.copy(camera.threeCamera);
      bgCam.lookAt(pivot);
      bgCam.updateProjectionMatrix();
    }
    /**
     * Create blurred cubemap texture of the given texture and use that as the skybox
     * @param {THREE.Texture} texture Equirect texture
     * @returns {this}
     */


    useBlurredHDR(texture) {
      this._disposeOldSkybox();

      const threeRenderer = this._view3D.renderer.threeRenderer;
      const bgScene = new Scene();
      bgScene.background = texture; // To prevent exposure applied twice

      const origExposure = threeRenderer.toneMappingExposure;
      threeRenderer.toneMappingExposure = 1;
      const cubeRenderTarget = new WebGLCubeRenderTarget(256, {
        encoding: sRGBEncoding,
        format: RGBAFormat
      });
      const cubeCamera = new CubeCamera(0.1, 1000, cubeRenderTarget);
      cubeCamera.update(threeRenderer, bgScene);
      const lightProbe = LightProbeGenerator.fromCubeRenderTarget(threeRenderer, cubeRenderTarget);
      const skyboxMat = new MeshStandardMaterial({
        side: BackSide
      });
      const geometry = new IcosahedronGeometry(1, 4);
      const skyboxScene = new Scene();
      const skyboxMesh = new Mesh(geometry, skyboxMat);
      const normals = geometry.getAttribute("normal");

      for (let i = 0; i < normals.count; i++) {
        normals.setXYZ(i, -normals.getX(i), -normals.getY(i), -normals.getZ(i));
      }

      skyboxScene.add(skyboxMesh);
      skyboxScene.add(lightProbe);
      cubeCamera.update(threeRenderer, skyboxScene);
      threeRenderer.toneMappingExposure = origExposure;
      this._scene.background = cubeRenderTarget.texture;
      return this;
    }
    /**
     * Use the given texture as a skybox scene background
     * @param {THREE.Texture} texture A texture that compatible for scene background
     * @returns {this}
     */


    useTexture(texture) {
      this._scene.background = texture;
      return this;
    }
    /**
     * Use the given color as a skybox scene background
     * @param {number | string} color A hexadecimal number or string that represents color
     * @returns {this}
     */


    useColor(color) {
      this._scene.background = new Color(color);
      return this;
    }

    _disposeOldSkybox() {
      const skyboxTexture = this._scene.background;
      if (!skyboxTexture) return;
      skyboxTexture.dispose();
      this._scene.background = null;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Scene that View3D will render.
   * All model datas including Mesh, Lights, etc. will be included on this
   */

  class Scene$1 {
    /**
     * Create new Scene instance
     * @param {View3D} view3D An instance of View3D
     */
    constructor(view3D) {
      this._view3D = view3D;
      this._root = new Scene();
      this._skybox = null;
      this._userObjects = new Group();
      this._envObjects = new Group();
      this._fixedObjects = new Group();
      this._shadowPlane = new ShadowPlane(view3D, getObjectOption(view3D.shadow));
      const root = this._root;
      const userObjects = this._userObjects;
      const envObjects = this._envObjects;
      const fixedObjects = this._fixedObjects;
      const shadowPlane = this._shadowPlane;
      userObjects.name = "userObjects";
      envObjects.name = "envObjects";
      fixedObjects.name = "fixedObjects";
      root.add(userObjects, envObjects, fixedObjects);

      if (view3D.shadow) {
        fixedObjects.add(shadowPlane.mesh, shadowPlane.light);
      }
    }
    /**
     * Root {@link https://threejs.org/docs/#api/en/scenes/Scene THREE.Scene} object
     * @readonly
     */


    get root() {
      return this._root;
    }
    /**
     * Skybox object for rendering background
     * @type {Skybox}
     * @readonly
     */


    get skybox() {
      return this._skybox;
    }
    /**
     * Shadow plane & light
     * @type {ShadowPlane}
     * @readonly
     */


    get shadowPlane() {
      return this._shadowPlane;
    }
    /**
     * Group that contains volatile user objects
     * @readonly
     */


    get userObjects() {
      return this._userObjects;
    }
    /**
     * Group that contains non-volatile user objects
     * @readonly
     */


    get envObjects() {
      return this._envObjects;
    }
    /**
     * Group that contains objects that View3D manages
     * @readonly
     */


    get fixedObjects() {
      return this._fixedObjects;
    }
    /**
     * Reset scene to initial state
     * @param {object} options Options
     * @param {boolean} [options.volatileOnly=true] Remove only volatile objects
     * @returns {void}
     */


    reset({
      volatileOnly = true
    } = {}) {
      this._removeChildsOf(this._userObjects);

      if (!volatileOnly) {
        this._removeChildsOf(this._envObjects);
      }
    }
    /**
     * Add new Three.js {@link https://threejs.org/docs/#api/en/core/Object3D Object3D} into the scene
     * @param object {@link https://threejs.org/docs/#api/en/core/Object3D THREE.Object3D}s to add
     * @param volatile If set to true, objects will be removed after displaying another 3D model
     * @returns {void}
     */


    add(object, volatile = true) {
      const objRoot = volatile ? this._userObjects : this._envObjects;
      const objects = Array.isArray(object) ? object : [object];
      objRoot.add(...objects);
    }
    /**
     * Remove Three.js {@link https://threejs.org/docs/#api/en/core/Object3D Object3D} into the scene
     * @param object {@link https://threejs.org/docs/#api/en/core/Object3D THREE.Object3D}s to add
     * @returns {void}
     */


    remove(object) {
      const objects = Array.isArray(object) ? object : [object];

      this._userObjects.remove(...objects);

      this._envObjects.remove(...objects);
    }
    /**
     * Set background of the scene.
     * @param background A color / image url to set as background
     * @returns {Promise<void>}
     */


    setBackground(background) {
      return __awaiter(this, void 0, void 0, function* () {
        const view3D = this._view3D;
        const skybox = new Skybox(view3D);
        this._skybox = skybox;

        if (typeof background === "number" || background.charAt(0) === "#") {
          skybox.useColor(background);
        } else {
          const textureLoader = new TextureLoader$1(this._view3D.renderer);
          const texture = yield textureLoader.load(background);
          texture.encoding = sRGBEncoding;
          skybox.useTexture(texture);
        }
      });
    }
    /**
     * Set scene's skybox, which both affects background & envmap
     * @param url An URL to equirectangular image
     * @returns {Promise<void>}
     */


    setSkybox(url) {
      var _a;

      return __awaiter(this, void 0, void 0, function* () {
        const root = this._root;
        const view3D = this._view3D; // Destroy previous skybox

        (_a = this._skybox) === null || _a === void 0 ? void 0 : _a.destroy();

        if (url) {
          const textureLoader = new TextureLoader$1(view3D.renderer);
          const texture = yield textureLoader.loadHDRTexture(url);
          const skybox = new Skybox(view3D);

          if (view3D.skyboxBlur) {
            skybox.useBlurredHDR(texture);
          } else {
            skybox.useTexture(texture);
          }

          this._skybox = skybox;
          root.environment = texture;
        } else {
          this._skybox = null;
          root.environment = null;
        }
      });
    }
    /**
     * Set scene's environment map that affects all physical materials in the scene
     * @param url An URL to equirectangular image
     * @returns {void}
     */


    setEnvMap(url) {
      return __awaiter(this, void 0, void 0, function* () {
        if (url) {
          const textureLoader = new TextureLoader$1(this._view3D.renderer);
          const texture = yield textureLoader.loadHDRTexture(url);
          this._root.environment = texture;
        } else {
          this._root.environment = null;
        }
      });
    }

    _removeChildsOf(obj) {
      obj.traverse(child => {
        if (child.isMesh) {
          const mesh = child; // Release geometry & material memory

          mesh.geometry.dispose();
          const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
          materials.forEach(mat => {
            STANDARD_MAPS.forEach(map => {
              if (mat[map]) {
                mat[map].dispose();
              }
            });
          });
        }
      });

      while (obj.children.length > 0) {
        obj.remove(obj.children[0]);
      }
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Data class of camera's pose
   */

  class Pose {
    /**
     * Create new instance of pose
     * @param {number} yaw yaw
     * @param {number} pitch pitch
     * @param {number} zoom zoom
     * @param {number[]} pivot pivot
     * @example
     * ```ts
     * import { THREE, Pose } from "@egjs/view3d";
     *
     * const pose = new Pose(180, 45, 150, [5, -1, 3]);
     * ```
     */
    constructor(yaw, pitch, zoom, pivot = [0, 0, 0]) {
      this.yaw = yaw;
      this.pitch = pitch;
      this.zoom = zoom;
      this.pivot = new Vector3().fromArray(pivot);
    }
    /**
     * Clone this pose
     * @returns Cloned pose
     */


    clone() {
      return new Pose(this.yaw, this.pitch, this.zoom, this.pivot.toArray());
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  const EASING$1 = EASING.EASE_OUT_CUBIC;
  const ANIMATION_DURATION = 300;
  const ANIMATION_LOOP = false;
  const ANIMATION_RANGE = {
    min: 0,
    max: 1
  }; // Camera

  const FOV = 45;
  const CAMERA_POSE = new Pose(0, 15, 0, [0, 0, 0]);
  const INFINITE_RANGE = {
    min: -Infinity,
    max: Infinity
  };
  const PITCH_RANGE = {
    min: -89.9,
    max: 89.9
  };
  const AR_OVERLAY_CLASS = "view3d-ar-overlay";
  const DRACO_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/1.4.1/";
  const KTX_TRANSCODER_URL = "https://unpkg.com/three@0.134.0/examples/js/libs/basis/";
  const AR_PRIORITY = [AR_SESSION_TYPE.WEBXR, AR_SESSION_TYPE.SCENE_VIEWER, AR_SESSION_TYPE.QUICK_LOOK];

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  class Motion {
    constructor({
      duration = ANIMATION_DURATION,
      loop = ANIMATION_LOOP,
      range = ANIMATION_RANGE,
      easing = EASING$1
    } = {}) {
      this._duration = duration;
      this._loop = loop;
      this._range = range;
      this._easing = easing;
      this._activated = false;
      this.reset(0);
    }

    get val() {
      return this._val;
    }

    get start() {
      return this._start;
    }

    get end() {
      return this._end;
    }

    get progress() {
      return this._progress;
    }

    get duration() {
      return this._duration;
    }

    get loop() {
      return this._loop;
    }

    get range() {
      return this._range;
    }

    get easing() {
      return this._easing;
    }

    set duration(val) {
      this._duration = val;
    }

    set loop(val) {
      this._loop = val;
    }

    set range(val) {
      this._range = val;
    }

    set easing(val) {
      this._easing = val;
    }
    /**
     * Update motion and progress it by given deltaTime
     * @param deltaTime number of milisec to update motion
     * @returns Difference(delta) of the value from the last update.
     */


    update(deltaTime) {
      if (!this._activated) return 0;
      const start = this._start;
      const end = this._end;
      const duration = this._duration;
      const prev = this._val;
      const loop = this._loop;
      const nextProgress = this._progress + deltaTime / duration;
      this._progress = loop ? circulate(nextProgress, 0, 1) : clamp$1(nextProgress, 0, 1);

      const easedProgress = this._easing(this._progress);

      this._val = mix(start, end, easedProgress);

      if (!loop && this._progress >= 1) {
        this._activated = false;
      }

      return this._val - prev;
    }

    reset(defaultVal) {
      const range = this._range;
      const val = clamp$1(defaultVal, range.min, range.max);
      this._start = val;
      this._end = val;
      this._val = val;
      this._progress = 0;
      this._activated = false;
    }

    setEndDelta(delta) {
      const range = this._range;
      this._start = this._val;
      this._end = clamp$1(this._end + delta, range.min, range.max);
      this._progress = 0;
      this._activated = true;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Control that animates model without user input
   */

  class AnimationControl {
    /**
     * Create new instance of AnimationControl
     * @param from Start pose
     * @param to End pose
     * @param {object} options Options
     * @param {number} [options.duration=500] Animation duration
     * @param {function} [options.easing=(x: number) => 1 - Math.pow(1 - x, 3)] Animation easing function
     */
    constructor(view3D, from, to, {
      duration = ANIMATION_DURATION,
      easing = EASING$1
    } = {}) {
      this._enabled = false;
      this._finishCallbacks = [];
      this._view3D = view3D;
      from = from.clone();
      to = to.clone();
      from.yaw = circulate(from.yaw, 0, 360);
      to.yaw = circulate(to.yaw, 0, 360); // Take the smaller degree

      if (Math.abs(to.yaw - from.yaw) > 180) {
        to.yaw = to.yaw < from.yaw ? to.yaw + 360 : to.yaw - 360;
      }

      this._motion = new Motion({
        duration,
        range: ANIMATION_RANGE,
        easing
      });
      this._from = from;
      this._to = to;
    }

    get element() {
      return null;
    }
    /**
     * Whether this control is enabled or not
     * @readonly
     */


    get enabled() {
      return this._enabled;
    }
    /**
     * Duration of the animation
     */


    get duration() {
      return this._motion.duration;
    }
    /**
     * Easing function of the animation
     */


    get easing() {
      return this._motion.easing;
    }

    set duration(val) {
      this._motion.duration = val;
    }

    set easing(val) {
      this._motion.easing = val;
    }
    /**
     * Destroy the instance and remove all event listeners attached
     * This also will reset CSS cursor to intial
     * @returns {void}
     */


    destroy() {
      this.disable();
    }
    /**
     * Update control by given deltaTime
     * @param deltaTime Number of milisec to update
     * @returns {void}
     */


    update(deltaTime) {
      if (!this._enabled) return;
      const camera = this._view3D.camera;
      const from = this._from;
      const to = this._to;
      const motion = this._motion;
      motion.update(deltaTime); // Progress that easing is applied

      const progress = motion.val;
      camera.yaw = mix(from.yaw, to.yaw, progress);
      camera.pitch = mix(from.pitch, to.pitch, progress);
      camera.zoom = mix(from.zoom, to.zoom, progress);
      camera.pivot = from.pivot.clone().lerp(to.pivot, progress);

      if (progress >= 1) {
        this.disable();

        this._finishCallbacks.forEach(callback => callback());
      }
    }
    /**
     * Enable this input and add event listeners
     * @returns {void}
     */


    enable() {
      if (this._enabled) return;
      this._enabled = true;

      this._motion.reset(0);

      this._motion.setEndDelta(1);
    }
    /**
     * Disable this input and remove all event handlers
     * @returns {void}
     */


    disable() {
      if (!this._enabled) return;
      this._enabled = false;
    }
    /**
     * Add callback which is called when animation is finished
     * @param callback Callback that will be called when animation finishes
     * @returns {void}
     */


    onFinished(callback) {
      this._finishCallbacks.push(callback);
    }
    /**
     * Remove all onFinished callbacks
     * @returns {void}
     */


    clearFinished() {
      this._finishCallbacks = [];
    }
    /* eslint-disable @typescript-eslint/no-unused-vars */


    resize(size) {// DO NOTHING
    }

    sync() {// Do nothing
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Camera that renders the scene of View3D
   */

  class Camera$1 {
    /**
     * Create new Camera instance
     * @param canvas \<canvas\> element to render 3d model
     */
    constructor(view3D) {
      this._distance = 0;
      this._baseFov = 45;
      this._defaultPose = CAMERA_POSE;
      this._currentPose = this._defaultPose.clone();
      this._view3D = view3D;
      this._threeCamera = new PerspectiveCamera();
      this._maxTanHalfHFov = 0;
      this._defaultPose = new Pose(view3D.yaw, view3D.pitch, 0);
      this._currentPose = this._defaultPose.clone();
    }
    /**
     * Three.js {@link https://threejs.org/docs/#api/en/cameras/PerspectiveCamera PerspectiveCamera} instance
     * @readonly
     * @type THREE.PerspectiveCamera
     */


    get threeCamera() {
      return this._threeCamera;
    }
    /**
     * Camera's default pose(yaw, pitch, zoom, pivot)
     * This will be new currentPose when {@link Camera#reset reset()} is called
     * @readonly
     * @type {Pose}
     */


    get defaultPose() {
      return this._defaultPose;
    }
    /**
     * Camera's current pose value
     * @readonly
     * @type {Pose}
     */


    get currentPose() {
      return this._currentPose.clone();
    }
    /**
     * Camera's current yaw
     * {@link Camera#updatePosition} should be called after changing this value, and normally it is called every frame.
     * @type {number}
     */


    get yaw() {
      return this._currentPose.yaw;
    }
    /**
     * Camera's current pitch
     * {@link Camera#updatePosition} should be called after changing this value, and normally it is called every frame.
     * @type {number}
     */


    get pitch() {
      return this._currentPose.pitch;
    }
    /**
     * Camera's current zoom value
     * {@link Camera#updatePosition} should be called after changing this value, and normally it is called every frame.
     * @type {number}
     */


    get zoom() {
      return this._currentPose.zoom;
    }
    /**
     * Camera's default fov value.
     * This will be automatically chosen when `view3D.fov` is "auto", otherwise it is equal to `view3D.fov`
     * @type {number}
     */


    get baseFov() {
      return this._baseFov;
    }
    /**
     * Current pivot point of camera rotation
     * @readonly
     * @type THREE.Vector3
     * @see {@link https://threejs.org/docs/#api/en/math/Vector3 THREE#Vector3}
     */


    get pivot() {
      return this._currentPose.pivot;
    }
    /**
     * Camera's focus of view value (vertical)
     * @type number
     * @see {@link https://threejs.org/docs/#api/en/cameras/PerspectiveCamera.fov THREE#PerspectiveCamera}
     */


    get fov() {
      return this._threeCamera.fov;
    }

    get pose() {
      return this._currentPose;
    }
    /**
     * Camera's frustum width
     * @type number
     */


    get renderWidth() {
      return this.renderHeight * this._threeCamera.aspect;
    }
    /**
     * Camera's frustum height
     * @type number
     */


    get renderHeight() {
      return 2 * this._distance * Math.tan(toRadian(this._threeCamera.getEffectiveFOV() / 2));
    }

    set yaw(val) {
      this._currentPose.yaw = val;
    }

    set pitch(val) {
      this._currentPose.pitch = val;
    }

    set zoom(val) {
      this._currentPose.zoom = val;
    }

    set pivot(val) {
      this._currentPose.pivot = val;
    }
    /**
     * Reset camera to default pose
     * @param duration Duration of the reset animation
     * @param easing Easing function for the reset animation
     * @returns Promise that resolves when the animation finishes
     */


    reset(duration = 0, easing = EASING$1) {
      return __awaiter(this, void 0, void 0, function* () {
        const view3D = this._view3D;
        const control = view3D.control;
        const currentPose = this._currentPose;
        const defaultPose = this._defaultPose;

        if (duration <= 0) {
          // Reset camera immediately
          this._currentPose = defaultPose.clone();
          control.sync();
          return Promise.resolve();
        } else {
          // Play the animation
          const resetControl = new AnimationControl(view3D, currentPose, defaultPose);
          resetControl.duration = duration;
          resetControl.easing = easing;
          resetControl.enable();
          control.disable();

          const updateResetControl = evt => {
            resetControl.update(evt.delta);
          };

          view3D.on(EVENTS.BEFORE_RENDER, updateResetControl);
          return new Promise(resolve => {
            resetControl.onFinished(() => {
              control.sync();
              control.enable();
              view3D.off(EVENTS.BEFORE_RENDER, updateResetControl);
              resolve();
            });
          });
        }
      });
    }
    /**
     * Update camera's aspect to given size
     * @param {object} size New size to apply
     * @param {number} [size.width] New width
     * @param {number} [size.height] New height
     * @returns {void}
     */


    resize({
      width,
      height
    }) {
      const cam = this._threeCamera;
      const aspect = width / height;
      const fov = this._view3D.fov;
      cam.aspect = aspect;

      if (fov === AUTO) {
        this._applyEffectiveFov(FOV);
      } else {
        this._baseFov = fov;
      }
    }
    /**
     * Fit camera frame to the given model
     */


    fit(model, center) {
      const view3D = this._view3D;
      const camera = this._threeCamera;
      const control = view3D.control;
      const defaultPose = this._defaultPose;
      const bbox = model.bbox;
      const fov = view3D.fov;
      const hfov = fov === AUTO ? FOV : fov;
      const modelCenter = Array.isArray(center) ? new Vector3().fromArray(center) : bbox.getCenter(new Vector3());
      const maxDistToCenterSquared = model.reduceVertices((dist, vertice) => {
        return Math.max(dist, vertice.distanceToSquared(modelCenter));
      }, 0);
      const maxDistToCenter = Math.sqrt(maxDistToCenterSquared);
      const effectiveCamDist = maxDistToCenter / Math.sin(toRadian(hfov / 2));
      const maxTanHalfHFov = model.reduceVertices((res, vertex) => {
        const distToCenter = new Vector3().subVectors(vertex, modelCenter);
        const radiusXZ = Math.sqrt(distToCenter.x * distToCenter.x + distToCenter.z * distToCenter.z);
        return Math.max(res, radiusXZ / (effectiveCamDist - Math.abs(distToCenter.y)));
      }, 0);

      if (fov === AUTO) {
        // Cache for later use in resize
        this._maxTanHalfHFov = maxTanHalfHFov;

        this._applyEffectiveFov(hfov);
      } else {
        this._maxTanHalfHFov = fov;
      }

      defaultPose.pivot = modelCenter.clone();
      this._distance = effectiveCamDist;
      camera.near = (effectiveCamDist - maxDistToCenter) * 0.1;
      camera.far = (effectiveCamDist + maxDistToCenter) * 10;
      control.zoom.updateRange();
    }
    /**
     * Update camera position base on the {@link Camera#currentPose currentPose} value
     * @returns {void}
     */


    updatePosition() {
      const {
        control
      } = this._view3D;
      const threeCamera = this._threeCamera;
      const currentPose = this._currentPose;
      const distance = this._distance;
      const baseFov = this._baseFov;
      const zoomRange = control.zoom.range; // Clamp current pose

      currentPose.yaw = circulate(currentPose.yaw, 0, 360);
      currentPose.pitch = clamp$1(currentPose.pitch, PITCH_RANGE.min, PITCH_RANGE.max);
      currentPose.zoom = -(clamp$1(baseFov - currentPose.zoom, zoomRange.min, zoomRange.max) - baseFov);
      const newCamPos = getRotatedPosition(distance, currentPose.yaw, currentPose.pitch);
      const fov = baseFov - currentPose.zoom;
      newCamPos.add(currentPose.pivot);
      threeCamera.fov = fov;
      threeCamera.position.copy(newCamPos);
      threeCamera.lookAt(currentPose.pivot);
      threeCamera.updateProjectionMatrix();
    }

    _applyEffectiveFov(fov) {
      const camera = this._threeCamera;
      const tanHalfHFov = Math.tan(toRadian(fov / 2));
      const tanHalfVFov = tanHalfHFov * Math.max(1, this._maxTanHalfHFov / tanHalfHFov / camera.aspect);
      this._baseFov = toDegree(2 * Math.atan(tanHalfVFov));
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  class AutoResizer {
    constructor(view3d) {
      this._onResize = () => {
        this._view3d.resize();
      };

      this._view3d = view3d;
      this._enabled = false;
      this._resizeObserver = null;
    }

    get enabled() {
      return this._enabled;
    }

    enable() {
      const view3d = this._view3d;

      if (this._enabled) {
        this.disable();
      }

      if (view3d.useResizeObserver && !!window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(this._onResize); // This will automatically call `resize` for the first time

        resizeObserver.observe(view3d.renderer.canvas);
        this._resizeObserver = resizeObserver;
      } else {
        view3d.resize();
        window.addEventListener(EVENTS$1.RESIZE, this._onResize);
      }

      this._enabled = true;
      return this;
    }

    disable() {
      if (!this._enabled) return this;
      const resizeObserver = this._resizeObserver;

      if (resizeObserver) {
        resizeObserver.disconnect();
        this._resizeObserver = null;
      } else {
        window.removeEventListener(EVENTS$1.RESIZE, this._onResize);
      }

      this._enabled = false;
      return this;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Component that manages animations of the 3D Model
   */

  class ModelAnimator {
    /**
     * Create new ModelAnimator instance
     */
    constructor(view3D) {
      this._view3D = view3D;
      this._mixer = new AnimationMixer(view3D.scene.userObjects);
      this._clips = [];
      this._actions = [];
      this._activeAnimationIdx = -1;
      this._fadePromises = [];
    }
    /**
     * Three.js {@link https://threejs.org/docs/#api/en/animation/AnimationClip AnimationClip}s that stored
     * @type THREE.AnimationClip
     * @readonly
     */


    get clips() {
      return this._clips;
    }
    /**
     * {@link https://threejs.org/docs/#api/en/animation/AnimationMixer THREE.AnimationMixer} instance
     * @type THREE.AnimationMixer
     * @readonly
     */


    get mixer() {
      return this._mixer;
    }
    /**
     * An array of active {@link https://threejs.org/docs/#api/en/animation/AnimationAction AnimationAction}s
     * @type THREE.AnimationAction
     * @readonly
     */


    get actions() {
      return this._actions;
    }
    /**
     * Current length of animations
     * @type {number}
     * @readonly
     */


    get animationCount() {
      return this._clips.length;
    }
    /**
     * Infomation of the animation currently playing, `null` if there're no animation or stopped.
     * @see {@link https://threejs.org/docs/#api/en/animation/AnimationClip AnimationClip}
     * @type {THREE.AnimationClip | null}
     */


    get activeAnimation() {
      var _a;

      return (_a = this._clips[this._activeAnimationIdx]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * An index of the animation currently playing.
     * @type {number}
     * @readonly
     */


    get activeAnimationIndex() {
      return this._activeAnimationIdx;
    }
    /**
     * An boolean value indicating whether the animations are paused
     * @type {boolean}
     * @readonly
     */


    get paused() {
      return this._mixer.timeScale === 0;
    }
    /**
     * Store the given clips
     * @param clips Three.js {@link https://threejs.org/docs/#api/en/animation/AnimationClip AnimationClip}s of the model
     * @returns {void}
     * @example
     * ```ts
     * // After loading model
     * view3d.animator.setClips(model.animations);
     * ```
     */


    setClips(clips) {
      const mixer = this._mixer;
      this._clips = clips;
      this._actions = clips.map(clip => {
        const action = mixer.clipAction(clip);
        action.setEffectiveWeight(0);
        return action;
      });
    }
    /**
     * Play one of the model's animation
     * @param {number} index Index of the animation to play
     * @returns {void}
     */


    play(index) {
      const action = this._actions[index];
      if (!action) return;
      this.stop(); // Stop all previous actions

      this._restoreTimeScale();

      action.setEffectiveTimeScale(1);
      action.setEffectiveWeight(1);
      action.play();
      this._activeAnimationIdx = index;

      this._flushFadePromises();
    }
    /**
     * Crossfade animation from one to another
     * @param {number} index Index of the animation to crossfade to
     * @param {number} duration Duration of the crossfade animation, in milisec
     * @returns {Promise<boolean>} A promise that resolves boolean value that indicates whether the crossfade is fullfilled without any inference
     */


    crossFade(index, duration, {
      synchronize = false
    } = {}) {
      var _a;

      return __awaiter(this, void 0, void 0, function* () {
        const view3D = this._view3D;
        const mixer = this._mixer;
        const actions = this._actions;
        const activeAnimationIdx = this._activeAnimationIdx;
        const endAction = actions[index];
        const startAction = (_a = actions[activeAnimationIdx]) !== null && _a !== void 0 ? _a : endAction; // eslint-disable-next-line @typescript-eslint/naming-convention

        const EVT_LOOP = "loop";

        this._restoreTimeScale();

        const doCrossfade = () => {
          endAction.enabled = true;
          endAction.setEffectiveTimeScale(1);
          endAction.setEffectiveWeight(1);
          endAction.time = 0;
          endAction.play();
          startAction.crossFadeTo(endAction, duration / 1000, true);
          this._activeAnimationIdx = index;
        };

        if (synchronize) {
          const onLoop = evt => {
            if (evt.action === startAction) {
              mixer.removeEventListener(EVT_LOOP, onLoop);
              doCrossfade();
            }
          };

          mixer.addEventListener(EVT_LOOP, onLoop);
        } else {
          doCrossfade();
        }

        this._flushFadePromises();

        const fadePromise = new Promise(resolve => {
          const onFrame = () => {
            if (endAction.getEffectiveWeight() < 1) return;
            view3D.off(EVENTS.BEFORE_RENDER, onFrame);
            resolve(true);
          };

          view3D.on(EVENTS.BEFORE_RENDER, onFrame);

          this._fadePromises.push({
            listener: onFrame,
            resolve
          });
        });
        return fadePromise;
      });
    }
    /**
     * Fadeout active animation, and restore to the default pose
     * @param {number} duration Duration of the crossfade animation, in milisec
     * @returns {Promise<boolean>} A promise that resolves boolean value that indicates whether the fadeout is fullfilled without any inference
     */


    fadeOut(duration) {
      return __awaiter(this, void 0, void 0, function* () {
        const view3D = this._view3D;
        const actions = this._actions;
        const activeAction = actions[this._activeAnimationIdx];
        if (!activeAction) return false;

        this._flushFadePromises();

        this._restoreTimeScale();

        activeAction.fadeOut(duration / 1000);
        this._activeAnimationIdx = -1;
        const fadePromise = new Promise(resolve => {
          const onFrame = () => {
            if (activeAction.getEffectiveWeight() > 0) return;
            view3D.off(EVENTS.BEFORE_RENDER, onFrame);
            resolve(true);
          };

          view3D.on(EVENTS.BEFORE_RENDER, onFrame);

          this._fadePromises.push({
            listener: onFrame,
            resolve
          });
        });
        return fadePromise;
      });
    }
    /**
     * Pause all animations
     * If you want to stop animation completely, you should call {@link ModelAnimator#stop stop} instead
     * You should call {@link ModelAnimator#resume resume} to resume animation
     * @returns {void}
     */


    pause() {
      this._mixer.timeScale = 0;
    }
    /**
     * Resume all animations
     * This will play animation from the point when the animation is paused
     * @returns {void}
     */


    resume() {
      this._restoreTimeScale();
    }
    /**
     * Fully stops one of the model's animation
     * @returns {void}
     */


    stop() {
      this._actions.forEach(action => {
        action.stop();
        action.setEffectiveWeight(0);
      });

      this._activeAnimationIdx = -1;

      this._flushFadePromises();
    }
    /**
     * Update animations
     * @param {number} delta number of seconds to play animations attached
     * @internal
     * @returns {void}
     */


    update(delta) {
      this._mixer.update(delta);
    }
    /**
     * Reset the instance and remove all cached animation clips attached to it
     * @returns {void}
     */


    reset() {
      const mixer = this._mixer;
      this.stop();
      mixer.uncacheRoot(mixer.getRoot());
      this._clips = [];
      this._actions = [];
    }

    _restoreTimeScale() {
      this._mixer.timeScale = 1;
    }

    _flushFadePromises() {
      const view3D = this._view3D;
      const fadePromises = this._fadePromises;
      fadePromises.forEach(({
        resolve,
        listener
      }) => {
        resolve(false);
        view3D.off(EVENTS.BEFORE_RENDER, listener);
      });
      this._fadePromises = [];
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Fires for every animation frame when animation is active.
   * @type object
   * @property {object} event Event object.
   * @property {number} [event.progress] Current animation progress value.
   * Value is ranged from 0(start) to 1(end).
   * @property {number} [event.easedProgress] Eased progress value.
   * @event Animation#progress
   */

  /**
   * Fires for every animation loop except for the last loop
   * This will be triggered only when repeat > 0
   * @type object
   * @property {object} event Event object.
   * @property {number} [event.progress] Current animation progress value.
   * Value is ranged from 0(start) to 1(end).
   * @property {number} [event.easedProgress] Eased progress value.
   * @property {number} [event.loopIndex] Index of the current loop.
   * @event Animation#loop
   */

  /**
   * Fires when animation ends.
   * @type void
   * @event Animation#finish
   */

  /**
   * Self-running animation
   */

  class Animation extends Component {
    /**
     * Create new instance of the Animation
     * @param {object} [options={}] Options
     */
    constructor({
      context = window,
      repeat = 0,
      duration = ANIMATION_DURATION,
      easing = EASING.EASE_OUT_CUBIC
    } = {}) {
      super();

      this._loop = () => {
        const delta = this._getDeltaTime();

        const duration = this._duration;
        const repeat = this._repeat;
        const prevTime = this._time;
        const time = prevTime + delta;
        const loopIncrease = Math.floor(time / duration);
        this._time = this._loopCount >= repeat ? clamp$1(time, 0, duration) : circulate(time, 0, duration);
        const progress = this._time / duration;
        const progressEvent = {
          progress,
          easedProgress: this._easing(progress)
        };
        this.trigger("progress", progressEvent);

        for (let loopIdx = 0; loopIdx < loopIncrease; loopIdx++) {
          this._loopCount++;

          if (this._loopCount > repeat) {
            this.trigger("finish");
            this.stop();
            return;
          } else {
            this.trigger("loop", Object.assign(Object.assign({}, progressEvent), {
              loopIndex: this._loopCount
            }));
          }
        }

        this._rafId = this._ctx.requestAnimationFrame(this._loop);
      }; // Options


      this._repeat = repeat;
      this._duration = duration;
      this._easing = easing; // Internal States

      this._ctx = context;
      this._rafId = -1;
      this._time = 0;
      this._clock = 0;
      this._loopCount = 0;
    }

    start() {
      if (this._rafId >= 0) return; // This guarantees "progress" event with progress = 0 on first start

      this._updateClock();

      this._loop();
    }

    stop() {
      if (this._rafId < 0) return;
      this._time = 0;
      this._loopCount = 0;

      this._stopLoop();
    }

    pause() {
      if (this._rafId < 0) return;

      this._stopLoop();
    }

    _stopLoop() {
      this._ctx.cancelAnimationFrame(this._rafId);

      this._rafId = -1;
    }

    _getDeltaTime() {
      const lastTime = this._clock;

      this._updateClock();

      return this._clock - lastTime;
    }

    _updateClock() {
      this._clock = Date.now();
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  /* eslint-enable */
  const QUICK_LOOK_SUPPORTED = () => {
    const anchorEl = document.createElement("a");
    return anchorEl.relList && anchorEl.relList.supports && anchorEl.relList.supports("ar");
  };
  const WEBXR_SUPPORTED = () => navigator.xr && !!navigator.xr.isSessionSupported;
  const HIT_TEST_SUPPORTED = () => window.XRSession && window.XRSession.prototype.requestHitTestSource;
  const DOM_OVERLAY_SUPPORTED = () => window.XRDOMOverlayState != null;
  const SESSION = {
    AR: "immersive-ar",
    VR: "immersive-vr"
  };
  const REFERENCE_SPACE = {
    LOCAL: "local",
    LOCAL_FLOOR: "local-floor",
    VIEWER: "viewer"
  };
  const EVENTS$2 = {
    SELECT_START: "selectstart",
    SELECT: "select",
    SELECT_END: "selectend"
  };
  const INPUT_PROFILE = {
    TOUCH: "generic-touchscreen"
  };
  const FEATURES = {
    HIT_TEST: {
      requiredFeatures: ["hit-test"]
    },
    DOM_OVERLAY: root => root ? {
      requiredFeatures: ["dom-overlay"],
      domOverlay: {
        root
      }
    } : {}
  }; // For type definition

  const EMPTY_FEATURES = {};
  const SCENE_VIEWER = {
    INTENT_AR_CORE: (params, fallback) => `intent://arvr.google.com/scene-viewer/1.2?${params}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;${fallback ? `S.browser_fallback_url=${fallback};` : ""}end;`,
    INTENT_SEARCHBOX: (params, fallback) => `intent://arvr.google.com/scene-viewer/1.2?${params}#Intent;scheme=https;package=com.google.android.googlequicksearchbox;action=android.intent.action.VIEW;${fallback ? `S.browser_fallback_url=${fallback};` : ""}end;`,
    FALLBACK_DEFAULT: params => `https://arvr.google.com/scene-viewer?${params}`
  };

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * One finger swirl control on single axis
   */

  class ARSwirlControl {
    /**
     * Create new ARSwirlControl
     * @param {ARSwirlControlOptions} [options={}] Options
     * @param {number} [options.scale=1] Scale(speed) factor of the rotation
     * @param {boolean} [options.showIndicator=true] Whether to show rotation indicator or not.
     */
    constructor({
      scale = 1
    } = {}) {
      /**
       * Current rotation value
       */
      this.rotation = new Quaternion(); // Internal States

      this._axis = new Vector3(0, 1, 0);
      this._enabled = false;
      this._active = false;
      this._prevPos = new Vector2();
      this._fromQuat = new Quaternion();
      this._toQuat = new Quaternion();
      this._motion = new Motion({
        range: INFINITE_RANGE
      });
      this._userScale = scale;
    }
    /**
     * Whether this control is enabled or not.
     * @readonly
     */


    get enabled() {
      return this._enabled;
    }
    /**
     * Scale(speed) factor of this control.
     */


    get scale() {
      return this._userScale;
    }

    set scale(val) {
      this._userScale = val;
    }

    updateRotation(rotation) {
      this.rotation.copy(rotation);

      this._fromQuat.copy(rotation);

      this._toQuat.copy(rotation);
    }
    /**
     * Enable this control
     */


    enable() {
      this._enabled = true;
    }
    /**
     * Disable this control
     */


    disable() {
      this._enabled = false;
    }

    activate() {
      if (!this._enabled) return;
      this._active = true;
    }

    deactivate() {
      this._active = false;
    }

    updateAxis(axis) {
      this._axis.copy(axis);
    }

    setInitialPos(coords) {
      this._prevPos.copy(coords[0]);
    }

    process({
      scene,
      xrCam
    }, {
      coords
    }) {
      if (!this._active || coords.length !== 1) return;
      const prevPos = this._prevPos;
      const motion = this._motion;
      const coord = coords[0];
      const modelPos = scene.modelMovable.getWorldPosition(new Vector3());
      const ndcModelPos = new Vector2().fromArray(modelPos.project(xrCam).toArray()); // Get the rotation angle with the model's NDC coordinates as the center.

      const rotationAngle = getRotationAngle(ndcModelPos, prevPos, coord) * this._userScale;

      const rotation = new Quaternion().setFromAxisAngle(this._axis, rotationAngle);

      const interpolated = this._getInterpolatedQuaternion();

      this._fromQuat.copy(interpolated);

      this._toQuat.premultiply(rotation);

      motion.reset(0);
      motion.setEndDelta(1);
      prevPos.copy(coord);
    }

    update({
      scene
    }, deltaTime) {
      if (!this._active) return;
      const motion = this._motion;
      motion.update(deltaTime);

      const interpolated = this._getInterpolatedQuaternion();

      this.rotation.copy(interpolated);
      scene.setModelRotation(interpolated);
    }

    _getInterpolatedQuaternion() {
      const motion = this._motion;
      const toEuler = this._toQuat;
      const fromEuler = this._fromQuat;
      const progress = motion.val;
      return new Quaternion().copy(fromEuler).slerp(toEuler, progress);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  var STATE;

  (function (STATE) {
    STATE[STATE["WAITING"] = 0] = "WAITING";
    STATE[STATE["TRANSLATING"] = 1] = "TRANSLATING";
    STATE[STATE["BOUNCING"] = 2] = "BOUNCING";
  })(STATE || (STATE = {}));
  /**
   * Model's translation(position) control for {@link WebARControl}
   */


  class ARTranslateControl {
    /**
     * Create new instance of ARTranslateControl
     * @param {ARTranslateControlOption} [options={}] Options
     */
    constructor({
      hoverHeight = 0.1,
      bounceDuration = 1000,
      bounceEasing = EASING.EASE_OUT_BOUNCE
    } = {}) {
      // Internal states
      this._hoverPosition = new Vector3();
      this._floorPosition = new Vector3();
      this._wallRotation = new Quaternion();
      this._dragPlane = new Plane();
      this._enabled = false;
      this._vertical = false;
      this._state = STATE.WAITING;
      this._initialPos = new Vector2();
      this._hoverHeight = hoverHeight;
      this._bounceMotion = new Motion({
        duration: bounceDuration,
        easing: bounceEasing,
        range: INFINITE_RANGE
      });
    }
    /**
     * Whether this control is enabled or not
     * @readonly
     */


    get enabled() {
      return this._enabled;
    }
    /**
     * Last detected floor position
     * @readonly
     */


    get floorPosition() {
      return this._floorPosition.clone();
    }
    /**
     * How much model will float from the floor, in meter.
     */


    get hoverHeight() {
      return this._hoverHeight;
    }

    set hoverHeight(val) {
      this._hoverHeight = val;
    }
    /**
     * Enable this control
     */


    enable() {
      this._enabled = true;
    }
    /**
     * Disable this control
     */


    disable() {
      this.deactivate();
      this._enabled = false;
    }

    activate() {
      if (!this._enabled) return;
      const dragPlane = this._dragPlane;
      dragPlane.constant = this._calcDragPlaneConstant(this._floorPosition);
      this._state = STATE.TRANSLATING;
    }

    deactivate() {
      if (!this._enabled || this._vertical || this._state === STATE.WAITING) {
        this._state = STATE.WAITING;
        return;
      }

      this._state = STATE.BOUNCING;
      const floorPosition = this._floorPosition;
      const hoverPosition = this._hoverPosition;
      const bounceMotion = this._bounceMotion;
      const hoveringAmount = hoverPosition.y - floorPosition.y;
      bounceMotion.reset(hoveringAmount);
      bounceMotion.setEndDelta(-hoveringAmount);
    }

    init(position, rotation, vertical) {
      this._floorPosition.copy(position);

      this._hoverPosition.copy(position);

      const planeNormal = vertical ? new Vector3(0, 1, 0).applyQuaternion(rotation) : new Vector3(0, 1, 0);

      this._dragPlane.normal.copy(planeNormal);

      this._wallRotation.copy(rotation);

      this._vertical = vertical;
    }

    setInitialPos(coords) {
      this._initialPos.copy(coords[0]);
    }

    process({
      frame,
      referenceSpace,
      xrCam
    }, {
      hitResults
    }) {
      const state = this._state;
      const notActive = state === STATE.WAITING || state === STATE.BOUNCING;
      if (!hitResults || hitResults.length !== 1 || notActive) return;
      const hitResult = hitResults[0];

      const prevFloorPosition = this._floorPosition.clone();

      const floorPosition = this._floorPosition;
      const hoverPosition = this._hoverPosition;
      const hoverHeight = this._hoverHeight;
      const dragPlane = this._dragPlane;
      const vertical = this._vertical;
      const hitPose = hitResult.results[0] && hitResult.results[0].getPose(referenceSpace);
      const hitMatrix = hitPose && new Matrix4().fromArray(hitPose.transform.matrix);
      const isFloorHit = hitPose && hitMatrix.elements[5] > 0.75;
      const isWallHit = hitPose && hitMatrix.elements[5] < 0.25;
      const camPos = new Vector3().setFromMatrixPosition(xrCam.matrixWorld);
      const hitPosition = hitPose && new Vector3().setFromMatrixPosition(hitMatrix);

      if (!vertical) {
        if (frame && (!hitPose || !isFloorHit)) {
          // Use previous drag plane if no hit plane is found
          const targetRayPose = frame.getPose(hitResult.inputSource.targetRaySpace, referenceSpace);
          if (!targetRayPose) return;
          const rayPos = targetRayPose.transform.position;
          const fingerPos = new Vector3(rayPos.x, rayPos.y, rayPos.z);
          const fingerDir = fingerPos.sub(camPos).normalize();
          const fingerRay = new Ray(camPos, fingerDir);
          const intersection = fingerRay.intersectPlane(dragPlane, new Vector3());

          if (intersection) {
            floorPosition.copy(intersection);
            floorPosition.setY(prevFloorPosition.y);
            hoverPosition.copy(intersection);
          }

          return;
        } // Set new floor level when it's increased at least 10cm


        const currentDragPlaneHeight = -dragPlane.constant;
        const hitDragPlaneHeight = hitPosition.y + hoverHeight;

        if (hitDragPlaneHeight - currentDragPlaneHeight > 0.1) {
          dragPlane.constant = -hitDragPlaneHeight;
        }

        const camToHitDir = new Vector3().subVectors(hitPosition, camPos).normalize();
        const camToHitRay = new Ray(camPos, camToHitDir);
        const hitOnDragPlane = camToHitRay.intersectPlane(dragPlane, new Vector3());
        if (!hitOnDragPlane) return;
        floorPosition.copy(hitOnDragPlane);
        floorPosition.setY(hitPosition.y);
        hoverPosition.copy(hitOnDragPlane);
      } else {
        if (frame && (!hitPose || !isWallHit)) {
          // Use previous drag plane if no hit plane is found
          const targetRayPose = frame.getPose(hitResult.inputSource.targetRaySpace, referenceSpace);
          if (!targetRayPose) return;
          const rayPos = targetRayPose.transform.position;
          const fingerPos = new Vector3(rayPos.x, rayPos.y, rayPos.z);
          const fingerDir = fingerPos.sub(camPos).normalize();
          const fingerRay = new Ray(camPos, fingerDir);
          const intersection = fingerRay.intersectPlane(dragPlane, new Vector3());

          if (intersection) {
            floorPosition.copy(intersection);
          }

          return;
        }

        const globalUp = new Vector3(0, 1, 0);
        const hitOrientation = hitPose.transform.orientation;
        const wallNormal = globalUp.clone().applyQuaternion(new Quaternion(hitOrientation.x, hitOrientation.y, hitOrientation.z, hitOrientation.w)).normalize();
        const wallX = new Vector3().crossVectors(new Vector3(0, 1, 0), wallNormal); // Update rotation if it differs more than 10deg

        const prevWallNormal = new Vector3(0, 1, 0).applyQuaternion(this._wallRotation).normalize();

        if (Math.acos(Math.abs(prevWallNormal.dot(wallNormal))) >= Math.PI / 18) {
          const wallMatrix = new Matrix4().makeBasis(wallX, globalUp, wallNormal);
          const wallEuler = new Euler(0, 0, 0, "YXZ").setFromRotationMatrix(wallMatrix);
          wallEuler.z = 0;
          wallEuler.x = Math.PI / 2;

          this._wallRotation.setFromEuler(wallEuler);

          dragPlane.normal.copy(new Vector3(0, 1, 0).applyQuaternion(this._wallRotation));
          dragPlane.constant = this._calcDragPlaneConstant(hitPosition);
        }

        const camToHitDir = new Vector3().subVectors(hitPosition, camPos).normalize();
        const camToHitRay = new Ray(camPos, camToHitDir);
        const hitOnDragPlane = camToHitRay.intersectPlane(dragPlane, new Vector3());
        if (!hitOnDragPlane) return;
        floorPosition.copy(hitOnDragPlane);
      }
    }

    update({
      scene
    }, delta) {
      const state = this._state;
      const floorPosition = this._floorPosition;
      const hoverPosition = this._hoverPosition;
      const bounceMotion = this._bounceMotion;
      const vertical = this._vertical;

      if (state === STATE.BOUNCING) {
        bounceMotion.update(delta);
        hoverPosition.setY(floorPosition.y + bounceMotion.val);

        if (bounceMotion.progress >= 1) {
          this._state = STATE.WAITING;
        }
      }

      scene.setRootPosition(floorPosition);

      if (!vertical) {
        scene.setModelHovering(hoverPosition.y - floorPosition.y);
      } else {
        scene.setWallRotation(this._wallRotation);
      }
    }

    _calcDragPlaneConstant(floor) {
      const vertical = this._vertical;

      const dragPlaneNormal = this._dragPlane.normal.clone();

      const dragPlaneAtZero = new Plane(dragPlaneNormal, 0);
      const hoverHeight = vertical ? 0 : this._hoverHeight;
      const dragPlaneConstant = -(dragPlaneAtZero.distanceToPoint(floor) + hoverHeight);
      return dragPlaneConstant;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * UI element displaying model's scale percentage info when user chaning model's scale.
   */

  class ScaleUI {
    /**
     * Create new instance of ScaleUI
     * @param {ScaleUIOptions} [options={}] Options
     */
    constructor({
      width = 0.1,
      padding = 20,
      offset = 0.05,
      font = "64px sans-serif",
      color = "white"
    } = {}) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      ctx.font = font; // Maximum canvas width should be equal to this

      const maxText = ctx.measureText("100%"); // Following APIs won't work on IE, but it's WebXR so I think it's okay

      const maxWidth = maxText.actualBoundingBoxLeft + maxText.actualBoundingBoxRight;
      const maxHeight = maxText.actualBoundingBoxAscent + maxText.actualBoundingBoxDescent;
      const widthPowerOfTwo = toPowerOfTwo(maxWidth);
      canvas.width = widthPowerOfTwo;
      canvas.height = widthPowerOfTwo; // This considers increased amount by making width to power of two

      const planeWidth = width * (widthPowerOfTwo / maxWidth);
      this._ctx = ctx;
      this._canvas = canvas;
      this._height = planeWidth * maxHeight / maxWidth; // Text height inside plane

      this._texture = new CanvasTexture(canvas); // Plane is square

      const uiGeometry = new PlaneGeometry(planeWidth, planeWidth);
      const mesh = new Mesh(uiGeometry, new MeshBasicMaterial({
        map: this._texture,
        transparent: true,
        depthTest: false
      }));
      this._mesh = mesh;
      this._font = font;
      this._color = color;
      this._padding = padding;
      this._offset = offset;
      this.hide();
    }
    /**
     * Scale UI's plane mesh
     * @readonly
     */


    get mesh() {
      return this._mesh;
    }
    /**
     * Scale UI's height value
     * @readonly
     */


    get height() {
      return this._height;
    }
    /**
     * Whether UI is visible or not.
     * @readonly
     */


    get visible() {
      return this._mesh.visible;
    }

    updatePosition(worldRotation, focus, modelHeight) {
      const mesh = this._mesh;
      const offset = this._height / 2 + this._offset + modelHeight;
      const offsetVec = new Vector3(0, offset, 0).applyQuaternion(worldRotation.clone().invert()); // Update mesh

      mesh.position.copy(offsetVec);
      mesh.lookAt(focus);
    }

    updateScale(scale) {
      const ctx = this._ctx;
      const canvas = this._canvas;
      const padding = this._padding;
      const scalePercentage = (scale * 100).toFixed(0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2; // Draw round rect

      const textSize = ctx.measureText(`${scalePercentage}%`);
      const halfWidth = (textSize.actualBoundingBoxLeft + textSize.actualBoundingBoxRight) / 2;
      const halfHeight = (textSize.actualBoundingBoxAscent + textSize.actualBoundingBoxDescent) / 2;
      ctx.beginPath();
      ctx.moveTo(centerX - halfWidth, centerY - halfHeight - padding);
      ctx.lineTo(centerX + halfWidth, centerY - halfHeight - padding);
      ctx.quadraticCurveTo(centerX + halfWidth + padding, centerY - halfHeight - padding, centerX + halfWidth + padding, centerY - halfHeight);
      ctx.lineTo(centerX + halfWidth + padding, centerY + halfHeight);
      ctx.quadraticCurveTo(centerX + halfWidth + padding, centerY + halfHeight + padding, centerX + halfWidth, centerY + halfHeight + padding);
      ctx.lineTo(centerX - halfWidth, centerY + halfHeight + padding);
      ctx.quadraticCurveTo(centerX - halfWidth - padding, centerY + halfHeight + padding, centerX - halfWidth - padding, centerY + halfHeight);
      ctx.lineTo(centerX - halfWidth - padding, centerY - halfHeight);
      ctx.quadraticCurveTo(centerX - halfWidth - padding, centerY - halfHeight - padding, centerX - halfWidth, centerY - halfHeight - padding);
      ctx.closePath();
      ctx.lineWidth = 5;
      ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
      ctx.fill();
      ctx.stroke(); // Draw text

      ctx.font = this._font;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.strokeStyle = this._color;
      ctx.fillStyle = this._color;
      ctx.fillText(`${scalePercentage}%`, centerX, centerY);
      this._texture.needsUpdate = true;

      this._mesh.scale.setScalar(1 / scale);
    }
    /**
     * Show UI
     */


    show() {
      this._mesh.visible = true;
    }
    /**
     * Hide UI
     */


    hide() {
      this._mesh.visible = false;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Model's scale controller which works on AR(WebXR) mode.
   */

  class ARScaleControl {
    /**
     * Create new instance of ARScaleControl
     * @param {ARScaleControlOptions} [options={}] Options
     * @param {number} [options.min=0.05] Minimum scale, default is 0.05(5%)
     * @param {number} [options.max=5] Maximum scale, default is 5(500%)
     */
    constructor({
      min = 0.05,
      max = 5
    } = {}) {
      this._enabled = false;
      this._active = false;
      this._prevCoordDistance = -1;
      this._scaleMultiplier = 1;
      this._ui = new ScaleUI();
      this._motion = new Motion({
        duration: 0,
        range: {
          min,
          max
        }
      });

      this._motion.reset(1); // default scale is 1(100%)


      this._ui = new ScaleUI();
    }
    /**
     * Whether this control is enabled or not
     * @readonly
     */


    get enabled() {
      return this._enabled;
    }

    get scale() {
      return this._scaleMultiplier;
    }

    get ui() {
      return this._ui;
    }
    /**
     * Range of the scale
     * @readonly
     */


    get range() {
      return this._motion.range;
    }

    setInitialScale({
      scene,
      model,
      floorPosition,
      xrCam,
      initialScale
    }) {
      const motion = this._motion;
      const scaleRange = motion.range;

      if (initialScale === AUTO) {
        const camFov = 2 * Math.atan(1 / xrCam.projectionMatrix.elements[5]); // in radians

        const aspectInv = xrCam.projectionMatrix.elements[0] / xrCam.projectionMatrix.elements[5]; // x/y

        const camPos = xrCam.position;
        const modelHeight = model.bbox.max.y - model.bbox.min.y;
        const camToFloorDist = camPos.distanceTo(new Vector3().addVectors(floorPosition, new Vector3(0, modelHeight / 2, 0)));
        const viewY = camToFloorDist * Math.tan(camFov / 2);
        const viewX = viewY * aspectInv;
        const modelBoundingSphere = model.bbox.getBoundingSphere(new Sphere());
        const scaleY = viewY / modelBoundingSphere.radius;
        const scaleX = viewX / modelBoundingSphere.radius;
        const scale = clamp$1(Math.min(scaleX, scaleY), scaleRange.min, 1);
        motion.reset(scale);
      } else {
        motion.reset(clamp$1(initialScale, scaleRange.min, scaleRange.max));
      }

      const scale = this._motion.val;
      this._scaleMultiplier = scale;
      scene.setModelScale(scale);
    }

    setInitialPos(coords) {
      this._prevCoordDistance = new Vector2().subVectors(coords[0], coords[1]).length();
    }
    /**
     * Enable this control
     */


    enable() {
      this._enabled = true;
    }
    /**
     * Disable this control
     */


    disable() {
      this._enabled = false;
      this.deactivate();
    }

    activate(ctx) {
      this._active = true;

      this._ui.show();

      this._updateUIPosition(ctx);
    }

    deactivate() {
      this._active = false;

      this._ui.hide();

      this._prevCoordDistance = -1;
    }

    process(ctx, {
      coords
    }) {
      if (coords.length !== 2 || !this._enabled || !this._active) return;
      const motion = this._motion;
      const distance = new Vector2().subVectors(coords[0], coords[1]).length();
      const delta = distance - this._prevCoordDistance;
      motion.setEndDelta(delta);
      this._prevCoordDistance = distance;

      this._updateUIPosition(ctx);
    }

    update({
      view3D,
      scene
    }, deltaTime) {
      if (!this._enabled || !this._active) return;
      const motion = this._motion;
      motion.update(deltaTime);
      this._scaleMultiplier = motion.val;

      this._ui.updateScale(this._scaleMultiplier);

      scene.setModelScale(this._scaleMultiplier);
      view3D.scene.shadowPlane.updateShadow(this._scaleMultiplier);
    }

    _updateUIPosition({
      view3D,
      scene,
      xrCam,
      vertical
    }) {
      // Update UI
      const model = view3D.model;
      const camPos = new Vector3().setFromMatrixPosition(xrCam.matrixWorld);
      const modelHeight = vertical ? model.bbox.getBoundingSphere(new Sphere()).radius : model.bbox.max.y - model.bbox.min.y;

      this._ui.updatePosition(scene.root.quaternion, camPos, modelHeight);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Ring type indicator for showing where the model's at.
   */

  class FloorIndicator {
    /**
     * Create new instance of FloorIndicator
     * @param {FloorIndicatorOptions} [options={}] Options
     */
    constructor({
      ringOpacity = 0.3,
      dirIndicatorOpacity = 1,
      fadeoutDuration = 1000
    } = {}) {
      const deg10 = Math.PI / 18;
      const ringGeomtry = new RingGeometry(0.975, 1, 150, 1, -6 * deg10, 30 * deg10);
      const reticleGeometry = new CircleGeometry(0.1, 30, 0, Math.PI * 2);
      ringGeomtry.rotateX(-Math.PI / 2);
      reticleGeometry.rotateX(-Math.PI / 2);
      const arrowGeometry = new RingGeometry(0.96, 1.015, 30, 1, 25 * deg10, 4 * deg10); // Create little triangle in ring

      const {
        position: arrowGeometryPosition
      } = arrowGeometry.attributes;
      const triangleStartIdx = Math.floor(11 * arrowGeometryPosition.count / 16);
      const triangleEndIdx = Math.floor(13 * arrowGeometryPosition.count / 16);
      const midIndex = Math.floor((triangleEndIdx - triangleStartIdx + 1) / 2);
      const firstY = new Vector3().fromBufferAttribute(arrowGeometryPosition, triangleStartIdx).y;

      for (let idx = triangleStartIdx; idx < triangleEndIdx; idx++) {
        const vecIndex = idx - triangleStartIdx;
        const offsetAmount = 0.025 * (midIndex - Math.abs(vecIndex - midIndex));
        arrowGeometryPosition.setY(idx, firstY - offsetAmount);
      }

      arrowGeometry.rotateX(-Math.PI / 2);
      const dimmedMaterial = new MeshBasicMaterial({
        transparent: true,
        opacity: ringOpacity,
        color: 0xffffff
      });
      const highlightMaterial = new MeshBasicMaterial({
        transparent: true,
        opacity: dirIndicatorOpacity,
        color: 0xffffff
      });
      const ring = new Mesh(ringGeomtry, dimmedMaterial);
      const reticle = new Mesh(reticleGeometry, dimmedMaterial);
      const arrow = new Mesh(arrowGeometry, highlightMaterial);
      const merged = new Group();
      merged.add(ring, reticle, arrow);
      merged.position.setY(0.0001); // Set Y higher than shadow plane

      this._mesh = merged;
      this._ring = ring;
      this._reticle = reticle;
      this._arrow = arrow;
      this._animator = new Motion({
        duration: fadeoutDuration
      });
      this._opacityRange = {
        min: ringOpacity,
        max: dirIndicatorOpacity
      };
      this.hide();
    }
    /**
     * Ring mesh
     */


    get mesh() {
      return this._mesh;
    }

    updateSize(model) {
      this._mesh.scale.setScalar(model.bbox.getBoundingSphere(new Sphere()).radius);
    }

    update({
      delta,
      rotation
    }) {
      const mesh = this._mesh;
      const animator = this._animator;
      if (!mesh.visible) return;
      animator.update(delta);
      const minOpacityMat = this._ring.material;
      const maxOpacityMat = this._arrow.material;
      const opacityRange = this._opacityRange;
      minOpacityMat.opacity = animator.val * opacityRange.min;
      maxOpacityMat.opacity = animator.val * opacityRange.max;

      if (animator.val <= 0) {
        mesh.visible = false;
      } // Update mesh


      mesh.quaternion.copy(rotation);
      mesh.updateMatrix();
    }

    show() {
      this._mesh.visible = true;

      this._animator.reset(1);
    }

    hide() {
      this._mesh.visible = false;
    }

    fadeout() {
      this._animator.setEndDelta(-1);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  var STATE$1;

  (function (STATE) {
    STATE[STATE["WAITING"] = 0] = "WAITING";
    STATE[STATE["IN_DEADZONE"] = 1] = "IN_DEADZONE";
    STATE[STATE["OUT_OF_DEADZONE"] = 2] = "OUT_OF_DEADZONE";
  })(STATE$1 || (STATE$1 = {}));
  /**
   * Deadzone checker for deadzone-based controls
   */


  class DeadzoneChecker {
    /**
     * Create new DeadzoneChecker
     * @param {DeadzoneCheckerOptions} [options={}] Options
     * @param {number} [options.size=0.1] Size of the deadzone circle.
     */
    constructor({
      size = 0.1
    } = {}) {
      // Internal States
      this._state = STATE$1.WAITING;
      this._detectedGesture = GESTURE.NONE;
      this._testingGestures = GESTURE.NONE;
      this._lastFingerCount = 0;
      this._aspect = 1; // Store two prev positions, as it should be maintained separately

      this._prevOneFingerPos = new Vector2();
      this._prevTwoFingerPos = new Vector2();
      this._initialTwoFingerDistance = 0;
      this._prevOneFingerPosInitialized = false;
      this._prevTwoFingerPosInitialized = false;
      this._size = size;
    }
    /**
     * Size of the deadzone.
     * @type {number}
     */


    get size() {
      return this._size;
    }
    /**
     * Whether the input is in the deadzone
     * @type {boolean}
     */


    get inDeadzone() {
      return this._state === STATE$1.IN_DEADZONE;
    }

    set size(val) {
      this._size = val;
    }
    /**
     * Set screen aspect(height / width)
     * @param aspect Screen aspect value
     */


    setAspect(aspect) {
      this._aspect = aspect;
    }

    setFirstInput(inputs) {
      const fingerCount = inputs.length;

      if (fingerCount === 1 && !this._prevOneFingerPosInitialized) {
        this._prevOneFingerPos.copy(inputs[0]);

        this._prevOneFingerPosInitialized = true;
      } else if (fingerCount === 2 && !this._prevTwoFingerPosInitialized) {
        this._prevTwoFingerPos.copy(new Vector2().addVectors(inputs[0], inputs[1]).multiplyScalar(0.5));

        this._initialTwoFingerDistance = new Vector2().subVectors(inputs[0], inputs[1]).length();
        this._prevTwoFingerPosInitialized = true;
      }

      this._lastFingerCount = fingerCount;
      this._state = STATE$1.IN_DEADZONE;
    }

    addTestingGestures(...gestures) {
      this._testingGestures = this._testingGestures | gestures.reduce((gesture, accumulated) => gesture | accumulated, GESTURE.NONE);
    }

    cleanup() {
      this._testingGestures = GESTURE.NONE;
      this._lastFingerCount = 0;
      this._prevOneFingerPosInitialized = false;
      this._prevTwoFingerPosInitialized = false;
      this._initialTwoFingerDistance = 0;
      this._detectedGesture = GESTURE.NONE;
      this._state = STATE$1.WAITING;
    }

    applyScreenAspect(inputs) {
      const aspect = this._aspect;
      inputs.forEach(input => {
        if (aspect > 1) {
          input.setY(input.y * aspect);
        } else {
          input.setX(input.x / aspect);
        }
      });
    }

    check(inputs) {
      const state = this._state;
      const deadzone = this._size;
      const testingGestures = this._testingGestures;
      const lastFingerCount = this._lastFingerCount;
      const fingerCount = inputs.length;

      if (state === STATE$1.OUT_OF_DEADZONE) {
        return this._detectedGesture;
      }

      this._lastFingerCount = fingerCount;
      this.applyScreenAspect(inputs);

      if (fingerCount !== lastFingerCount) {
        this.setFirstInput(inputs);
        return GESTURE.NONE;
      }

      if (fingerCount === 1) {
        const input = inputs[0];

        const prevPos = this._prevOneFingerPos.clone();

        const diff = new Vector2().subVectors(input, prevPos);

        if (diff.length() > deadzone) {
          if (Math.abs(diff.x) > Math.abs(diff.y)) {
            if (GESTURE.ONE_FINGER_HORIZONTAL & testingGestures) {
              this._detectedGesture = GESTURE.ONE_FINGER_HORIZONTAL;
            }
          } else {
            if (GESTURE.ONE_FINGER_VERTICAL & testingGestures) {
              this._detectedGesture = GESTURE.ONE_FINGER_VERTICAL;
            }
          }
        }
      } else if (fingerCount === 2) {
        const middle = new Vector2().addVectors(inputs[1], inputs[0]).multiplyScalar(0.5);

        const prevPos = this._prevTwoFingerPos.clone();

        const diff = new Vector2().subVectors(middle, prevPos);

        if (diff.length() > deadzone) {
          if (Math.abs(diff.x) > Math.abs(diff.y)) {
            if (GESTURE.TWO_FINGER_HORIZONTAL & testingGestures) {
              this._detectedGesture = GESTURE.TWO_FINGER_HORIZONTAL;
            }
          } else {
            if (GESTURE.TWO_FINGER_VERTICAL & testingGestures) {
              this._detectedGesture = GESTURE.TWO_FINGER_VERTICAL;
            }
          }
        }

        const distance = new Vector2().subVectors(inputs[1], inputs[0]).length();

        if (Math.abs(distance - this._initialTwoFingerDistance) > deadzone) {
          if (GESTURE.PINCH & testingGestures) {
            this._detectedGesture = GESTURE.PINCH;
          }
        }
      }

      if (this._detectedGesture !== GESTURE.NONE) {
        this._state = STATE$1.OUT_OF_DEADZONE;
      }

      return this._detectedGesture;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * AR control for {@link WebARSession}
   */

  class WebARControl {
    /**
     * Create new instance of ARControl
     * @param {WebARControlOptions} options Options
     */
    constructor(view3D, arScene, {
      rotate,
      translate,
      scale,
      ring,
      deadzone,
      initialScale
    }) {
      this._onSelectStart = evt => {
        const frame = evt.frame;
        const view3D = this._view3D;
        const arScene = this._arScene;
        const hitTestSource = this._hitTestSource;
        const deadzoneChecker = this._deadzoneChecker;
        const rotateControl = this._rotateControl;
        const translateControl = this._translateControl;
        const scaleControl = this._scaleControl;
        const threeRenderer = view3D.renderer.threeRenderer;
        const xrCamArray = threeRenderer.xr.getCamera(new PerspectiveCamera());
        const referenceSpace = threeRenderer.xr.getReferenceSpace();
        if (!hitTestSource || xrCamArray.cameras.length <= 0) return;
        const xrCam = xrCamArray.cameras[0];
        const model = view3D.model; // Update deadzone testing gestures

        if (rotateControl.enabled) {
          deadzoneChecker.addTestingGestures(GESTURE.ONE_FINGER);
        }

        if (translateControl.enabled) {
          deadzoneChecker.addTestingGestures(GESTURE.ONE_FINGER);
        }

        if (scaleControl.enabled) {
          deadzoneChecker.addTestingGestures(GESTURE.PINCH);
        }

        const hitResults = frame.getHitTestResultsForTransientInput(hitTestSource);

        const coords = this._hitResultToVector(hitResults);

        deadzoneChecker.applyScreenAspect(coords);
        deadzoneChecker.setFirstInput(coords);

        if (coords.length === 1) {
          // Check finger is on the model
          const targetRayPose = frame.getPose(hitResults[0].inputSource.targetRaySpace, referenceSpace);

          if (targetRayPose) {
            const camPos = new Vector3().setFromMatrixPosition(xrCam.matrixWorld);
            const rayPose = targetRayPose.transform.position;
            const fingerDir = new Vector3(rayPose.x, rayPose.y, rayPose.z).sub(camPos).normalize();
            const fingerRay = new Ray(camPos, fingerDir);
            const modelBoundingSphere = model.bbox.getBoundingSphere(new Sphere());
            modelBoundingSphere.applyMatrix4(arScene.modelMovable.matrixWorld);
            const intersection = fingerRay.intersectSphere(modelBoundingSphere, new Vector3());

            if (intersection) {
              // Touch point intersected with model
              this._modelHit = true;
            }
          }
        }

        if (!this._vertical || this._modelHit) {
          this._floorIndicator.show();
        }
      };

      this._onSelectEnd = () => {
        this._deactivate();

        this._floorIndicator.fadeout();
      };

      this._view3D = view3D;
      this._arScene = arScene;
      this._vertical = false;
      this._initialized = false;
      this._modelHit = false;
      this._hitTestSource = null;
      this._rotate = rotate;
      this._translate = translate;
      this._scale = scale;
      this._initialScale = initialScale;
      this._rotateControl = new ARSwirlControl(getObjectOption(rotate));
      this._translateControl = new ARTranslateControl(getObjectOption(translate));
      this._scaleControl = new ARScaleControl(getObjectOption(scale));
      this._floorIndicator = new FloorIndicator(ring);
      this._deadzoneChecker = new DeadzoneChecker(deadzone);
    }
    /**
     * {@link ARSwirlControl} in this control
     */


    get rotate() {
      return this._rotateControl;
    }
    /**
     * {@link ARTranslateControl} in this control
     */


    get translate() {
      return this._translateControl;
    }
    /**
     * {@link ARScaleControl} in this control
     */


    get scale() {
      return this._scaleControl;
    }

    init({
      model,
      session,
      size,
      vertical,
      hitPosition,
      hitRotation
    }) {
      return __awaiter(this, void 0, void 0, function* () {
        const arScene = this._arScene;
        const translateControl = this._translateControl;
        const scaleControl = this._scaleControl;
        const floorIndicator = this._floorIndicator;
        const deadzoneChecker = this._deadzoneChecker;
        this._vertical = vertical;
        translateControl.init(hitPosition, hitRotation, vertical);
        deadzoneChecker.setAspect(size.height / size.width);
        arScene.add(floorIndicator.mesh, scaleControl.ui.mesh);
        this.syncTargetModel(model);
        const transientHitTestSource = yield session.requestHitTestSourceForTransientInput({
          profile: INPUT_PROFILE.TOUCH
        });
        this._hitTestSource = transientHitTestSource;
        this._initialized = true;
      });
    }
    /**
     * Destroy this control and deactivate it
     */


    destroy(session) {
      if (!this._initialized) return;

      if (this._hitTestSource) {
        this._hitTestSource.cancel();

        this._hitTestSource = null;
      }

      this.disable(session);

      this._floorIndicator.hide();

      this._scaleControl.ui.hide();

      session.removeEventListener(EVENTS$2.SELECT_START, this._onSelectStart);
      session.removeEventListener(EVENTS$2.SELECT_END, this._onSelectEnd);
      this._initialized = false;
    }

    enable(session) {
      const rotate = this._rotate;
      const translate = this._translate;
      const scale = this._scale;
      const rotateControl = this._rotateControl;
      const translateControl = this._translateControl;
      const scaleControl = this._scaleControl;
      const vertical = this._vertical;
      session.addEventListener(EVENTS$2.SELECT_START, this._onSelectStart);
      session.addEventListener(EVENTS$2.SELECT_END, this._onSelectEnd);

      if (rotate && !vertical) {
        rotateControl.enable();
      }

      if (translate) {
        translateControl.enable();
      }

      if (scale) {
        scaleControl.enable();
      }
    }

    disable(session) {
      const rotateControl = this._rotateControl;
      const translateControl = this._translateControl;
      const scaleControl = this._scaleControl;
      session.removeEventListener(EVENTS$2.SELECT_START, this._onSelectStart);
      session.removeEventListener(EVENTS$2.SELECT_END, this._onSelectEnd);

      this._deactivate();

      rotateControl.disable();
      translateControl.disable();
      scaleControl.disable();
    }

    update(ctx) {
      var _a;

      const {
        view3D,
        session,
        frame
      } = ctx;
      const hitTestSource = this._hitTestSource;
      if (!hitTestSource || !view3D.model) return;
      const deadzoneChecker = this._deadzoneChecker;
      const inputSources = session.inputSources;
      const hitResults = (_a = frame === null || frame === void 0 ? void 0 : frame.getHitTestResultsForTransientInput(hitTestSource)) !== null && _a !== void 0 ? _a : [];

      const coords = this._hitResultToVector(hitResults);

      const xrInputs = {
        coords,
        inputSources,
        hitResults
      };

      if (deadzoneChecker.inDeadzone) {
        this._checkDeadzone(ctx, xrInputs);
      } else {
        this._processInput(ctx, xrInputs);
      }

      this._updateControls(ctx);
    }

    syncTargetModel(model) {
      const initialScale = this._initialScale;
      const floorPosition = this._translateControl.floorPosition;

      const xrCam = this._view3D.renderer.threeRenderer.xr.getCamera(new PerspectiveCamera()).cameras[0];

      this._floorIndicator.updateSize(model);

      this._scaleControl.setInitialScale({
        scene: this._arScene,
        model,
        floorPosition,
        xrCam,
        initialScale
      });
    }

    _deactivate() {
      this._modelHit = false;

      this._deadzoneChecker.cleanup();

      this._rotateControl.deactivate();

      this._translateControl.deactivate();

      this._scaleControl.deactivate();
    }

    _checkDeadzone(ctx, {
      coords
    }) {
      const arScene = this._arScene;
      const rotateControl = this._rotateControl;
      const translateControl = this._translateControl;
      const scaleControl = this._scaleControl;

      const gesture = this._deadzoneChecker.check(coords.map(coord => coord.clone()));

      if (gesture === GESTURE.NONE) return;

      switch (gesture) {
        case GESTURE.ONE_FINGER_HORIZONTAL:
        case GESTURE.ONE_FINGER_VERTICAL:
          if (this._modelHit) {
            translateControl.activate();
            translateControl.setInitialPos(coords);
          } else {
            rotateControl.activate();
            rotateControl.updateRotation(arScene.modelMovable.quaternion);
            rotateControl.setInitialPos(coords);
          }

          break;

        case GESTURE.PINCH:
          scaleControl.activate(ctx);
          scaleControl.setInitialPos(coords);
          break;
      }
    }

    _processInput(ctx, inputs) {
      this._rotateControl.process(ctx, inputs);

      this._translateControl.process(ctx, inputs);

      this._scaleControl.process(ctx, inputs);
    }

    _updateControls(ctx) {
      const {
        delta
      } = ctx;
      const arScene = this._arScene;
      const rotateControl = this._rotateControl;
      const translateControl = this._translateControl;
      const scaleControl = this._scaleControl;
      const floorIndicator = this._floorIndicator;
      const deltaMilisec = delta * 1000;
      rotateControl.update(ctx, deltaMilisec);
      translateControl.update(ctx, deltaMilisec);
      scaleControl.update(ctx, deltaMilisec);
      const modelRotation = rotateControl.rotation;
      const floorPosition = translateControl.floorPosition;
      arScene.setRootPosition(floorPosition);
      floorIndicator.update({
        delta: deltaMilisec,
        rotation: modelRotation
      });
    }

    _hitResultToVector(hitResults) {
      return hitResults.map(input => {
        return new Vector2().set(input.inputSource.gamepad.axes[0], -input.inputSource.gamepad.axes[1]);
      });
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  class ARScene {
    constructor() {
      this._root = new Scene();
      this._modelRoot = new Group();
      this._modelMovable = new Group();
      this._modelFixed = new Group();
      this._arRoot = new Group();
      const root = this._root;
      const modelRoot = this._modelRoot;
      const modelMovable = this._modelMovable;
      const modelFixed = this._modelFixed;
      const arRoot = this._arRoot;
      modelRoot.add(modelMovable);
      root.add(modelRoot, modelFixed, arRoot);
    }

    get root() {
      return this._root;
    }

    get modelRoot() {
      return this._modelRoot;
    }

    get modelMovable() {
      return this._modelMovable;
    }

    get arRoot() {
      return this._arRoot;
    }

    init(view3D) {
      const root = this._root;
      const modelMovable = this._modelMovable;
      const modelFixed = this._modelFixed; // Copy all scene objects into model objects

      const originalScene = view3D.scene;
      modelMovable.add(originalScene.userObjects, originalScene.envObjects);
      modelFixed.add(originalScene.fixedObjects); // Copy environment

      root.environment = originalScene.root.environment; // Start with root hidden, as floor should be detected first

      this.hideModel();
    }

    destroy(view3D) {
      const modelMovable = this._modelMovable;
      const modelFixed = this._modelFixed;
      const originalScene = view3D.scene;
      [...modelMovable.children, ...modelFixed.children].forEach(child => {
        originalScene.root.add(child);
      });
    }
    /**
     * Make this scene visible
     * @returns {void}
     */


    showModel() {
      this._modelRoot.visible = true;
    }
    /**
     * Make this scene invisible
     * @returns {void}
     */


    hideModel() {
      this._modelRoot.visible = false;
    }
    /**
     * Add AR-exclusive object
     */


    add(...objects) {
      this._arRoot.add(...objects);
    }

    setRootPosition(pos) {
      const root = this._root;
      root.position.copy(pos);
    }

    setWallRotation(quat) {
      const root = this._root;
      root.quaternion.copy(quat);
    }

    updateModelRootPosition(model, vertical) {
      const modelRoot = this._modelRoot;
      if (!vertical) return;
      const modelHeight = model.bbox.max.y - model.bbox.min.y;
      modelRoot.position.setZ(modelHeight / 2);
      modelRoot.position.setY(-model.bbox.min.z);
      modelRoot.rotateX(-Math.PI / 2);
      modelRoot.updateMatrix();
    }

    setModelHovering(hoverAmount) {
      const modelMovable = this._modelMovable;
      modelMovable.position.setY(hoverAmount);
    }

    setModelRotation(quat) {
      const modelMovable = this._modelMovable;
      modelMovable.quaternion.copy(quat);
    }

    setModelScale(scalar) {
      const root = this._root;
      root.scale.setScalar(scalar);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Manager for WebXR dom-overlay feature
   */

  class DOMOverlay {
    constructor() {
      this._root = null;
    }
    /**
     * Return whether dom-overlay feature is available
     */


    static isAvailable() {
      return DOM_OVERLAY_SUPPORTED();
    }

    get root() {
      return this._root;
    }

    destroy() {
      this._root = null;
    }

    getFeatures(root) {
      this._root = root;
      return FEATURES.DOM_OVERLAY(root);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Manager for WebXR hit-test feature
   */

  class HitTest {
    constructor() {
      this._source = null;
    }
    /**
     * Return whether hit-test feature is available
     */


    static isAvailable() {
      return HIT_TEST_SUPPORTED();
    }
    /**
     * Return whether hit-test is ready
     */


    get ready() {
      return this._source != null;
    }
    /**
     * Destroy instance
     */


    destroy() {
      if (this._source) {
        this._source.cancel();

        this._source = null;
      }
    }
    /**
     * Initialize hit-test feature
     * @param {XRSession} session XRSession instance
     */


    init(session) {
      session.requestReferenceSpace(REFERENCE_SPACE.VIEWER).then(referenceSpace => {
        session.requestHitTestSource({
          space: referenceSpace
        }).then(source => {
          this._source = source;
        });
      });
    }
    /**
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/XRSessionInit XRSessionInit} object for hit-test feature
     */


    getFeatures() {
      return FEATURES.HIT_TEST;
    }
    /**
     * Get hit-test results
     * @param {XRFrame} frame XRFrame instance
     */


    getResults(frame) {
      var _a;

      return (_a = frame === null || frame === void 0 ? void 0 : frame.getHitTestResults(this._source)) !== null && _a !== void 0 ? _a : [];
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * WebXR based abstract AR session class
   */

  class WebARSession {
    /**
     * Create new instance of WebARSession
     * @param {View3D} view3D Instance of the View3D
     * @param {object} [options={}] Options
     * @param {object} [options.features={}] Additional features(see {@link https://developer.mozilla.org/en-US/docs/Web/API/XRSessionInit XRSessionInit}) of the WebXR session.
     * @param {HTMLElement|string|null} [options.overlayRoot=null] `dom-overlay`'s root element. You can set either HTMLElement or query selector for that element.
     * @param {boolean|ARSwirlControlOptions} [options.rotate=true] Options for the rotate control inside the AR session. You can disable rotate control by giving `false`.
     * @param {boolean|ARTranslateControlOptions} [options.translate=true] Options for the translate control inside the AR session. You can disable translate control by giving `false`.
     * @param {boolean|ARScaleControlOptions} [options.scale=true] Options for the scale control inside the AR session. You can disable scale control by giving `false`.
     * @param {FloorIndicatorOptions} [options.ring={}] Options for the floor ring.
     * @param {DeadzoneCheckerOptions} [options.deadzone={}] Control's deadzone options.
     * @param {"auto"|number} [options.initialScale="auto"] Initial scale of the model. If set to "auto", it will modify big overflowing 3D model's scale to fit the screen when it's initially displayed. This won't increase the 3D model's scale more than 1.
     */
    constructor(view3D, {
      features = EMPTY_FEATURES,
      vertical = false,
      overlayRoot = null,
      rotate = true,
      translate = true,
      scale = true,
      ring = {},
      deadzone = {},
      initialScale = AUTO
    } = {}) {
      this._view3D = view3D; // Init internal states

      this._modelPlaced = false; // Bind options

      this.features = features;
      this.vertical = vertical;
      this.overlayRoot = overlayRoot; // Create internal components

      this._arScene = new ARScene();
      this._control = new WebARControl(view3D, this._arScene, {
        rotate,
        translate,
        scale,
        ring,
        deadzone,
        initialScale
      });
      this._hitTest = new HitTest();
      this._domOverlay = new DOMOverlay();
    }
    /**
     * Return availability of this session
     * @returns {Promise<boolean>} A Promise that resolves availability of this session(boolean).
     */


    static isAvailable() {
      if (!WEBXR_SUPPORTED() || !HitTest.isAvailable() || !DOMOverlay.isAvailable()) return Promise.resolve(false);
      return navigator.xr.isSessionSupported(SESSION.AR);
    }
    /**
     * {@link ARControl} instance of this session
     * @type ARFloorControl
     */


    get control() {
      return this._control;
    }

    get arScene() {
      return this._arScene;
    }

    get hitTest() {
      return this._hitTest;
    }

    get domOverlay() {
      return this._domOverlay;
    }
    /**
     * Enter session
     * @param view3D Instance of the View3D
     * @returns {Promise}
     */


    enter() {
      return __awaiter(this, void 0, void 0, function* () {
        const view3D = this._view3D;
        const arScene = this._arScene;
        const renderer = view3D.renderer;
        const threeRenderer = renderer.threeRenderer;
        const control = this._control;
        const hitTest = this._hitTest;
        const domOverlay = this._domOverlay;
        const vertical = this.vertical;

        const features = this._getAllXRFeatures(); // Enable xr


        threeRenderer.xr.enabled = true;
        const session = yield navigator.xr.requestSession(SESSION.AR, features); // Cache original values

        const originalPixelRatio = threeRenderer.getPixelRatio();
        threeRenderer.setPixelRatio(1);
        threeRenderer.xr.setReferenceSpaceType(REFERENCE_SPACE.LOCAL);
        yield threeRenderer.xr.setSession(session);
        arScene.init(view3D);
        hitTest.init(session);

        const onSessionEnd = () => __awaiter(this, void 0, void 0, function* () {
          const overlayEl = domOverlay.root;
          control.destroy(session);
          arScene.destroy(view3D);

          if (!this.overlayRoot && overlayEl) {
            view3D.rootEl.removeChild(overlayEl);
          }

          domOverlay.destroy();
          view3D.scene.shadowPlane.updateShadow(); // Restore original values

          threeRenderer.setPixelRatio(originalPixelRatio); // Restore render loop

          renderer.stopAnimationLoop();
          renderer.setAnimationLoop(renderer.defaultRenderLoop);
          view3D.trigger(EVENTS.AR_END, {
            target: view3D,
            type: EVENTS.AR_END,
            session: this
          });
        });

        session.addEventListener("end", onSessionEnd, {
          once: true
        }); // Set XR session render loop

        const arClock = new Clock();
        arClock.start();
        renderer.stopAnimationLoop();
        threeRenderer.xr.setAnimationLoop((_, frame) => {
          var _a, _b;

          const xrCamArray = threeRenderer.xr.getCamera(new PerspectiveCamera());
          const delta = arClock.getDelta();
          if (xrCamArray.cameras.length <= 0) return;
          const xrCam = xrCamArray.cameras[0];
          const referenceSpace = threeRenderer.xr.getReferenceSpace();
          const glLayer = session.renderState.baseLayer;
          const size = {
            width: (_a = glLayer === null || glLayer === void 0 ? void 0 : glLayer.framebufferWidth) !== null && _a !== void 0 ? _a : 1,
            height: (_b = glLayer === null || glLayer === void 0 ? void 0 : glLayer.framebufferHeight) !== null && _b !== void 0 ? _b : 1
          };
          const ctx = {
            view3D,
            scene: arScene,
            session,
            delta,
            frame,
            vertical,
            referenceSpace,
            xrCam,
            size
          };
          const deltaMiliSec = delta * 1000;
          view3D.trigger(EVENTS.BEFORE_RENDER, {
            type: EVENTS.BEFORE_RENDER,
            target: view3D,
            delta: deltaMiliSec
          });

          if (!this._modelPlaced) {
            this._initModelPosition(ctx);
          } else {
            control.update(ctx);
            view3D.animator.update(delta);
            threeRenderer.render(arScene.root, xrCam);
          }

          view3D.trigger(EVENTS.RENDER, {
            type: EVENTS.RENDER,
            target: view3D,
            delta: deltaMiliSec
          });
        });
        view3D.trigger(EVENTS.AR_START, {
          type: EVENTS.AR_START,
          target: view3D,
          session: this
        });
      });
    }
    /**
     * Exit this session
     */


    exit() {
      return __awaiter(this, void 0, void 0, function* () {
        const session = this._view3D.renderer.threeRenderer.xr.getSession();

        return session === null || session === void 0 ? void 0 : session.end();
      });
    }

    _getAllXRFeatures() {
      var _a;

      const userFeatures = this.features;
      const overlayRoot = (_a = getNullableElement(this.overlayRoot)) !== null && _a !== void 0 ? _a : this._createARRootElement();
      return merge({}, this._domOverlay.getFeatures(overlayRoot), this._hitTest.getFeatures(), userFeatures);
    }

    _initModelPosition(ctx) {
      const {
        frame,
        session,
        size,
        vertical,
        referenceSpace
      } = ctx;
      const view3D = this._view3D;
      const model = view3D.model;
      const arScene = this._arScene;
      const hitTest = this._hitTest; // Make sure the model is loaded

      if (!hitTest.ready || !model) return;
      const control = this._control;
      const hitTestResults = hitTest.getResults(frame);
      if (hitTestResults.length <= 0) return;
      const hit = hitTestResults[0];
      const hitPose = hit.getPose(referenceSpace);
      if (!hitPose) return;
      const hitMatrix = new Matrix4().fromArray(hitPose.transform.matrix); // If transformed coords space's y axis is not facing the correct direction, don't use it.

      if (!vertical && hitMatrix.elements[5] < 0.75 || vertical && (hitMatrix.elements[5] >= 0.25 || hitMatrix.elements[5] <= -0.25)) return;
      const hitPosition = new Vector3().setFromMatrixPosition(hitMatrix);
      const hitRotation = new Quaternion();

      if (vertical) {
        const globalUp = new Vector3(0, 1, 0);
        const hitOrientation = hitPose.transform.orientation;
        const wallNormal = globalUp.clone().applyQuaternion(new Quaternion(hitOrientation.x, hitOrientation.y, hitOrientation.z, hitOrientation.w)).normalize();
        const wallX = new Vector3().crossVectors(new Vector3(0, 1, 0), wallNormal);
        const wallMatrix = new Matrix4().makeBasis(wallX, globalUp, wallNormal);
        const wallEuler = new Euler(0, 0, 0, "YXZ").setFromRotationMatrix(wallMatrix);
        wallEuler.z = 0;
        wallEuler.x = Math.PI / 2;
        hitRotation.setFromEuler(wallEuler);
        arScene.setWallRotation(hitRotation);
      } // Reset rotation & update position


      arScene.updateModelRootPosition(model, vertical);
      arScene.setRootPosition(hitPosition);
      arScene.showModel(); // Don't need hit-test anymore, as we're having new one in WebARControl

      hitTest.destroy();
      this._modelPlaced = true;
      view3D.trigger(EVENTS.AR_MODEL_PLACED, {
        type: EVENTS.AR_MODEL_PLACED,
        target: view3D,
        session: this,
        model
      });
      void control.init({
        model,
        vertical,
        session,
        size,
        hitPosition,
        hitRotation
      });
      const initialScale = control.scale.scale; // Show scale up animation

      const scaleUpAnimation = new Animation({
        context: session,
        duration: 1000
      });
      scaleUpAnimation.on("progress", evt => {
        arScene.setModelScale(evt.easedProgress * initialScale);
      });
      scaleUpAnimation.on("finish", () => {
        arScene.setModelScale(initialScale);
        control.enable(session);
      });
      scaleUpAnimation.start();
    }

    _createARRootElement() {
      const view3D = this._view3D;
      const root = document.createElement("div");
      root.classList.add(AR_OVERLAY_CLASS);
      view3D.rootEl.appendChild(root);
      view3D.once(EVENTS.AR_END, () => {
        view3D.rootEl.removeChild(root);
      });
      return root;
    }

  }

  WebARSession.type = AR_SESSION_TYPE.WEBXR;

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * AR session using Google's scene-viewer
   * @see https://developers.google.com/ar/develop/java/scene-viewer
   */

  class SceneViewerSession {
    /**
     * Create new instance of SceneViewerSession
     * @see https://developers.google.com/ar/develop/java/scene-viewer
     * @param {View3D} view3D Instance of the View3D
     * @param {object} [params={}] Session params
     * @param {string} [params.file=null] This URL specifies the glTF or glb file that should be loaded into Scene Viewer. This should be URL-escaped. If `null` is given, it will try to use current model shown on the canvas. This behavior only works when the format of the model shown is either "glTF" or "glb".
     * @param {string} [params.mode="ar_only"] See [SCENE_VIEWER_MODE](/docs/api/SCENE_VIEWER_MODE) for available modes (also check their [official page](https://developers.google.com/ar/develop/java/scene-viewer) for details).
     * @param {string} [params.fallbackURL=null] This is a Google Chrome feature supported only for web-based implementations. When the Google app com.google.android.googlequicksearchbox is not present on the device, this is the URL that Google Chrome navigates to.
     * @param {string} [params.title=null] A name for the model. If present, it will be displayed in the UI. The name will be truncated with ellipses after 60 characters.
     * @param {string} [params.link=null] A URL for an external webpage. If present, a button will be surfaced in the UI that intents to this URL when clicked.
     * @param {string} [params.sound=null] A URL to a looping audio track that is synchronized with the first animation embedded in a glTF file. It should be provided alongside a glTF with an animation of matching length. If present, the sound is looped after the model is loaded. This should be URL-escaped.
     * @param {boolean} [params.resizable=true] When set to false, users will not be able to scale the model in the AR experience. Scaling works normally in the 3D experience.
     * @param {boolean} [params.vertical=false] When set to true, users will be able to place the model on a vertical surface.
     * @param {boolean} [params.disableOcclusion=false] When set to true, SceneViewer will disable {@link https://developers.google.com/ar/develop/java/depth/introduction object blending}
     * @param {string} [params.initialScale="auto"] Initial scale of the 3D model. If set to `null`, 3D model will shown as its original size and will disable the "View actual size" button. Default value is "auto", and "1" will show model size in 100%, "2" in 200%, "0.5" in 50% and so on.
     * @param {string} [params.shareText=null] A text that will be displayed when user clicked the share button.
     */
    constructor(view3D, _a = {}) {
      var {
        file = null,
        mode = SCENE_VIEWER_MODE.ONLY_AR,
        fallbackURL = null,
        title = null,
        link = null,
        sound = null,
        resizable = true,
        vertical = false,
        disableOcclusion = false,
        initialScale = AUTO,
        shareText = null
      } = _a,
          otherParams = __rest(_a, ["file", "mode", "fallbackURL", "title", "link", "sound", "resizable", "vertical", "disableOcclusion", "initialScale", "shareText"]);

      this._view3D = view3D;
      this.file = file;
      this.fallbackURL = fallbackURL;
      this.mode = mode;
      this.title = title;
      this.link = link;
      this.sound = sound;
      this.resizable = resizable;
      this.vertical = vertical;
      this.disableOcclusion = disableOcclusion;
      this.initialScale = initialScale;
      this.shareText = shareText;
      this.otherParams = otherParams;
    }
    /**
     * Return the availability of SceneViewerSession.
     * Scene-viewer is available on all android devices with google ARCore installed.
     * @returns {Promise} A Promise that resolves availability of this session(boolean).
     */


    static isAvailable() {
      return Promise.resolve(IS_ANDROID());
    }
    /**
     * Enter Scene-viewer AR session
     */


    enter() {
      var _a, _b;

      return __awaiter(this, void 0, void 0, function* () {
        const model = this._view3D.model;
        const params = Object.assign({
          title: this.title,
          link: this.link,
          sound: this.sound,
          mode: this.mode,
          initial_scale: this.initialScale
        }, this.otherParams);
        params.resizable = toBooleanString(this.resizable);
        params.enable_vertical_placement = toBooleanString(this.vertical);
        params.disable_occlusion = toBooleanString(this.disableOcclusion);
        params.share_text = this.shareText ? encodeURIComponent(this.shareText) : null;
        const file = (_a = this.file) !== null && _a !== void 0 ? _a : model.src;

        if (!file) {
          return Promise.reject(new View3DError(ERROR.MESSAGES.FILE_NOT_SUPPORTED((_b = this.file) !== null && _b !== void 0 ? _b : model.src), ERROR.CODES.FILE_NOT_SUPPORTED));
        }

        params.file = new URL(file, window.location.href).href;
        const fallbackURL = this.fallbackURL;
        const queryString = Object.keys(params).filter(key => params[key] != null).map(key => `${key}=${params[key]}`).join("&");
        const intentURL = params.mode === SCENE_VIEWER_MODE.ONLY_AR ? SCENE_VIEWER.INTENT_AR_CORE(queryString, fallbackURL) : SCENE_VIEWER.INTENT_SEARCHBOX(queryString, fallbackURL || SCENE_VIEWER.FALLBACK_DEFAULT(queryString));
        const anchor = document.createElement("a");
        anchor.href = intentURL;
        anchor.click();
      });
    }

    exit() {
      return Promise.resolve();
    }

  }

  SceneViewerSession.type = AR_SESSION_TYPE.SCENE_VIEWER;

  /**
   * AR Session using Apple AR Quick Look Viewer
   * @see https://developer.apple.com/augmented-reality/quick-look/
   */

  class QuickLookSession {
    /**
     * Create new instance of QuickLookSession
     * @param {View3D} view3D Instance of the View3D
     * @param {object} [options={}] Quick Look options
     * @param {boolean} [options.allowsContentScaling=true] Whether to allow content scaling.
     * @param {string | null} [options.canonicalWebPageURL=null] The web URL to share when the user invokes the share sheet. If `null` is given, the USDZ file will be shared.
     * @param {string | null} [options.applePayButtonType=null] Type of the apple pay button in the banner. See {@link QUICK_LOOK_APPLE_PAY_BUTTON_TYPE}
     * @param {string | null} [options.callToAction=null] A text that will be displayed instead of Apple Pay Button. See {@link https://developer.apple.com/documentation/arkit/adding_an_apple_pay_button_or_a_custom_action_in_ar_quick_look#3405143 Official Guide Page}
     * @param {string | null} [options.checkoutTitle=null] Title of the previewed item. See {@link https://developer.apple.com/documentation/arkit/adding_an_apple_pay_button_or_a_custom_action_in_ar_quick_look#3405142 Official Guide Page}
     * @param {string | null} [options.checkoutSubtitle=null] Subtitle of the previewed item. See {@link https://developer.apple.com/documentation/arkit/adding_an_apple_pay_button_or_a_custom_action_in_ar_quick_look#3405142 Official Guide Page}
     * @param {string | null} [options.price=null] Price of the previewed item. See {@link https://developer.apple.com/documentation/arkit/adding_an_apple_pay_button_or_a_custom_action_in_ar_quick_look#3405142 Official Guide Page}
     * @param {string | null} [options.custom=null] Custom URL to the banner HTML. See {@link https://developer.apple.com/documentation/arkit/adding_an_apple_pay_button_or_a_custom_action_in_ar_quick_look#3402837 Official Guide Page}
     * @param {string | null} [options.customHeight=null] Height of the custom banner. See {@link QUICK_LOOK_CUSTOM_BANNER_SIZE}
     */
    constructor(view3D, {
      allowsContentScaling = true,
      canonicalWebPageURL = null,
      applePayButtonType = null,
      callToAction = null,
      checkoutTitle = null,
      checkoutSubtitle = null,
      price = null,
      custom = null,
      customHeight = null
    } = {}) {
      this._view3D = view3D;
      this.allowsContentScaling = allowsContentScaling;
      this.canonicalWebPageURL = canonicalWebPageURL;
      this.applePayButtonType = applePayButtonType;
      this.callToAction = callToAction;
      this.checkoutTitle = checkoutTitle;
      this.checkoutSubtitle = checkoutSubtitle;
      this.price = price;
      this.custom = custom;
      this.customHeight = customHeight;
    }
    /**
     * Return the availability of QuickLookSession.
     * QuickLook AR is available on iOS12+
     * @returns {Promise} A Promise that resolves availability of this session(boolean).
     */


    static isAvailable() {
      return Promise.resolve(QUICK_LOOK_SUPPORTED() && IS_IOS());
    }
    /**
     * Enter QuickLook AR Session
     */


    enter() {
      const view3D = this._view3D;
      const file = view3D.iosSrc;

      if (!file) {
        return Promise.reject(new View3DError(ERROR.MESSAGES.FILE_NOT_SUPPORTED(`${file}`), ERROR.CODES.FILE_NOT_SUPPORTED));
      }

      const canonicalWebPageURL = this.canonicalWebPageURL;
      const custom = this.custom;
      const currentHref = window.location.href;
      const anchor = document.createElement("a");
      anchor.setAttribute("rel", "ar");
      anchor.appendChild(document.createElement("img"));
      const hashObj = Object.entries({
        applePayButtonType: this.applePayButtonType,
        callToAction: this.callToAction,
        checkoutTitle: this.checkoutTitle,
        checkoutSubtitle: this.checkoutSubtitle,
        price: this.price,
        customHeight: this.customHeight
      }).reduce((obj, [key, value]) => {
        if (value) {
          obj[key] = value;
        }

        return obj;
      }, {});
      const usdzURL = new URL(file, currentHref);

      if (!this.allowsContentScaling) {
        hashObj.allowsContentScaling = "0";
      }

      if (canonicalWebPageURL) {
        hashObj.canonicalWebPageURL = new URL(canonicalWebPageURL, currentHref).href;
      }

      if (custom) {
        hashObj.custom = new URL(custom, currentHref).href;
      }

      usdzURL.hash = new URLSearchParams(hashObj).toString();
      anchor.setAttribute("href", usdzURL.href);
      anchor.addEventListener("message", evt => {
        if (evt.data === "_apple_ar_quicklook_button_tapped") {
          // User tapped either Apple pay button / Custom action button
          view3D.trigger(EVENTS.QUICK_LOOK_TAP, Object.assign(Object.assign({}, evt), {
            type: EVENTS.QUICK_LOOK_TAP,
            target: view3D
          }));
        }
      }, false);
      anchor.click();
      return Promise.resolve();
    }

    exit() {
      return Promise.resolve();
    }

  }

  QuickLookSession.type = AR_SESSION_TYPE.QUICK_LOOK;

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  const sessionCtors = {
    [AR_SESSION_TYPE.WEBXR]: WebARSession,
    [AR_SESSION_TYPE.SCENE_VIEWER]: SceneViewerSession,
    [AR_SESSION_TYPE.QUICK_LOOK]: QuickLookSession
  };
  /**
   * ARManager that manages AR sessions
   */

  class ARManager {
    /**
     * Create a new instance of the ARManager
     * @param {View3D} view3D An instance of the View3D
     */
    constructor(view3D) {
      this._view3D = view3D;
      this._activeSession = null;
      view3D.on(EVENTS.AR_START, ({
        session
      }) => {
        this._activeSession = session;
      });
      view3D.on(EVENTS.AR_END, () => {
        this._activeSession = null;
      });
    }

    get activeSession() {
      return this._activeSession;
    }
    /**
     * Return a Promise containing whether any of the added session is available
     * If any of the AR session in current environment, this will return `true`
     * @returns {Promise<boolean>} Availability of the AR session
     */


    isAvailable() {
      return __awaiter(this, void 0, void 0, function* () {
        const sessions = this._getSesssionClasses();

        const results = yield Promise.all(sessions.map(session => session.isAvailable()));
        return results.some(result => result === true);
      });
    }
    /**
     * Enter XR Session.
     * This should be called from a user interaction.
     */


    enter() {
      return __awaiter(this, void 0, void 0, function* () {
        const view3D = this._view3D;

        if (!view3D.model || !view3D.initialized) {
          throw new View3DError(ERROR.MESSAGES.NOT_INITIALIZED, ERROR.CODES.NOT_INITIALIZED);
        }

        const sessions = this._getSesssionClasses();

        for (const session of sessions) {
          try {
            if (yield session.isAvailable()) {
              const sessionInstance = new session(view3D, getObjectOption(view3D[session.type]));
              yield sessionInstance.enter();
              return Promise.resolve();
            }
          } catch (err) {} // eslint-disable-line no-empty

        } // No sessions were available


        return Promise.reject();
      });
    }
    /**
     * Exit current XR Session.
     */


    exit() {
      return __awaiter(this, void 0, void 0, function* () {
        const activeSession = this._activeSession;
        activeSession === null || activeSession === void 0 ? void 0 : activeSession.exit();
      });
    }

    _getSesssionClasses() {
      return this._getUsingSessionTypes().map(sessionType => sessionCtors[sessionType]);
    }

    _getUsingSessionTypes() {
      const view3D = this._view3D;
      const priority = view3D.arPriority;
      return priority.filter(sessionType => !!view3D[sessionType]);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Model's rotation control that supports both mouse & touch
   */

  class RotateControl extends Component {
    /**
     * Create new RotateControl instance
     * @param {View3D} view3D An instance of View3D
     * @param {RotateControlOptions} options Options
     */
    constructor(view3D, {
      duration = ANIMATION_DURATION,
      easing = EASING$1,
      scale = 1,
      disablePitch = false,
      disableYaw = false
    } = {}) {
      super();
      this._screenScale = new Vector2(0, 0);
      this._prevPos = new Vector2(0, 0);
      this._enabled = false;

      this._onMouseDown = evt => {
        if (evt.button !== MOUSE_BUTTON.LEFT) return;
        const targetEl = this._view3D.renderer.canvas;
        evt.preventDefault();

        if (!!targetEl.focus) {
          targetEl.focus();
        } else {
          window.focus();
        }

        this._prevPos.set(evt.clientX, evt.clientY);

        window.addEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);
        window.addEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);
        this.trigger(CONTROL_EVENTS.HOLD);
      };

      this._onMouseMove = evt => {
        evt.preventDefault();
        const prevPos = this._prevPos;
        const rotateDelta = new Vector2(evt.clientX, evt.clientY).sub(prevPos).multiplyScalar(this._scale);
        rotateDelta.multiply(this._screenScale);

        this._xMotion.setEndDelta(rotateDelta.x);

        this._yMotion.setEndDelta(rotateDelta.y);

        prevPos.set(evt.clientX, evt.clientY);
      };

      this._onMouseUp = () => {
        this._prevPos.set(0, 0);

        window.removeEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);
        window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);
        this.trigger(CONTROL_EVENTS.RELEASE);
      };

      this._onTouchStart = evt => {
        const touch = evt.touches[0];
        this._isFirstTouch = true;

        this._prevPos.set(touch.clientX, touch.clientY);
      };

      this._onTouchMove = evt => {
        // Only the one finger motion should be considered
        if (evt.touches.length > 1 || this._isScrolling) return;
        const touch = evt.touches[0];
        const scrollable = this._view3D.scrollable;

        if (scrollable && !evt.cancelable) {
          return;
        }

        if (this._isFirstTouch) {
          if (scrollable) {
            const delta = new Vector2(touch.clientX, touch.clientY).sub(this._prevPos);

            if (Math.abs(delta.y) > Math.abs(delta.x)) {
              // Assume Scrolling
              this._isScrolling = true;
              return;
            }
          }

          this._isFirstTouch = false;
        }

        if (!scrollable && evt.cancelable) {
          evt.preventDefault();
        }

        evt.stopPropagation();
        const prevPos = this._prevPos;
        const rotateDelta = new Vector2(touch.clientX, touch.clientY).sub(prevPos).multiplyScalar(this._scale);
        rotateDelta.multiply(this._screenScale);

        this._xMotion.setEndDelta(rotateDelta.x);

        this._yMotion.setEndDelta(rotateDelta.y);

        prevPos.set(touch.clientX, touch.clientY);
      };

      this._onTouchEnd = evt => {
        const touch = evt.touches[0];

        if (touch) {
          this._prevPos.set(touch.clientX, touch.clientY);
        } else {
          this._prevPos.set(0, 0);
        }

        this._isScrolling = false;
      };

      this._view3D = view3D;
      this._scale = scale;
      this._duration = duration;
      this._easing = easing;
      this._disablePitch = disablePitch;
      this._disableYaw = disableYaw;
      this._isFirstTouch = false;
      this._isScrolling = false;
      this._xMotion = new Motion({
        duration,
        range: INFINITE_RANGE,
        easing
      });
      this._yMotion = new Motion({
        duration,
        range: PITCH_RANGE,
        easing
      });
    }
    /**
     * Whether this control is enabled or not
     * @readonly
     * @type {boolean}
     */


    get enabled() {
      return this._enabled;
    }
    /**
     * Scale factor for rotation
     * @type {number}
     * @default 1
     */


    get scale() {
      return this._scale;
    }
    /**
     * Duration of the input animation (ms)
     * @type {number}
     * @default 300
     */


    get duration() {
      return this._duration;
    }
    /**
     * Easing function of the animation
     * @type {function}
     * @default EASING.EASE_OUT_CUBIC
     * @see EASING
     */


    get easing() {
      return this._easing;
    }
    /**
     * Disable X-axis(pitch) rotation
     * @type {boolean}
     * @default false
     */


    get disablePitch() {
      return this._disablePitch;
    }
    /**
     * Disable Y-axis(yaw) rotation
     * @type {boolean}
     * @default false
     */


    get disableYaw() {
      return this._disableYaw;
    }

    set scale(val) {
      this._scale = val;
    }

    set duration(val) {
      this._duration = val;
      this._xMotion.duration = val;
      this._yMotion.duration = val;
    }

    set easing(val) {
      this._easing = val;
      this._xMotion.easing = val;
      this._yMotion.easing = val;
    }
    /**
     * Destroy the instance and remove all event listeners attached
     * @returns {void}
     */


    destroy() {
      this.disable();
    }
    /**
     * Update control by given deltaTime
     * @param deltaTime Number of milisec to update
     * @returns {void}
     */


    update(deltaTime) {
      const camera = this._view3D.camera;
      const xMotion = this._xMotion;
      const yMotion = this._yMotion;
      const yawEnabled = !this._disableYaw;
      const pitchEnabled = !this._disablePitch;
      const delta = new Vector2(xMotion.update(deltaTime), yMotion.update(deltaTime));

      if (yawEnabled) {
        camera.yaw += delta.x;
      }

      if (pitchEnabled) {
        camera.pitch += delta.y;
      }
    }
    /**
     * Resize control to match target size
     * @param {object} size New size to apply
     * @param {number} [size.width] New width
     * @param {number} [size.height] New height
     */


    resize(size) {
      this._screenScale.set(360 / size.width, 180 / size.height);
    }
    /**
     * Enable this input and add event listeners
     * @returns {void}
     */


    enable() {
      if (this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.addEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown);
      targetEl.addEventListener(EVENTS$1.TOUCH_START, this._onTouchStart, {
        passive: true
      });
      targetEl.addEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, {
        passive: this._view3D.scrollable
      });
      targetEl.addEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd);
      this._enabled = true;
      this.sync();
      this.trigger(CONTROL_EVENTS.ENABLE);
    }
    /**
     * Disable this input and remove all event handlers
     * @returns {void}
     */


    disable() {
      if (!this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.removeEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown);
      window.removeEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove);
      window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp);
      targetEl.removeEventListener(EVENTS$1.TOUCH_START, this._onTouchStart);
      targetEl.removeEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove);
      targetEl.removeEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd);
      this._enabled = false;
      this.trigger(CONTROL_EVENTS.DISABLE);
    }
    /**
     * Synchronize this control's state to given camera position
     * @returns {void}
     */


    sync() {
      const camera = this._view3D.camera;

      this._xMotion.reset(camera.yaw);

      this._yMotion.reset(camera.pitch);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Model's translation control that supports both mouse & touch
   */

  class TranslateControl extends Component {
    /**
     * Create new TranslateControl instance
     * @param {View3D} view3D An instance of View3D
     * @param {TranslateControlOptions} options Options
     */
    constructor(view3D, {
      easing = EASING$1,
      duration = 0,
      scale = 1
    } = {}) {
      super();
      this._enabled = false; // Sometimes, touchstart for second finger doesn't triggered.
      // This flag checks whether that happened

      this._touchInitialized = false;
      this._prevPos = new Vector2(0, 0);
      this._screenSize = new Vector2(0, 0);

      this._onMouseDown = evt => {
        if (evt.button !== MOUSE_BUTTON.RIGHT) return;
        const targetEl = this._view3D.renderer.canvas;
        evt.preventDefault();

        if (!!targetEl.focus) {
          targetEl.focus();
        } else {
          window.focus();
        }

        this._prevPos.set(evt.clientX, evt.clientY);

        window.addEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);
        window.addEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);
        window.addEventListener(EVENTS$1.CONTEXT_MENU, this._onContextMenu, false);
        this.trigger(CONTROL_EVENTS.HOLD);
      };

      this._onMouseMove = evt => {
        evt.preventDefault();
        const prevPos = this._prevPos;
        const delta = new Vector2(evt.clientX, evt.clientY).sub(prevPos).multiplyScalar(this._scale); // X value is negated to match cursor direction

        this._xMotion.setEndDelta(-delta.x);

        this._yMotion.setEndDelta(delta.y);

        prevPos.set(evt.clientX, evt.clientY);
      };

      this._onMouseUp = () => {
        this._prevPos.set(0, 0);

        window.removeEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);
        window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);
        this.trigger(CONTROL_EVENTS.RELEASE);
      };

      this._onTouchStart = evt => {
        // Only the two finger motion should be considered
        if (evt.touches.length !== 2) return;

        if (evt.cancelable !== false) {
          evt.preventDefault();
        }

        this._prevPos.copy(this._getTouchesMiddle(evt.touches));

        this._touchInitialized = true;
      };

      this._onTouchMove = evt => {
        // Only the two finger motion should be considered
        if (evt.touches.length !== 2) return;

        if (evt.cancelable !== false) {
          evt.preventDefault();
        }

        evt.stopPropagation();
        const prevPos = this._prevPos;

        const middlePoint = this._getTouchesMiddle(evt.touches);

        if (!this._touchInitialized) {
          prevPos.copy(middlePoint);
          this._touchInitialized = true;
          return;
        }

        const delta = new Vector2().subVectors(middlePoint, prevPos).multiplyScalar(this._scale); // X value is negated to match cursor direction

        this._xMotion.setEndDelta(-delta.x);

        this._yMotion.setEndDelta(delta.y);

        prevPos.copy(middlePoint);
      };

      this._onTouchEnd = evt => {
        // Only the two finger motion should be considered
        if (evt.touches.length !== 2) {
          this._touchInitialized = false;
          return;
        } // Three fingers to two fingers


        this._prevPos.copy(this._getTouchesMiddle(evt.touches));

        this._touchInitialized = true;
      };

      this._onContextMenu = evt => {
        evt.preventDefault();
        window.removeEventListener(EVENTS$1.CONTEXT_MENU, this._onContextMenu, false);
      };

      this._view3D = view3D;
      this._xMotion = new Motion({
        duration,
        range: INFINITE_RANGE,
        easing
      });
      this._yMotion = new Motion({
        duration,
        range: INFINITE_RANGE,
        easing
      });
      this._scale = scale;
    }
    /**
     * Whether this control is enabled or not
     * @readonly
     * @type {boolean}
     */


    get enabled() {
      return this._enabled;
    }
    /**
     * Scale factor for translation
     * @type number
     * @default 1
     * @see https://threejs.org/docs/#api/en/math/Vector2
     */


    get scale() {
      return this._scale;
    }
    /**
     * Duration of the input animation (ms)
     * @type {number}
     * @default 300
     */


    get duration() {
      return this._duration;
    }
    /**
     * Easing function of the animation
     * @type {function}
     * @default EASING.EASE_OUT_CUBIC
     * @see EASING
     */


    get easing() {
      return this._easing;
    }

    set scale(val) {
      this._scale = val;
    }

    set duration(val) {
      this._duration = val;
      this._xMotion.duration = val;
      this._yMotion.duration = val;
    }

    set easing(val) {
      this._easing = val;
      this._xMotion.easing = val;
      this._yMotion.easing = val;
    }
    /**
     * Destroy the instance and remove all event listeners attached
     * @returns {void}
     */


    destroy() {
      this.disable();
    }
    /**
     * Update control by given deltaTime
     * @param deltaTime Number of milisec to update
     * @returns {void}
     */


    update(deltaTime) {
      const camera = this._view3D.camera;
      const screenSize = this._screenSize;
      const delta = new Vector2(this._xMotion.update(deltaTime), this._yMotion.update(deltaTime));
      const viewXDir = new Vector3(1, 0, 0).applyQuaternion(camera.threeCamera.quaternion);
      const viewYDir = new Vector3(0, 1, 0).applyQuaternion(camera.threeCamera.quaternion);
      const screenScale = new Vector2(camera.renderWidth, camera.renderHeight).divide(screenSize);
      delta.multiply(screenScale);
      camera.pivot.add(viewXDir.multiplyScalar(delta.x));
      camera.pivot.add(viewYDir.multiplyScalar(delta.y));
    }
    /**
     * Resize control to match target size
     * @param {object} size New size to apply
     * @param {number} [size.width] New width
     * @param {number} [size.height] New height
     */


    resize(size) {
      const screenSize = this._screenSize;
      screenSize.copy(new Vector2(size.width, size.height));
    }
    /**
     * Enable this input and add event listeners
     * @returns {void}
     */


    enable() {
      if (this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.addEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown, false);
      targetEl.addEventListener(EVENTS$1.TOUCH_START, this._onTouchStart, {
        passive: false,
        capture: false
      });
      targetEl.addEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, {
        passive: false,
        capture: false
      });
      targetEl.addEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd, {
        passive: false,
        capture: false
      });
      this._enabled = true;
      this.sync();
      this.trigger(CONTROL_EVENTS.ENABLE);
    }
    /**
     * Disable this input and remove all event handlers
     * @returns {void}
     */


    disable() {
      if (!this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.removeEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown, false);
      window.removeEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);
      window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);
      targetEl.removeEventListener(EVENTS$1.TOUCH_START, this._onTouchStart, false);
      targetEl.removeEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, false);
      targetEl.removeEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd, false);
      window.removeEventListener(EVENTS$1.CONTEXT_MENU, this._onContextMenu, false);
      this._enabled = false;
      this.trigger(CONTROL_EVENTS.DISABLE);
    }
    /**
     * Synchronize this control's state to the camera position
     * @returns {void}
     */


    sync() {
      this._xMotion.reset(0);

      this._yMotion.reset(0);
    }

    _getTouchesMiddle(touches) {
      return new Vector2(touches[0].clientX + touches[1].clientX, touches[0].clientY + touches[1].clientY).multiplyScalar(0.5);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Distance controller handling both mouse wheel and pinch zoom(fov)
   */

  class ZoomControl {
    /**
     * Create new ZoomControl instance
     * @param {View3D} view3D An instance of View3D
     * @param {ZoomControlOptions} options Options
     */
    constructor(view3D, {
      scale = 1,
      duration = ANIMATION_DURATION,
      minFov = 1,
      maxFov = AUTO,
      easing = EASING$1
    } = {}) {
      this._wheelModifier = 0.02;
      this._touchModifier = 0.05;
      this._prevTouchDistance = -1;
      this._enabled = false;

      this._onWheel = evt => {
        const wheelScrollable = this._view3D.wheelScrollable;
        if (evt.deltaY === 0 || wheelScrollable) return;
        evt.preventDefault();
        evt.stopPropagation();
        const animation = this._motion;
        const delta = -this._scale * this._wheelModifier * evt.deltaY;
        animation.setEndDelta(delta);
      };

      this._onTouchMove = evt => {
        const touches = evt.touches;
        if (touches.length !== 2) return;

        if (evt.cancelable !== false) {
          evt.preventDefault();
        }

        evt.stopPropagation();
        const animation = this._motion;
        const prevTouchDistance = this._prevTouchDistance;
        const touchPoint1 = new Vector2(touches[0].pageX, touches[0].pageY);
        const touchPoint2 = new Vector2(touches[1].pageX, touches[1].pageY);
        const touchDiff = touchPoint1.sub(touchPoint2);

        const touchDistance = touchDiff.length() * this._scale * this._touchModifier;

        const delta = touchDistance - prevTouchDistance;
        this._prevTouchDistance = touchDistance;
        if (prevTouchDistance < 0) return;
        animation.setEndDelta(delta);
      };

      this._onTouchEnd = () => {
        this._prevTouchDistance = -1;
      };

      this._view3D = view3D;
      this._scale = scale;
      this._duration = duration;
      this._minFov = minFov;
      this._maxFov = maxFov;
      this._easing = easing;
      this._range = {
        min: minFov,
        max: maxFov === AUTO ? 180 : maxFov
      };
      this._motion = new Motion({
        duration,
        easing
      });
    }
    /**
     * Whether this control is enabled or not
     * @readonly
     */


    get enabled() {
      return this._enabled;
    }
    /**
     * Actual fov range
     * @readonly
     */


    get range() {
      return this._range;
    }
    /**
     * Scale factor of the zoom
     * @type number
     * @default 1
     */


    get scale() {
      return this._scale;
    }
    /**
     * Duration of the input animation (ms)
     * @type {number}
     * @default 300
     */


    get duration() {
      return this._duration;
    }
    /**
     * Minimum vertical fov(field of view).
     * You can get a bigger image with the smaller value of this.
     * @type {number}
     * @default 1
     */


    get minFov() {
      return this._minFov;
    }
    /**
     * Maximum vertical fov(field of view).
     * You can get a smaller image with the bigger value of this.
     * If `"auto"` is given, it will use Math.min(default fov + 45, 175).
     * @type {"auto" | number}
     * @default "auto"
     */


    get maxFov() {
      return this._maxFov;
    }
    /**
     * Easing function of the animation
     * @type {function}
     * @default EASING.EASE_OUT_CUBIC
     * @see EASING
     */


    get easing() {
      return this._easing;
    }

    set scale(val) {
      this._scale = val;
    }
    /**
     * Destroy the instance and remove all event listeners attached
     * @returns {void}
     */


    destroy() {
      this.disable();
    }
    /**
     * Update control by given deltaTime
     * @param camera Camera to update position
     * @param deltaTime Number of milisec to update
     * @returns {void}
     */


    update(deltaTime) {
      const camera = this._view3D.camera;
      const motion = this._motion;
      camera.zoom += motion.update(deltaTime);
    } // eslint-disable-next-line @typescript-eslint/no-unused-vars


    resize(size) {// DO NOTHING
    }
    /**
     * Enable this input and add event listeners
     * @returns {void}
     */


    enable() {
      if (this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.addEventListener(EVENTS$1.WHEEL, this._onWheel, {
        passive: false,
        capture: false
      });
      targetEl.addEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, {
        passive: false,
        capture: false
      });
      targetEl.addEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd, {
        passive: false,
        capture: false
      });
      this._enabled = true;
      this.sync();
    }
    /**
     * Disable this input and remove all event handlers
     * @returns {void}
     */


    disable() {
      if (!this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.removeEventListener(EVENTS$1.WHEEL, this._onWheel, false);
      targetEl.removeEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, false);
      targetEl.removeEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd, false);
      this._enabled = false;
    }
    /**
     * Synchronize this control's state to given camera position
     * @param camera Camera to match state
     * @returns {void}
     */


    sync() {
      const camera = this._view3D.camera;

      this._motion.reset(camera.zoom);
    }
    /**
     * Update fov range by the camera's current fov value
     * @returns {void}
     */


    updateRange() {
      const max = this._maxFov;
      const range = this._range;
      const motion = this._motion;
      const {
        camera
      } = this._view3D;
      const baseFov = camera.baseFov;

      if (max === AUTO) {
        range.max = Math.min(baseFov + 45, 175);
      }

      motion.range.min = range.min - baseFov;
      motion.range.max = range.max - baseFov;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Aggregation of {@link RotateControl}, {@link TranslateControl}, and {@link ZoomControl}.
   */

  class OrbitControl {
    /**
     * Create new OrbitControl instance
     * @param {View3D} view3D An instance of View3D
     */
    constructor(view3D) {
      this._onEnable = () => {
        const view3D = this._view3D;
        const canvas = view3D.renderer.canvas;
        const shouldSetGrabCursor = view3D.useGrabCursor && (this._rotateControl.enabled || this._translateControl.enabled) && canvas.style.cursor === CURSOR.NONE;

        if (shouldSetGrabCursor) {
          this._setCursor(CURSOR.GRAB);
        }
      };

      this._onDisable = () => {
        const canvas = this._view3D.renderer.canvas;
        const shouldRemoveGrabCursor = canvas.style.cursor !== CURSOR.NONE && !this._rotateControl.enabled && !this._translateControl.enabled;

        if (shouldRemoveGrabCursor) {
          this._setCursor(CURSOR.NONE);
        }
      };

      this._onHold = () => {
        const grabCursorEnabled = this._view3D.useGrabCursor && (this._rotateControl.enabled || this._translateControl.enabled);

        if (grabCursorEnabled) {
          this._setCursor(CURSOR.GRABBING);
        }
      };

      this._onRelease = () => {
        const grabCursorEnabled = this._view3D.useGrabCursor && (this._rotateControl.enabled || this._translateControl.enabled);

        if (grabCursorEnabled) {
          this._setCursor(CURSOR.GRAB);
        }
      };

      this._view3D = view3D;
      this._rotateControl = new RotateControl(view3D, getObjectOption(view3D.rotate));
      this._translateControl = new TranslateControl(view3D, getObjectOption(view3D.translate));
      this._zoomControl = new ZoomControl(view3D, getObjectOption(view3D.zoom));
      [this._rotateControl, this._translateControl].forEach(control => {
        control.on({
          [CONTROL_EVENTS.HOLD]: this._onHold,
          [CONTROL_EVENTS.RELEASE]: this._onRelease,
          [CONTROL_EVENTS.ENABLE]: this._onEnable,
          [CONTROL_EVENTS.DISABLE]: this._onDisable
        });
      });
    } // Internal Values Getter

    /**
     * {@link RotateControl} of this control
     */


    get rotate() {
      return this._rotateControl;
    }
    /**
     * {@link TranslateControl} of this control
     */


    get translate() {
      return this._translateControl;
    }
    /**
     * {@link ZoomControl} of this control
     */


    get zoom() {
      return this._zoomControl;
    }
    /**
     * Destroy the instance and remove all event listeners attached
     * This also will reset CSS cursor to intial
     * @returns {void}
     */


    destroy() {
      this._rotateControl.destroy();

      this._translateControl.destroy();

      this._zoomControl.destroy();
    }
    /**
     * Update control by given deltaTime
     * @param deltaTime Number of milisec to update
     * @returns {void}
     */


    update(delta) {
      this._rotateControl.update(delta);

      this._translateControl.update(delta);

      this._zoomControl.update(delta);
    }
    /**
     * Resize control to match target size
     * @param {object} size New size to apply
     * @param {number} [size.width] New width
     * @param {number} [size.height] New height
     * @returns {void}
     */


    resize(size) {
      this._rotateControl.resize(size);

      this._translateControl.resize(size);

      this._zoomControl.resize(size);
    }
    /**
     * Enable this control and add event listeners
     * @returns {void}
     */


    enable() {
      const view3D = this._view3D;

      if (view3D.rotate) {
        this._rotateControl.enable();
      }

      if (view3D.translate) {
        this._translateControl.enable();
      }

      if (view3D.zoom) {
        this._zoomControl.enable();
      }
    }
    /**
     * Disable this control and remove all event handlers
     * @returns {void}
     */


    disable() {
      this._rotateControl.disable();

      this._translateControl.disable();

      this._zoomControl.disable();
    }
    /**
     * Synchronize this control's state to current camera position
     * @returns {void}
     */


    sync() {
      this._rotateControl.sync();

      this._translateControl.sync();

      this._zoomControl.sync();
    }
    /**
     * Update cursor to current option
     * @returns {void}
     */


    updateCursor() {
      const cursor = this._view3D.useGrabCursor ? CURSOR.GRAB : CURSOR.NONE;

      this._setCursor(cursor);
    }

    _setCursor(newCursor) {
      const view3D = this._view3D;
      if (!view3D.useGrabCursor && newCursor !== CURSOR.NONE) return;
      const targetEl = view3D.renderer.canvas;
      targetEl.style.cursor = newCursor;
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Autoplayer that animates model without user input
   */

  class AutoPlayer {
    /**
     * Create new AutoPlayer instance
     * @param {View3D} view3D An instance of View3D
     * @param {object} options Options
     * @param {number} [options.delay=2000] Reactivation delay after mouse input in milisecond
     * @param {number} [options.delayOnMouseLeave=0] Reactivation delay after mouse leave
     * @param {number} [options.speed=1] Y-axis(yaw) rotation speed
     * @param {boolean} [options.pauseOnHover=false] Whether to pause rotation on mouse hover
     * @param {boolean} [options.canInterrupt=true] Whether user can interrupt the rotation with click/wheel input
     * @param {boolean} [options.disableOnInterrupt=false] Whether to disable autoplay on user interrupt
     */
    constructor(view3D, {
      delay = 2000,
      delayOnMouseLeave = 0,
      speed = 1,
      pauseOnHover = false,
      canInterrupt = true,
      disableOnInterrupt = false
    } = {}) {
      this._enabled = false;
      this._interrupted = false;
      this._interruptionTimer = -1;
      this._hovering = false;

      this._onMouseDown = evt => {
        if (!this._canInterrupt) return;
        if (evt.button !== MOUSE_BUTTON.LEFT && evt.button !== MOUSE_BUTTON.RIGHT) return;
        this._interrupted = true;

        this._clearTimeout();

        window.addEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);
      };

      this._onMouseUp = () => {
        window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);

        this._setUninterruptedAfterDelay(this._delay);
      };

      this._onTouchStart = () => {
        if (!this._canInterrupt) return;
        this._interrupted = true;

        this._clearTimeout();
      };

      this._onTouchEnd = () => {
        this._setUninterruptedAfterDelay(this._delay);
      };

      this._onMouseEnter = () => {
        if (!this._pauseOnHover) return;
        this._interrupted = true;
        this._hovering = true;
      };

      this._onMouseLeave = () => {
        if (!this._pauseOnHover) return;
        this._hovering = false;

        this._setUninterruptedAfterDelay(this._delayOnMouseLeave);
      };

      this._onWheel = () => {
        if (!this._canInterrupt) return;
        this._interrupted = true;

        this._setUninterruptedAfterDelay(this._delay);
      };

      this._view3D = view3D;
      this._delay = delay;
      this._delayOnMouseLeave = delayOnMouseLeave;
      this._speed = speed;
      this._pauseOnHover = pauseOnHover;
      this._canInterrupt = canInterrupt;
      this._disableOnInterrupt = disableOnInterrupt;
    }
    /**
     * Whether autoplay is enabled or not
     * @readonly
     */


    get enabled() {
      return this._enabled;
    }
    /**
     * Reactivation delay after mouse input in milisecond
     */


    get delay() {
      return this._delay;
    }
    /**
     * Reactivation delay after mouse leave
     * This option only works when {@link AutoPlayer#pauseOnHover pauseOnHover} is activated
     */


    get delayOnMouseLeave() {
      return this._delayOnMouseLeave;
    }
    /**
     * Y-axis(yaw) rotation speed
     * @default 1
     */


    get speed() {
      return this._speed;
    }
    /**
     * Whether to pause rotation on mouse hover
     * @default false
     */


    get pauseOnHover() {
      return this._pauseOnHover;
    }
    /**
     * Whether user can interrupt the rotation with click/wheel input
     * @default true
     */


    get canInterrupt() {
      return this._canInterrupt;
    }
    /**
     * Whether to disable autoplay on user interrupt
     * @default false
     */


    get disableOnInterrupt() {
      return this._disableOnInterrupt;
    }

    set delay(val) {
      this._delay = val;
    }

    set delayOnMouseLeave(val) {
      this._delayOnMouseLeave = val;
    }

    set speed(val) {
      this._speed = val;
    }

    set pauseOnHover(val) {
      this._pauseOnHover = val;
    }

    set canInterrupt(val) {
      this._canInterrupt = val;
    }

    set disableOnInterrupt(val) {
      this._disableOnInterrupt = val;
    }
    /**
     * Destroy the instance and remove all event listeners attached
     * This also will reset CSS cursor to intial
     * @returns {void}
     */


    destroy() {
      this.disable();
    }
    /**
     * Update camera by given deltaTime
     * @param camera Camera to update position
     * @param deltaTime Number of milisec to update
     * @returns {void}
     */


    update(deltaTime) {
      if (!this._enabled) return;

      if (this._interrupted) {
        if (this._disableOnInterrupt) {
          this.disable();
        }

        return;
      }

      const camera = this._view3D.camera;
      camera.yaw += this._speed * deltaTime / 100;
    }
    /**
     * Enable this input and add event listeners
     * @returns {void}
     */


    enable() {
      if (this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.addEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown, false);
      targetEl.addEventListener(EVENTS$1.TOUCH_START, this._onTouchStart, {
        passive: false,
        capture: false
      });
      targetEl.addEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd, {
        passive: false,
        capture: false
      });
      targetEl.addEventListener(EVENTS$1.MOUSE_ENTER, this._onMouseEnter, false);
      targetEl.addEventListener(EVENTS$1.MOUSE_LEAVE, this._onMouseLeave, false);
      targetEl.addEventListener(EVENTS$1.WHEEL, this._onWheel, {
        passive: false,
        capture: false
      });
      this._enabled = true;
    }
    /**
     * Disable this input and remove all event handlers
     * @returns {void}
     */


    disable() {
      if (!this._enabled) return;
      const targetEl = this._view3D.renderer.canvas;
      targetEl.removeEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown, false);
      window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);
      targetEl.removeEventListener(EVENTS$1.TOUCH_START, this._onTouchStart, false);
      targetEl.removeEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd, false);
      targetEl.removeEventListener(EVENTS$1.MOUSE_ENTER, this._onMouseEnter, false);
      targetEl.removeEventListener(EVENTS$1.MOUSE_LEAVE, this._onMouseLeave, false);
      targetEl.removeEventListener(EVENTS$1.WHEEL, this._onWheel, false);
      this._enabled = false;
      this._interrupted = false;
      this._hovering = false;

      this._clearTimeout();
    }

    _setUninterruptedAfterDelay(delay) {
      if (this._hovering) return;

      this._clearTimeout();

      if (delay > 0) {
        this._interruptionTimer = window.setTimeout(() => {
          this._interrupted = false;
          this._interruptionTimer = -1;
        }, delay);
      } else {
        this._interrupted = false;
        this._interruptionTimer = -1;
      }
    }

    _clearTimeout() {
      if (this._interruptionTimer >= 0) {
        window.clearTimeout(this._interruptionTimer);
        this._interruptionTimer = -1;
      }
    }

  }

  class GLTFLoader extends Loader {
    constructor(manager) {
      super(manager);
      this.dracoLoader = null;
      this.ktx2Loader = null;
      this.meshoptDecoder = null;
      this.pluginCallbacks = [];
      this.register(function (parser) {
        return new GLTFMaterialsClearcoatExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFTextureBasisUExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFTextureWebPExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFMaterialsSheenExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFMaterialsTransmissionExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFMaterialsVolumeExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFMaterialsIorExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFMaterialsSpecularExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFLightsExtension(parser);
      });
      this.register(function (parser) {
        return new GLTFMeshoptCompression(parser);
      });
    }

    load(url, onLoad, onProgress, onError) {
      var scope = this;
      var resourcePath;

      if (this.resourcePath !== '') {
        resourcePath = this.resourcePath;
      } else if (this.path !== '') {
        resourcePath = this.path;
      } else {
        resourcePath = LoaderUtils.extractUrlBase(url);
      } // Tells the LoadingManager to track an extra item, which resolves after
      // the model is fully loaded. This means the count of items loaded will
      // be incorrect, but ensures manager.onLoad() does not fire early.


      this.manager.itemStart(url);

      var _onError = function (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      };

      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (data) {
        try {
          scope.parse(data, resourcePath, function (gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError);
        } catch (e) {
          _onError(e);
        }
      }, onProgress, _onError);
    }

    setDRACOLoader(dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    }

    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }

    setKTX2Loader(ktx2Loader) {
      this.ktx2Loader = ktx2Loader;
      return this;
    }

    setMeshoptDecoder(meshoptDecoder) {
      this.meshoptDecoder = meshoptDecoder;
      return this;
    }

    register(callback) {
      if (this.pluginCallbacks.indexOf(callback) === -1) {
        this.pluginCallbacks.push(callback);
      }

      return this;
    }

    unregister(callback) {
      if (this.pluginCallbacks.indexOf(callback) !== -1) {
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
      }

      return this;
    }

    parse(data, path, onLoad, onError) {
      var content;
      var extensions = {};
      var plugins = {};

      if (typeof data === 'string') {
        content = data;
      } else {
        var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError) onError(error);
            return;
          }

          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = LoaderUtils.decodeText(new Uint8Array(data));
        }
      }

      var json = JSON.parse(content);

      if (json.asset === undefined || json.asset.version[0] < 2) {
        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
        return;
      }

      var parser = new GLTFParser(json, {
        path: path || this.resourcePath || '',
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      parser.fileLoader.setRequestHeader(this.requestHeader);

      for (var i = 0; i < this.pluginCallbacks.length; i++) {
        var plugin = this.pluginCallbacks[i](parser);
        plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension
        // in addUnknownExtensionsToUserData().
        // Remove this workaround if we move all the existing
        // extension handlers to plugin system

        extensions[plugin.name] = true;
      }

      if (json.extensionsUsed) {
        for (var _i = 0; _i < json.extensionsUsed.length; ++_i) {
          var extensionName = json.extensionsUsed[_i];
          var extensionsRequired = json.extensionsRequired || [];

          switch (extensionName) {
            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;

            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;

            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;

            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;

            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;

            default:
              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }

          }
        }
      }

      parser.setExtensions(extensions);
      parser.setPlugins(plugins);
      parser.parse(onLoad, onError);
    }

  }
  /* GLTFREGISTRY */


  function GLTFRegistry() {
    var objects = {};
    return {
      get: function (key) {
        return objects[key];
      },
      add: function (key, object) {
        objects[key] = object;
      },
      remove: function (key) {
        delete objects[key];
      },
      removeAll: function () {
        objects = {};
      }
    };
  }
  /*********************************/

  /********** EXTENSIONS ***********/

  /*********************************/


  var EXTENSIONS = {
    KHR_BINARY_GLTF: 'KHR_binary_glTF',
    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
    KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
    KHR_MATERIALS_IOR: 'KHR_materials_ior',
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
    KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
    KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
    KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
    KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
    KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
    KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
    EXT_TEXTURE_WEBP: 'EXT_texture_webp',
    EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
  };
  /**
   * Punctual Lights Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
   */

  class GLTFLightsExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches

      this.cache = {
        refs: {},
        uses: {}
      };
    }

    _markDefs() {
      var parser = this.parser;
      var nodeDefs = this.parser.json.nodes || [];

      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];

        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {
          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
        }
      }
    }

    _loadLight(lightIndex) {
      var parser = this.parser;
      var cacheKey = 'light:' + lightIndex;
      var dependency = parser.cache.get(cacheKey);
      if (dependency) return dependency;
      var json = parser.json;
      var extensions = json.extensions && json.extensions[this.name] || {};
      var lightDefs = extensions.lights || [];
      var lightDef = lightDefs[lightIndex];
      var lightNode;
      var color = new Color(0xffffff);
      if (lightDef.color !== undefined) color.fromArray(lightDef.color);
      var range = lightDef.range !== undefined ? lightDef.range : 0;

      switch (lightDef.type) {
        case 'directional':
          lightNode = new DirectionalLight(color);
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        case 'point':
          lightNode = new PointLight(color);
          lightNode.distance = range;
          break;

        case 'spot':
          lightNode = new SpotLight(color);
          lightNode.distance = range; // Handle spotlight properties.

          lightDef.spot = lightDef.spot || {};
          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
          lightNode.angle = lightDef.spot.outerConeAngle;
          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        default:
          throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);
      } // Some lights (e.g. spot) default to a position other than the origin. Reset the position
      // here, because node-level parsing will only override position if explicitly specified.


      lightNode.position.set(0, 0, 0);
      lightNode.decay = 2;
      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
      lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);
      dependency = Promise.resolve(lightNode);
      parser.cache.add(cacheKey, dependency);
      return dependency;
    }

    createNodeAttachment(nodeIndex) {
      var self = this;
      var parser = this.parser;
      var json = parser.json;
      var nodeDef = json.nodes[nodeIndex];
      var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
      var lightIndex = lightDef.light;
      if (lightIndex === undefined) return null;
      return this._loadLight(lightIndex).then(function (light) {
        return parser._getNodeRef(self.cache, lightIndex, light);
      });
    }

  }
  /**
   * Unlit Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
   */


  class GLTFMaterialsUnlitExtension {
    constructor() {
      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }

    getMaterialType() {
      return MeshBasicMaterial;
    }

    extendParams(materialParams, materialDef, parser) {
      var pending = [];
      materialParams.color = new Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      var metallicRoughness = materialDef.pbrMetallicRoughness;

      if (metallicRoughness) {
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }
      }

      return Promise.all(pending);
    }

  }
  /**
   * Clearcoat Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
   */


  class GLTFMaterialsClearcoatExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }

    getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }

    extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];

      if (extension.clearcoatFactor !== undefined) {
        materialParams.clearcoat = extension.clearcoatFactor;
      }

      if (extension.clearcoatTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));
      }

      if (extension.clearcoatRoughnessFactor !== undefined) {
        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
      }

      if (extension.clearcoatRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));
      }

      if (extension.clearcoatNormalTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));

        if (extension.clearcoatNormalTexture.scale !== undefined) {
          var scale = extension.clearcoatNormalTexture.scale;
          materialParams.clearcoatNormalScale = new Vector2(scale, scale);
        }
      }

      return Promise.all(pending);
    }

  }
  /**
   * Sheen Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
   */


  class GLTFMaterialsSheenExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
    }

    getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }

    extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      materialParams.sheenColor = new Color(0, 0, 0);
      materialParams.sheenRoughness = 0;
      materialParams.sheen = 1;
      var extension = materialDef.extensions[this.name];

      if (extension.sheenColorFactor !== undefined) {
        materialParams.sheenColor.fromArray(extension.sheenColorFactor);
      }

      if (extension.sheenRoughnessFactor !== undefined) {
        materialParams.sheenRoughness = extension.sheenRoughnessFactor;
      }

      if (extension.sheenColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture));
      }

      if (extension.sheenRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture));
      }

      return Promise.all(pending);
    }

  }
  /**
   * Transmission Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
   * Draft: https://github.com/KhronosGroup/glTF/pull/1698
   */


  class GLTFMaterialsTransmissionExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }

    getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }

    extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];

      if (extension.transmissionFactor !== undefined) {
        materialParams.transmission = extension.transmissionFactor;
      }

      if (extension.transmissionTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));
      }

      return Promise.all(pending);
    }

  }
  /**
   * Materials Volume Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
   */


  class GLTFMaterialsVolumeExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
    }

    getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }

    extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];
      materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

      if (extension.thicknessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));
      }

      materialParams.attenuationDistance = extension.attenuationDistance || 0;
      var colorArray = extension.attenuationColor || [1, 1, 1];
      materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
      return Promise.all(pending);
    }

  }
  /**
   * Materials ior Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
   */


  class GLTFMaterialsIorExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_IOR;
    }

    getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }

    extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var extension = materialDef.extensions[this.name];
      materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;
      return Promise.resolve();
    }

  }
  /**
   * Materials specular Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
   */


  class GLTFMaterialsSpecularExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
    }

    getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }

    extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];
      materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

      if (extension.specularTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));
      }

      var colorArray = extension.specularColorFactor || [1, 1, 1];
      materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);

      if (extension.specularColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture).then(function (texture) {
          texture.encoding = sRGBEncoding;
        }));
      }

      return Promise.all(pending);
    }

  }
  /**
   * BasisU Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
   */


  class GLTFTextureBasisUExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }

    loadTexture(textureIndex) {
      var parser = this.parser;
      var json = parser.json;
      var textureDef = json.textures[textureIndex];

      if (!textureDef.extensions || !textureDef.extensions[this.name]) {
        return null;
      }

      var extension = textureDef.extensions[this.name];
      var source = json.images[extension.source];
      var loader = parser.options.ktx2Loader;

      if (!loader) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
        } else {
          // Assumes that the extension is optional and that a fallback texture is present
          return null;
        }
      }

      return parser.loadTextureImage(textureIndex, source, loader);
    }

  }
  /**
   * WebP Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
   */


  class GLTFTextureWebPExtension {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
      this.isSupported = null;
    }

    loadTexture(textureIndex) {
      var name = this.name;
      var parser = this.parser;
      var json = parser.json;
      var textureDef = json.textures[textureIndex];

      if (!textureDef.extensions || !textureDef.extensions[name]) {
        return null;
      }

      var extension = textureDef.extensions[name];
      var source = json.images[extension.source];
      var loader = parser.textureLoader;

      if (source.uri) {
        var handler = parser.options.manager.getHandler(source.uri);
        if (handler !== null) loader = handler;
      }

      return this.detectSupport().then(function (isSupported) {
        if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);

        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
          throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
        } // Fall back to PNG or JPEG.


        return parser.loadTexture(textureIndex);
      });
    }

    detectSupport() {
      if (!this.isSupported) {
        this.isSupported = new Promise(function (resolve) {
          var image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all
          // WebP images, unfortunately.

          image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

          image.onload = image.onerror = function () {
            resolve(image.height === 1);
          };
        });
      }

      return this.isSupported;
    }

  }
  /**
   * meshopt BufferView Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
   */


  class GLTFMeshoptCompression {
    constructor(parser) {
      this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
      this.parser = parser;
    }

    loadBufferView(index) {
      var json = this.parser.json;
      var bufferView = json.bufferViews[index];

      if (bufferView.extensions && bufferView.extensions[this.name]) {
        var extensionDef = bufferView.extensions[this.name];
        var buffer = this.parser.getDependency('buffer', extensionDef.buffer);
        var decoder = this.parser.options.meshoptDecoder;

        if (!decoder || !decoder.supported) {
          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
            throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
          } else {
            // Assumes that the extension is optional and that fallback buffer data is present
            return null;
          }
        }

        return Promise.all([buffer, decoder.ready]).then(function (res) {
          var byteOffset = extensionDef.byteOffset || 0;
          var byteLength = extensionDef.byteLength || 0;
          var count = extensionDef.count;
          var stride = extensionDef.byteStride;
          var result = new ArrayBuffer(count * stride);
          var source = new Uint8Array(res[0], byteOffset, byteLength);
          decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
          return result;
        });
      } else {
        return null;
      }
    }

  }
  /* BINARY EXTENSION */


  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 0x4E4F534A,
    BIN: 0x004E4942
  };

  class GLTFBinaryExtension {
    constructor(data) {
      this.name = EXTENSIONS.KHR_BINARY_GLTF;
      this.content = null;
      this.body = null;
      var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
      this.header = {
        magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true)
      };

      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
        throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
      } else if (this.header.version < 2.0) {
        throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
      }

      var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
      var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
      var chunkIndex = 0;

      while (chunkIndex < chunkContentsLength) {
        var chunkLength = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        var chunkType = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;

        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
          var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
          this.content = LoaderUtils.decodeText(contentArray);
        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
          var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
          this.body = data.slice(byteOffset, byteOffset + chunkLength);
        } // Clients must ignore chunks with unknown types.


        chunkIndex += chunkLength;
      }

      if (this.content === null) {
        throw new Error('THREE.GLTFLoader: JSON content not found.');
      }
    }

  }
  /**
   * DRACO Mesh Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
   */


  class GLTFDracoMeshCompressionExtension {
    constructor(json, dracoLoader) {
      if (!dracoLoader) {
        throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
      }

      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
      this.json = json;
      this.dracoLoader = dracoLoader;
      this.dracoLoader.preload();
    }

    decodePrimitive(primitive, parser) {
      var json = this.json;
      var dracoLoader = this.dracoLoader;
      var bufferViewIndex = primitive.extensions[this.name].bufferView;
      var gltfAttributeMap = primitive.extensions[this.name].attributes;
      var threeAttributeMap = {};
      var attributeNormalizedMap = {};
      var attributeTypeMap = {};

      for (var attributeName in gltfAttributeMap) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
      }

      for (var _attributeName in primitive.attributes) {
        var _threeAttributeName = ATTRIBUTES[_attributeName] || _attributeName.toLowerCase();

        if (gltfAttributeMap[_attributeName] !== undefined) {
          var accessorDef = json.accessors[primitive.attributes[_attributeName]];
          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          attributeTypeMap[_threeAttributeName] = componentType;
          attributeNormalizedMap[_threeAttributeName] = accessorDef.normalized === true;
        }
      }

      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
        return new Promise(function (resolve) {
          dracoLoader.decodeDracoFile(bufferView, function (geometry) {
            for (var _attributeName2 in geometry.attributes) {
              var attribute = geometry.attributes[_attributeName2];
              var normalized = attributeNormalizedMap[_attributeName2];
              if (normalized !== undefined) attribute.normalized = normalized;
            }

            resolve(geometry);
          }, threeAttributeMap, attributeTypeMap);
        });
      });
    }

  }
  /**
   * Texture Transform Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
   */


  class GLTFTextureTransformExtension {
    constructor() {
      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }

    extendTexture(texture, transform) {
      if (transform.texCoord !== undefined) {
        console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
      }

      if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {
        // See https://github.com/mrdoob/three.js/issues/21819.
        return texture;
      }

      texture = texture.clone();

      if (transform.offset !== undefined) {
        texture.offset.fromArray(transform.offset);
      }

      if (transform.rotation !== undefined) {
        texture.rotation = transform.rotation;
      }

      if (transform.scale !== undefined) {
        texture.repeat.fromArray(transform.scale);
      }

      texture.needsUpdate = true;
      return texture;
    }

  }
  /**
   * Specular-Glossiness Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
   */

  /**
   * A sub class of StandardMaterial with some of the functionality
   * changed via the `onBeforeCompile` callback
   * @pailhead
   */


  class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
    constructor(params) {
      super();
      this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing

      var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
      var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
      var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
      var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
      var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\n');
      var uniforms = {
        specular: {
          value: new Color().setHex(0xffffff)
        },
        glossiness: {
          value: 1
        },
        specularMap: {
          value: null
        },
        glossinessMap: {
          value: null
        }
      };
      this._extraUniforms = uniforms;

      this.onBeforeCompile = function (shader) {
        for (var uniformName in uniforms) {
          shader.uniforms[uniformName] = uniforms[uniformName];
        }

        shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
      };

      Object.defineProperties(this, {
        specular: {
          get: function () {
            return uniforms.specular.value;
          },
          set: function (v) {
            uniforms.specular.value = v;
          }
        },
        specularMap: {
          get: function () {
            return uniforms.specularMap.value;
          },
          set: function (v) {
            uniforms.specularMap.value = v;

            if (v) {
              this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps
            } else {
              delete this.defines.USE_SPECULARMAP;
            }
          }
        },
        glossiness: {
          get: function () {
            return uniforms.glossiness.value;
          },
          set: function (v) {
            uniforms.glossiness.value = v;
          }
        },
        glossinessMap: {
          get: function () {
            return uniforms.glossinessMap.value;
          },
          set: function (v) {
            uniforms.glossinessMap.value = v;

            if (v) {
              this.defines.USE_GLOSSINESSMAP = '';
              this.defines.USE_UV = '';
            } else {
              delete this.defines.USE_GLOSSINESSMAP;
              delete this.defines.USE_UV;
            }
          }
        }
      });
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      this.setValues(params);
    }

    copy(source) {
      super.copy(source);
      this.specularMap = source.specularMap;
      this.specular.copy(source.specular);
      this.glossinessMap = source.glossinessMap;
      this.glossiness = source.glossiness;
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      return this;
    }

  }

  class GLTFMaterialsPbrSpecularGlossinessExtension {
    constructor() {
      this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
      this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];
    }

    getMaterialType() {
      return GLTFMeshStandardSGMaterial;
    }

    extendParams(materialParams, materialDef, parser) {
      var pbrSpecularGlossiness = materialDef.extensions[this.name];
      materialParams.color = new Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      var pending = [];

      if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
        var array = pbrSpecularGlossiness.diffuseFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
      }

      materialParams.emissive = new Color(0.0, 0.0, 0.0);
      materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
      materialParams.specular = new Color(1.0, 1.0, 1.0);

      if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
      }

      if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
        var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
        pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
        pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
      }

      return Promise.all(pending);
    }

    createMaterial(materialParams) {
      var material = new GLTFMeshStandardSGMaterial(materialParams);
      material.fog = true;
      material.color = materialParams.color;
      material.map = materialParams.map === undefined ? null : materialParams.map;
      material.lightMap = null;
      material.lightMapIntensity = 1.0;
      material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
      material.aoMapIntensity = 1.0;
      material.emissive = materialParams.emissive;
      material.emissiveIntensity = 1.0;
      material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
      material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
      material.bumpScale = 1;
      material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
      material.normalMapType = TangentSpaceNormalMap;
      if (materialParams.normalScale) material.normalScale = materialParams.normalScale;
      material.displacementMap = null;
      material.displacementScale = 1;
      material.displacementBias = 0;
      material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
      material.specular = materialParams.specular;
      material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
      material.glossiness = materialParams.glossiness;
      material.alphaMap = null;
      material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
      material.envMapIntensity = 1.0;
      material.refractionRatio = 0.98;
      return material;
    }

  }
  /**
   * Mesh Quantization Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
   */


  class GLTFMeshQuantizationExtension {
    constructor() {
      this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    }

  }
  /*********************************/

  /********** INTERPOLATION ********/

  /*********************************/
  // Spline Interpolation
  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


  class GLTFCubicSplineInterpolant extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }

    copySampleValue_(index) {
      // Copies a sample value to the result buffer. See description of glTF
      // CUBICSPLINE values layout in interpolate_() function below.
      var result = this.resultBuffer,
          values = this.sampleValues,
          valueSize = this.valueSize,
          offset = index * valueSize * 3 + valueSize;

      for (var i = 0; i !== valueSize; i++) {
        result[i] = values[offset + i];
      }

      return result;
    }

  }

  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
    var result = this.resultBuffer;
    var values = this.sampleValues;
    var stride = this.valueSize;
    var stride2 = stride * 2;
    var stride3 = stride * 3;
    var td = t1 - t0;
    var p = (t - t0) / td;
    var pp = p * p;
    var ppp = pp * p;
    var offset1 = i1 * stride3;
    var offset0 = offset1 - stride3;
    var s2 = -2 * ppp + 3 * pp;
    var s3 = ppp - pp;
    var s0 = 1 - s2;
    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

    for (var i = 0; i !== stride; i++) {
      var p0 = values[offset0 + i + stride]; // splineVertex_k

      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)

      var p1 = values[offset1 + i + stride]; // splineVertex_k+1

      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }

    return result;
  };

  var _q = new Quaternion();

  class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
    interpolate_(i1, t0, t, t1) {
      var result = super.interpolate_(i1, t0, t, t1);

      _q.fromArray(result).normalize().toArray(result);

      return result;
    }

  }
  /*********************************/

  /********** INTERNALS ************/

  /*********************************/

  /* CONSTANTS */


  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping
  };
  var WEBGL_TYPE_SIZES = {
    'SCALAR': 1,
    'VEC2': 2,
    'VEC3': 3,
    'VEC4': 4,
    'MAT2': 4,
    'MAT3': 9,
    'MAT4': 16
  };
  var ATTRIBUTES = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv2',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex'
  };
  var PATH_PROPERTIES = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  };
  var INTERPOLATION = {
    CUBICSPLINE: undefined,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: 'OPAQUE',
    MASK: 'MASK',
    BLEND: 'BLEND'
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   */

  function createDefaultMaterial(cache) {
    if (cache['DefaultMaterial'] === undefined) {
      cache['DefaultMaterial'] = new MeshStandardMaterial({
        color: 0xFFFFFF,
        emissive: 0x000000,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }

    return cache['DefaultMaterial'];
  }

  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    // Add unknown glTF extensions to an object's userData.
    for (var name in objectDef.extensions) {
      if (knownExtensions[name] === undefined) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  /**
   * @param {Object3D|Material|BufferGeometry} object
   * @param {GLTF.definition} gltfDef
   */


  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== undefined) {
      if (typeof gltfDef.extras === 'object') {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
      }
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   *
   * @param {BufferGeometry} geometry
   * @param {Array<GLTF.Target>} targets
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */


  function addMorphTargets(geometry, targets, parser) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      if (target.POSITION !== undefined) hasMorphPosition = true;
      if (target.NORMAL !== undefined) hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal) break;
    }

    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
    var pendingPositionAccessors = [];
    var pendingNormalAccessors = [];

    for (var _i2 = 0, _il = targets.length; _i2 < _il; _i2++) {
      var _target = targets[_i2];

      if (hasMorphPosition) {
        var pendingAccessor = _target.POSITION !== undefined ? parser.getDependency('accessor', _target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }

      if (hasMorphNormal) {
        var _pendingAccessor = _target.NORMAL !== undefined ? parser.getDependency('accessor', _target.NORMAL) : geometry.attributes.normal;

        pendingNormalAccessors.push(_pendingAccessor);
      }
    }

    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
      var morphPositions = accessors[0];
      var morphNormals = accessors[1];
      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  /**
   * @param {Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   */


  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();

    if (meshDef.weights !== undefined) {
      for (var i = 0, il = meshDef.weights.length; i < il; i++) {
        mesh.morphTargetInfluences[i] = meshDef.weights[i];
      }
    } // .extras has user-defined data, so check that .extras.targetNames is an array.


    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      var targetNames = meshDef.extras.targetNames;

      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};

        for (var _i3 = 0, _il2 = targetNames.length; _i3 < _il2; _i3++) {
          mesh.morphTargetDictionary[targetNames[_i3]] = _i3;
        }
      } else {
        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
      }
    }
  }

  function createPrimitiveKey(primitiveDef) {
    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    var geometryKey;

    if (dracoExtension) {
      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
    }

    return geometryKey;
  }

  function createAttributesKey(attributes) {
    var attributesKey = '';
    var keys = Object.keys(attributes).sort();

    for (var i = 0, il = keys.length; i < il; i++) {
      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
    }

    return attributesKey;
  }

  function getNormalizedComponentScale(constructor) {
    // Reference:
    // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
    switch (constructor) {
      case Int8Array:
        return 1 / 127;

      case Uint8Array:
        return 1 / 255;

      case Int16Array:
        return 1 / 32767;

      case Uint16Array:
        return 1 / 65535;

      default:
        throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
    }
  }
  /* GLTF PARSER */


  class GLTFParser {
    constructor() {
      var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.json = json;
      this.extensions = {};
      this.plugins = {};
      this.options = options; // loader object cache

      this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements

      this.associations = new Map(); // BufferGeometry caching

      this.primitiveCache = {}; // Object3D instance caches

      this.meshCache = {
        refs: {},
        uses: {}
      };
      this.cameraCache = {
        refs: {},
        uses: {}
      };
      this.lightCache = {
        refs: {},
        uses: {}
      };
      this.textureCache = {}; // Track node names, to ensure no duplicates

      this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
      // expensive work of uploading a texture to the GPU off the main thread.

      if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {
        this.textureLoader = new ImageBitmapLoader(this.options.manager);
      } else {
        this.textureLoader = new TextureLoader(this.options.manager);
      }

      this.textureLoader.setCrossOrigin(this.options.crossOrigin);
      this.textureLoader.setRequestHeader(this.options.requestHeader);
      this.fileLoader = new FileLoader(this.options.manager);
      this.fileLoader.setResponseType('arraybuffer');

      if (this.options.crossOrigin === 'use-credentials') {
        this.fileLoader.setWithCredentials(true);
      }
    }

    setExtensions(extensions) {
      this.extensions = extensions;
    }

    setPlugins(plugins) {
      this.plugins = plugins;
    }

    parse(onLoad, onError) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions; // Clear the loader cache

      this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

      this._invokeAll(function (ext) {
        return ext._markDefs && ext._markDefs();
      });

      Promise.all(this._invokeAll(function (ext) {
        return ext.beforeRoot && ext.beforeRoot();
      })).then(function () {
        return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);
      }).then(function (dependencies) {
        var result = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser: parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, result, json);
        assignExtrasToUserData(result, json);
        Promise.all(parser._invokeAll(function (ext) {
          return ext.afterRoot && ext.afterRoot(result);
        })).then(function () {
          onLoad(result);
        });
      }).catch(onError);
    }
    /**
     * Marks the special nodes/meshes in json for efficient parse.
     */


    _markDefs() {
      var nodeDefs = this.json.nodes || [];
      var skinDefs = this.json.skins || [];
      var meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an
      // Object3D. Use the skins' joint references to mark bones.

      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
        var joints = skinDefs[skinIndex].joints;

        for (var i = 0, il = joints.length; i < il; i++) {
          nodeDefs[joints[i]].isBone = true;
        }
      } // Iterate over all nodes, marking references to shared resources,
      // as well as skeleton joints.


      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];

        if (nodeDef.mesh !== undefined) {
          this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is
          // a SkinnedMesh or Mesh. Use the node's mesh reference
          // to mark SkinnedMesh if node has skin.


          if (nodeDef.skin !== undefined) {
            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
          }
        }

        if (nodeDef.camera !== undefined) {
          this._addNodeRef(this.cameraCache, nodeDef.camera);
        }
      }
    }
    /**
     * Counts references to shared node / Object3D resources. These resources
     * can be reused, or "instantiated", at multiple nodes in the scene
     * hierarchy. Mesh, Camera, and Light instances are instantiated and must
     * be marked. Non-scenegraph resources (like Materials, Geometries, and
     * Textures) can be reused directly and are not marked here.
     *
     * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
     */


    _addNodeRef(cache, index) {
      if (index === undefined) return;

      if (cache.refs[index] === undefined) {
        cache.refs[index] = cache.uses[index] = 0;
      }

      cache.refs[index]++;
    }
    /** Returns a reference to a shared resource, cloning it if necessary. */


    _getNodeRef(cache, index, object) {
      if (cache.refs[index] <= 1) return object;
      var ref = object.clone(); // Propagates mappings to the cloned object, prevents mappings on the
      // original object from being lost.

      var updateMappings = (original, clone) => {
        var mappings = this.associations.get(original);

        if (mappings != null) {
          this.associations.set(clone, mappings);
        }

        for (var [i, child] of original.children.entries()) {
          updateMappings(child, clone.children[i]);
        }
      };

      updateMappings(object, ref);
      ref.name += '_instance_' + cache.uses[index]++;
      return ref;
    }

    _invokeOne(func) {
      var extensions = Object.values(this.plugins);
      extensions.push(this);

      for (var i = 0; i < extensions.length; i++) {
        var result = func(extensions[i]);
        if (result) return result;
      }

      return null;
    }

    _invokeAll(func) {
      var extensions = Object.values(this.plugins);
      extensions.unshift(this);
      var pending = [];

      for (var i = 0; i < extensions.length; i++) {
        var result = func(extensions[i]);
        if (result) pending.push(result);
      }

      return pending;
    }
    /**
     * Requests the specified dependency asynchronously, with caching.
     * @param {string} type
     * @param {number} index
     * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
     */


    getDependency(type, index) {
      var cacheKey = type + ':' + index;
      var dependency = this.cache.get(cacheKey);

      if (!dependency) {
        switch (type) {
          case 'scene':
            dependency = this.loadScene(index);
            break;

          case 'node':
            dependency = this.loadNode(index);
            break;

          case 'mesh':
            dependency = this._invokeOne(function (ext) {
              return ext.loadMesh && ext.loadMesh(index);
            });
            break;

          case 'accessor':
            dependency = this.loadAccessor(index);
            break;

          case 'bufferView':
            dependency = this._invokeOne(function (ext) {
              return ext.loadBufferView && ext.loadBufferView(index);
            });
            break;

          case 'buffer':
            dependency = this.loadBuffer(index);
            break;

          case 'material':
            dependency = this._invokeOne(function (ext) {
              return ext.loadMaterial && ext.loadMaterial(index);
            });
            break;

          case 'texture':
            dependency = this._invokeOne(function (ext) {
              return ext.loadTexture && ext.loadTexture(index);
            });
            break;

          case 'skin':
            dependency = this.loadSkin(index);
            break;

          case 'animation':
            dependency = this.loadAnimation(index);
            break;

          case 'camera':
            dependency = this.loadCamera(index);
            break;

          default:
            throw new Error('Unknown type: ' + type);
        }

        this.cache.add(cacheKey, dependency);
      }

      return dependency;
    }
    /**
     * Requests all dependencies of the specified type asynchronously, with caching.
     * @param {string} type
     * @return {Promise<Array<Object>>}
     */


    getDependencies(type) {
      var dependencies = this.cache.get(type);

      if (!dependencies) {
        var parser = this;
        var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
        dependencies = Promise.all(defs.map(function (def, index) {
          return parser.getDependency(type, index);
        }));
        this.cache.add(type, dependencies);
      }

      return dependencies;
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferIndex
     * @return {Promise<ArrayBuffer>}
     */


    loadBuffer(bufferIndex) {
      var bufferDef = this.json.buffers[bufferIndex];
      var loader = this.fileLoader;

      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
      } // If present, GLB container is required to be the first buffer.


      if (bufferDef.uri === undefined && bufferIndex === 0) {
        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
      }

      var options = this.options;
      return new Promise(function (resolve, reject) {
        loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
          reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
        });
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferViewIndex
     * @return {Promise<ArrayBuffer>}
     */


    loadBufferView(bufferViewIndex) {
      var bufferViewDef = this.json.bufferViews[bufferViewIndex];
      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
        var byteLength = bufferViewDef.byteLength || 0;
        var byteOffset = bufferViewDef.byteOffset || 0;
        return buffer.slice(byteOffset, byteOffset + byteLength);
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
     * @param {number} accessorIndex
     * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
     */


    loadAccessor(accessorIndex) {
      var parser = this;
      var json = this.json;
      var accessorDef = this.json.accessors[accessorIndex];

      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
        // Ignore empty accessors, which may be used to declare runtime
        // information about attributes coming from another source (e.g. Draco
        // compression extension).
        return Promise.resolve(null);
      }

      var pendingBufferViews = [];

      if (accessorDef.bufferView !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
      } else {
        pendingBufferViews.push(null);
      }

      if (accessorDef.sparse !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
      }

      return Promise.all(pendingBufferViews).then(function (bufferViews) {
        var bufferView = bufferViews[0];
        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

        var elementBytes = TypedArray.BYTES_PER_ELEMENT;
        var itemBytes = elementBytes * itemSize;
        var byteOffset = accessorDef.byteOffset || 0;
        var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
        var normalized = accessorDef.normalized === true;
        var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

        if (byteStride && byteStride !== itemBytes) {
          // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
          // This makes sure that IBA.count reflects accessor.count properly
          var ibSlice = Math.floor(byteOffset / byteStride);
          var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
          var ib = parser.cache.get(ibCacheKey);

          if (!ib) {
            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.

            ib = new InterleavedBuffer(array, byteStride / elementBytes);
            parser.cache.add(ibCacheKey, ib);
          }

          bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
        } else {
          if (bufferView === null) {
            array = new TypedArray(accessorDef.count * itemSize);
          } else {
            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
          }

          bufferAttribute = new BufferAttribute(array, itemSize, normalized);
        } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


        if (accessorDef.sparse !== undefined) {
          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

          if (bufferView !== null) {
            // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
            bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
          }

          for (var i = 0, il = sparseIndices.length; i < il; i++) {
            var index = sparseIndices[i];
            bufferAttribute.setX(index, sparseValues[i * itemSize]);
            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
            if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
          }
        }

        return bufferAttribute;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
     * @param {number} textureIndex
     * @return {Promise<THREE.Texture>}
     */


    loadTexture(textureIndex) {
      var json = this.json;
      var options = this.options;
      var textureDef = json.textures[textureIndex];
      var source = json.images[textureDef.source];
      var loader = this.textureLoader;

      if (source.uri) {
        var handler = options.manager.getHandler(source.uri);
        if (handler !== null) loader = handler;
      }

      return this.loadTextureImage(textureIndex, source, loader);
    }

    loadTextureImage(textureIndex, source, loader) {
      var parser = this;
      var json = this.json;
      var options = this.options;
      var textureDef = json.textures[textureIndex];
      var cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;

      if (this.textureCache[cacheKey]) {
        // See https://github.com/mrdoob/three.js/issues/21559.
        return this.textureCache[cacheKey];
      }

      var URL = self.URL || self.webkitURL;
      var sourceURI = source.uri || '';
      var isObjectURL = false;

      if (source.bufferView !== undefined) {
        // Load binary image data from bufferView, if provided.
        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
          isObjectURL = true;
          var blob = new Blob([bufferView], {
            type: source.mimeType
          });
          sourceURI = URL.createObjectURL(blob);
          return sourceURI;
        });
      } else if (source.uri === undefined) {
        throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');
      }

      var promise = Promise.resolve(sourceURI).then(function (sourceURI) {
        return new Promise(function (resolve, reject) {
          var onLoad = resolve;

          if (loader.isImageBitmapLoader === true) {
            onLoad = function (imageBitmap) {
              var texture = new Texture(imageBitmap);
              texture.needsUpdate = true;
              resolve(texture);
            };
          }

          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject);
        });
      }).then(function (texture) {
        // Clean up resources and configure Texture.
        if (isObjectURL === true) {
          URL.revokeObjectURL(sourceURI);
        }

        texture.flipY = false;
        if (textureDef.name) texture.name = textureDef.name;
        var samplers = json.samplers || {};
        var sampler = samplers[textureDef.sampler] || {};
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
        parser.associations.set(texture, {
          textures: textureIndex
        });
        return texture;
      }).catch(function () {
        console.error('THREE.GLTFLoader: Couldn\'t load texture', sourceURI);
        return null;
      });
      this.textureCache[cacheKey] = promise;
      return promise;
    }
    /**
     * Asynchronously assigns a texture to the given material parameters.
     * @param {Object} materialParams
     * @param {string} mapName
     * @param {Object} mapDef
     * @return {Promise<Texture>}
     */


    assignTexture(materialParams, mapName, mapDef) {
      var parser = this;
      return this.getDependency('texture', mapDef.index).then(function (texture) {
        // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
        // However, we will copy UV set 0 to UV set 1 on demand for aoMap
        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
          console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
        }

        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
          var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

          if (transform) {
            var gltfReference = parser.associations.get(texture);
            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
            parser.associations.set(texture, gltfReference);
          }
        }

        materialParams[mapName] = texture;
        return texture;
      });
    }
    /**
     * Assigns final material to a Mesh, Line, or Points instance. The instance
     * already has a material (generated from the glTF material options alone)
     * but reuse of the same glTF material may require multiple threejs materials
     * to accommodate different primitive types, defines, etc. New materials will
     * be created if necessary, and reused from a cache.
     * @param  {Object3D} mesh Mesh, Line, or Points instance.
     */


    assignFinalMaterial(mesh) {
      var geometry = mesh.geometry;
      var material = mesh.material;
      var useDerivativeTangents = geometry.attributes.tangent === undefined;
      var useVertexColors = geometry.attributes.color !== undefined;
      var useFlatShading = geometry.attributes.normal === undefined;

      if (mesh.isPoints) {
        var cacheKey = 'PointsMaterial:' + material.uuid;
        var pointsMaterial = this.cache.get(cacheKey);

        if (!pointsMaterial) {
          pointsMaterial = new PointsMaterial();
          Material.prototype.copy.call(pointsMaterial, material);
          pointsMaterial.color.copy(material.color);
          pointsMaterial.map = material.map;
          pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

          this.cache.add(cacheKey, pointsMaterial);
        }

        material = pointsMaterial;
      } else if (mesh.isLine) {
        var _cacheKey = 'LineBasicMaterial:' + material.uuid;

        var lineMaterial = this.cache.get(_cacheKey);

        if (!lineMaterial) {
          lineMaterial = new LineBasicMaterial();
          Material.prototype.copy.call(lineMaterial, material);
          lineMaterial.color.copy(material.color);
          this.cache.add(_cacheKey, lineMaterial);
        }

        material = lineMaterial;
      } // Clone the material if it will be modified


      if (useDerivativeTangents || useVertexColors || useFlatShading) {
        var _cacheKey2 = 'ClonedMaterial:' + material.uuid + ':';

        if (material.isGLTFSpecularGlossinessMaterial) _cacheKey2 += 'specular-glossiness:';
        if (useDerivativeTangents) _cacheKey2 += 'derivative-tangents:';
        if (useVertexColors) _cacheKey2 += 'vertex-colors:';
        if (useFlatShading) _cacheKey2 += 'flat-shading:';
        var cachedMaterial = this.cache.get(_cacheKey2);

        if (!cachedMaterial) {
          cachedMaterial = material.clone();
          if (useVertexColors) cachedMaterial.vertexColors = true;
          if (useFlatShading) cachedMaterial.flatShading = true;

          if (useDerivativeTangents) {
            // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
            if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
            if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
          }

          this.cache.add(_cacheKey2, cachedMaterial);
          this.associations.set(cachedMaterial, this.associations.get(material));
        }

        material = cachedMaterial;
      } // workarounds for mesh and geometry


      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
        geometry.setAttribute('uv2', geometry.attributes.uv);
      }

      mesh.material = material;
    }

    getMaterialType() {
      return MeshStandardMaterial;
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
     * @param {number} materialIndex
     * @return {Promise<Material>}
     */


    loadMaterial(materialIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var materialDef = json.materials[materialIndex];
      var materialType;
      var materialParams = {};
      var materialExtensions = materialDef.extensions || {};
      var pending = [];

      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        materialType = sgExtension.getMaterialType();
        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
        materialType = kmuExtension.getMaterialType();
        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
      } else {
        // Specification:
        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
        var metallicRoughness = materialDef.pbrMetallicRoughness || {};
        materialParams.color = new Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;

        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }

        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

        if (metallicRoughness.metallicRoughnessTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
        }

        materialType = this._invokeOne(function (ext) {
          return ext.getMaterialType && ext.getMaterialType(materialIndex);
        });
        pending.push(Promise.all(this._invokeAll(function (ext) {
          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
        })));
      }

      if (materialDef.doubleSided === true) {
        materialParams.side = DoubleSide;
      }

      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

      if (alphaMode === ALPHA_MODES.BLEND) {
        materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706

        materialParams.depthWrite = false;
      } else {
        materialParams.format = RGBFormat;
        materialParams.transparent = false;

        if (alphaMode === ALPHA_MODES.MASK) {
          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
        }
      }

      if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
        materialParams.normalScale = new Vector2(1, 1);

        if (materialDef.normalTexture.scale !== undefined) {
          var scale = materialDef.normalTexture.scale;
          materialParams.normalScale.set(scale, scale);
        }
      }

      if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

        if (materialDef.occlusionTexture.strength !== undefined) {
          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
      }

      if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {
        materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
      }

      if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
      }

      return Promise.all(pending).then(function () {
        var material;

        if (materialType === GLTFMeshStandardSGMaterial) {
          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
        } else {
          material = new materialType(materialParams);
        }

        if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.

        if (material.map) material.map.encoding = sRGBEncoding;
        if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;
        assignExtrasToUserData(material, materialDef);
        parser.associations.set(material, {
          materials: materialIndex
        });
        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
        return material;
      });
    }
    /** When Object3D instances are targeted by animation, they need unique names. */


    createUniqueName(originalName) {
      var sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');
      var name = sanitizedName;

      for (var i = 1; this.nodeNamesUsed[name]; ++i) {
        name = sanitizedName + '_' + i;
      }

      this.nodeNamesUsed[name] = true;
      return name;
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
     *
     * Creates BufferGeometries from primitives.
     *
     * @param {Array<GLTF.Primitive>} primitives
     * @return {Promise<Array<BufferGeometry>>}
     */


    loadGeometries(primitives) {
      var parser = this;
      var extensions = this.extensions;
      var cache = this.primitiveCache;

      function createDracoPrimitive(primitive) {
        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
          return addPrimitiveAttributes(geometry, primitive, parser);
        });
      }

      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var primitive = primitives[i];
        var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry

        var cached = cache[cacheKey];

        if (cached) {
          // Use the cached geometry if it exists
          pending.push(cached.promise);
        } else {
          var geometryPromise = void 0;

          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            // Use DRACO geometry if available
            geometryPromise = createDracoPrimitive(primitive);
          } else {
            // Otherwise create a new geometry
            geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
          } // Cache this geometry


          cache[cacheKey] = {
            primitive: primitive,
            promise: geometryPromise
          };
          pending.push(geometryPromise);
        }
      }

      return Promise.all(pending);
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
     * @param {number} meshIndex
     * @return {Promise<Group|Mesh|SkinnedMesh>}
     */


    loadMesh(meshIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var meshDef = json.meshes[meshIndex];
      var primitives = meshDef.primitives;
      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
        pending.push(material);
      }

      pending.push(parser.loadGeometries(primitives));
      return Promise.all(pending).then(function (results) {
        var materials = results.slice(0, results.length - 1);
        var geometries = results[results.length - 1];
        var meshes = [];

        for (var _i4 = 0, _il3 = geometries.length; _i4 < _il3; _i4++) {
          var geometry = geometries[_i4];
          var primitive = primitives[_i4]; // 1. create Mesh

          var mesh = void 0;
          var _material = materials[_i4];

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
            // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, _material) : new Mesh(geometry, _material);

            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
              // we normalize floating point skin weight array to fix malformed assets (see #15319)
              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
              mesh.normalizeSkinWeights();
            }

            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new LineSegments(geometry, _material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new Line(geometry, _material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new LineLoop(geometry, _material);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new Points(geometry, _material);
          } else {
            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
          }

          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }

          mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);
          assignExtrasToUserData(mesh, meshDef);
          if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
          parser.assignFinalMaterial(mesh);
          meshes.push(mesh);
        }

        for (var _i5 = 0, _il4 = meshes.length; _i5 < _il4; _i5++) {
          parser.associations.set(meshes[_i5], {
            meshes: meshIndex,
            primitives: _i5
          });
        }

        if (meshes.length === 1) {
          return meshes[0];
        }

        var group = new Group();
        parser.associations.set(group, {
          meshes: meshIndex
        });

        for (var _i6 = 0, _il5 = meshes.length; _i6 < _il5; _i6++) {
          group.add(meshes[_i6]);
        }

        return group;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
     * @param {number} cameraIndex
     * @return {Promise<THREE.Camera>}
     */


    loadCamera(cameraIndex) {
      var camera;
      var cameraDef = this.json.cameras[cameraIndex];
      var params = cameraDef[cameraDef.type];

      if (!params) {
        console.warn('THREE.GLTFLoader: Missing camera parameters.');
        return;
      }

      if (cameraDef.type === 'perspective') {
        camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
      } else if (cameraDef.type === 'orthographic') {
        camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
      }

      if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
      assignExtrasToUserData(camera, cameraDef);
      return Promise.resolve(camera);
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
     * @param {number} skinIndex
     * @return {Promise<Object>}
     */


    loadSkin(skinIndex) {
      var skinDef = this.json.skins[skinIndex];
      var skinEntry = {
        joints: skinDef.joints
      };

      if (skinDef.inverseBindMatrices === undefined) {
        return Promise.resolve(skinEntry);
      }

      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
        skinEntry.inverseBindMatrices = accessor;
        return skinEntry;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
     * @param {number} animationIndex
     * @return {Promise<AnimationClip>}
     */


    loadAnimation(animationIndex) {
      var json = this.json;
      var animationDef = json.animations[animationIndex];
      var pendingNodes = [];
      var pendingInputAccessors = [];
      var pendingOutputAccessors = [];
      var pendingSamplers = [];
      var pendingTargets = [];

      for (var i = 0, il = animationDef.channels.length; i < il; i++) {
        var channel = animationDef.channels[i];
        var sampler = animationDef.samplers[channel.sampler];
        var target = channel.target;
        var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

        var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
        var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
        pendingNodes.push(this.getDependency('node', name));
        pendingInputAccessors.push(this.getDependency('accessor', input));
        pendingOutputAccessors.push(this.getDependency('accessor', output));
        pendingSamplers.push(sampler);
        pendingTargets.push(target);
      }

      return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
        var nodes = dependencies[0];
        var inputAccessors = dependencies[1];
        var outputAccessors = dependencies[2];
        var samplers = dependencies[3];
        var targets = dependencies[4];
        var tracks = [];

        var _loop = function (_i7, _il6) {
          var node = nodes[_i7];
          var inputAccessor = inputAccessors[_i7];
          var outputAccessor = outputAccessors[_i7];
          var sampler = samplers[_i7];
          var target = targets[_i7];
          if (node === undefined) return "continue";
          node.updateMatrix();
          node.matrixAutoUpdate = true;
          var TypedKeyframeTrack = void 0;

          switch (PATH_PROPERTIES[target.path]) {
            case PATH_PROPERTIES.weights:
              TypedKeyframeTrack = NumberKeyframeTrack;
              break;

            case PATH_PROPERTIES.rotation:
              TypedKeyframeTrack = QuaternionKeyframeTrack;
              break;

            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
            default:
              TypedKeyframeTrack = VectorKeyframeTrack;
              break;
          }

          var targetName = node.name ? node.name : node.uuid;
          var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
          var targetNames = [];

          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
            // Node may be a Group (glTF mesh with several primitives) or a Mesh.
            node.traverse(function (object) {
              if (object.isMesh === true && object.morphTargetInfluences) {
                targetNames.push(object.name ? object.name : object.uuid);
              }
            });
          } else {
            targetNames.push(targetName);
          }

          var outputArray = outputAccessor.array;

          if (outputAccessor.normalized) {
            var scale = getNormalizedComponentScale(outputArray.constructor);
            var scaled = new Float32Array(outputArray.length);

            for (var j = 0, jl = outputArray.length; j < jl; j++) {
              scaled[j] = outputArray[j] * scale;
            }

            outputArray = scaled;
          }

          for (var _j = 0, _jl = targetNames.length; _j < _jl; _j++) {
            var track = new TypedKeyframeTrack(targetNames[_j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.

            if (sampler.interpolation === 'CUBICSPLINE') {
              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                // must be divided by three to get the interpolant's sampleSize argument.
                var interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
              }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.


              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
            }

            tracks.push(track);
          }
        };

        for (var _i7 = 0, _il6 = nodes.length; _i7 < _il6; _i7++) {
          var _ret = _loop(_i7);

          if (_ret === "continue") continue;
        }

        var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
        return new AnimationClip(name, undefined, tracks);
      });
    }

    createNodeMesh(nodeIndex) {
      var json = this.json;
      var parser = this;
      var nodeDef = json.nodes[nodeIndex];
      if (nodeDef.mesh === undefined) return null;
      return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
        var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.


        if (nodeDef.weights !== undefined) {
          node.traverse(function (o) {
            if (!o.isMesh) return;

            for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
              o.morphTargetInfluences[i] = nodeDef.weights[i];
            }
          });
        }

        return node;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
     * @param {number} nodeIndex
     * @return {Promise<Object3D>}
     */


    loadNode(nodeIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var parser = this;
      var nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.

      var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';
      return function () {
        var pending = [];

        var meshPromise = parser._invokeOne(function (ext) {
          return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
        });

        if (meshPromise) {
          pending.push(meshPromise);
        }

        if (nodeDef.camera !== undefined) {
          pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {
            return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
          }));
        }

        parser._invokeAll(function (ext) {
          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
        }).forEach(function (promise) {
          pending.push(promise);
        });

        return Promise.all(pending);
      }().then(function (objects) {
        var node; // .isBone isn't in glTF spec. See ._markDefs

        if (nodeDef.isBone === true) {
          node = new Bone();
        } else if (objects.length > 1) {
          node = new Group();
        } else if (objects.length === 1) {
          node = objects[0];
        } else {
          node = new Object3D();
        }

        if (node !== objects[0]) {
          for (var i = 0, il = objects.length; i < il; i++) {
            node.add(objects[i]);
          }
        }

        if (nodeDef.name) {
          node.userData.name = nodeDef.name;
          node.name = nodeName;
        }

        assignExtrasToUserData(node, nodeDef);
        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

        if (nodeDef.matrix !== undefined) {
          var matrix = new Matrix4();
          matrix.fromArray(nodeDef.matrix);
          node.applyMatrix4(matrix);
        } else {
          if (nodeDef.translation !== undefined) {
            node.position.fromArray(nodeDef.translation);
          }

          if (nodeDef.rotation !== undefined) {
            node.quaternion.fromArray(nodeDef.rotation);
          }

          if (nodeDef.scale !== undefined) {
            node.scale.fromArray(nodeDef.scale);
          }
        }

        if (!parser.associations.has(node)) {
          parser.associations.set(node, {});
        }

        parser.associations.get(node).nodes = nodeIndex;
        return node;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
     * @param {number} sceneIndex
     * @return {Promise<Group>}
     */


    loadScene(sceneIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var sceneDef = this.json.scenes[sceneIndex];
      var parser = this; // Loader returns Group, not Scene.
      // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172

      var scene = new Group();
      if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
      assignExtrasToUserData(scene, sceneDef);
      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
      var nodeIds = sceneDef.nodes || [];
      var pending = [];

      for (var i = 0, il = nodeIds.length; i < il; i++) {
        pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));
      }

      return Promise.all(pending).then(function () {
        // Removes dangling associations, associations that reference a node that
        // didn't make it into the scene.
        var reduceAssociations = node => {
          var reducedAssociations = new Map();

          for (var [key, value] of parser.associations) {
            if (key instanceof Material || key instanceof Texture) {
              reducedAssociations.set(key, value);
            }
          }

          node.traverse(node => {
            var mappings = parser.associations.get(node);

            if (mappings != null) {
              reducedAssociations.set(node, mappings);
            }
          });
          return reducedAssociations;
        };

        parser.associations = reduceAssociations(scene);
        return scene;
      });
    }

  }

  function buildNodeHierarchy(nodeId, parentObject, json, parser) {
    var nodeDef = json.nodes[nodeId];
    return parser.getDependency('node', nodeId).then(function (node) {
      if (nodeDef.skin === undefined) return node; // build skeleton here as well

      var skinEntry;
      return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
        skinEntry = skin;
        var pendingJoints = [];

        for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
          pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
        }

        return Promise.all(pendingJoints);
      }).then(function (jointNodes) {
        node.traverse(function (mesh) {
          if (!mesh.isMesh) return;
          var bones = [];
          var boneInverses = [];

          for (var j = 0, jl = jointNodes.length; j < jl; j++) {
            var jointNode = jointNodes[j];

            if (jointNode) {
              bones.push(jointNode);
              var mat = new Matrix4();

              if (skinEntry.inverseBindMatrices !== undefined) {
                mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
              }

              boneInverses.push(mat);
            } else {
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
            }
          }

          mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
        });
        return node;
      });
    }).then(function (node) {
      // build node hierachy
      parentObject.add(node);
      var pending = [];

      if (nodeDef.children) {
        var children = nodeDef.children;

        for (var i = 0, il = children.length; i < il; i++) {
          var child = children[i];
          pending.push(buildNodeHierarchy(child, node, json, parser));
        }
      }

      return Promise.all(pending);
    });
  }
  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   */


  function computeBounds(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var box = new Box3();

    if (attributes.POSITION !== undefined) {
      var accessor = parser.json.accessors[attributes.POSITION];
      var min = accessor.min;
      var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

      if (min !== undefined && max !== undefined) {
        box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));

        if (accessor.normalized) {
          var boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
          box.min.multiplyScalar(boxScale);
          box.max.multiplyScalar(boxScale);
        }
      } else {
        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
        return;
      }
    } else {
      return;
    }

    var targets = primitiveDef.targets;

    if (targets !== undefined) {
      var maxDisplacement = new Vector3();
      var vector = new Vector3();

      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];

        if (target.POSITION !== undefined) {
          var _accessor = parser.json.accessors[target.POSITION];
          var _min = _accessor.min;
          var _max = _accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

          if (_min !== undefined && _max !== undefined) {
            // we need to get max of absolute components because target weight is [-1,1]
            vector.setX(Math.max(Math.abs(_min[0]), Math.abs(_max[0])));
            vector.setY(Math.max(Math.abs(_min[1]), Math.abs(_max[1])));
            vector.setZ(Math.max(Math.abs(_min[2]), Math.abs(_max[2])));

            if (_accessor.normalized) {
              var _boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[_accessor.componentType]);

              vector.multiplyScalar(_boxScale);
            } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
            // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
            // are used to implement key-frame animations and as such only two are active at a time - this results in very large
            // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.


            maxDisplacement.max(vector);
          } else {
            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
          }
        }
      } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.


      box.expandByVector(maxDisplacement);
    }

    geometry.boundingBox = box;
    var sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */


  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var pending = [];

    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }

    for (var gltfAttributeName in attributes) {
      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.

      if (threeAttributeName in geometry.attributes) continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }

    if (primitiveDef.indices !== undefined && !geometry.index) {
      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
        geometry.setIndex(accessor);
      });
      pending.push(accessor);
    }

    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function () {
      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  /**
   * @param {BufferGeometry} geometry
   * @param {Number} drawMode
   * @return {BufferGeometry}
   */


  function toTrianglesDrawMode(geometry, drawMode) {
    var index = geometry.getIndex(); // generate index if not present

    if (index === null) {
      var indices = [];
      var position = geometry.getAttribute('position');

      if (position !== undefined) {
        for (var i = 0; i < position.count; i++) {
          indices.push(i);
        }

        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
        return geometry;
      }
    } //


    var numberOfTriangles = index.count - 2;
    var newIndices = [];

    if (drawMode === TriangleFanDrawMode) {
      // gl.TRIANGLE_FAN
      for (var _i8 = 1; _i8 <= numberOfTriangles; _i8++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(_i8));
        newIndices.push(index.getX(_i8 + 1));
      }
    } else {
      // gl.TRIANGLE_STRIP
      for (var _i9 = 0; _i9 < numberOfTriangles; _i9++) {
        if (_i9 % 2 === 0) {
          newIndices.push(index.getX(_i9));
          newIndices.push(index.getX(_i9 + 1));
          newIndices.push(index.getX(_i9 + 2));
        } else {
          newIndices.push(index.getX(_i9 + 2));
          newIndices.push(index.getX(_i9 + 1));
          newIndices.push(index.getX(_i9));
        }
      }
    }

    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
    } // build final geometry


    var newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }

  var _taskCache = new WeakMap();

  class DRACOLoader extends Loader {
    constructor(manager) {
      super(manager);
      this.decoderPath = '';
      this.decoderConfig = {};
      this.decoderBinary = null;
      this.decoderPending = null;
      this.workerLimit = 4;
      this.workerPool = [];
      this.workerNextTaskID = 1;
      this.workerSourceURL = '';
      this.defaultAttributeIDs = {
        position: 'POSITION',
        normal: 'NORMAL',
        color: 'COLOR',
        uv: 'TEX_COORD'
      };
      this.defaultAttributeTypes = {
        position: 'Float32Array',
        normal: 'Float32Array',
        color: 'Float32Array',
        uv: 'Float32Array'
      };
    }

    setDecoderPath(path) {
      this.decoderPath = path;
      return this;
    }

    setDecoderConfig(config) {
      this.decoderConfig = config;
      return this;
    }

    setWorkerLimit(workerLimit) {
      this.workerLimit = workerLimit;
      return this;
    }

    load(url, onLoad, onProgress, onError) {
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, buffer => {
        var taskConfig = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: false
        };
        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);
      }, onProgress, onError);
    }
    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */


    decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
      var taskConfig = {
        attributeIDs: attributeIDs || this.defaultAttributeIDs,
        attributeTypes: attributeTypes || this.defaultAttributeTypes,
        useUniqueIDs: !!attributeIDs
      };
      this.decodeGeometry(buffer, taskConfig).then(callback);
    }

    decodeGeometry(buffer, taskConfig) {
      // TODO: For backward-compatibility, support 'attributeTypes' objects containing
      // references (rather than names) to typed array constructors. These must be
      // serialized before sending them to the worker.
      for (var attribute in taskConfig.attributeTypes) {
        var type = taskConfig.attributeTypes[attribute];

        if (type.BYTES_PER_ELEMENT !== undefined) {
          taskConfig.attributeTypes[attribute] = type.name;
        }
      } //


      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred
      // again from this thread.

      if (_taskCache.has(buffer)) {
        var cachedTask = _taskCache.get(buffer);

        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          // Technically, it would be possible to wait for the previous task to complete,
          // transfer the buffer back, and decode again with the second configuration. That
          // is complex, and I don't know of any reason to decode a Draco buffer twice in
          // different ways, so this is left unimplemented.
          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');
        }
      } //


      var worker;
      var taskID = this.workerNextTaskID++;
      var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance
      // when the task completes.

      var geometryPending = this._getWorker(taskID, taskCost).then(_worker => {
        worker = _worker;
        return new Promise((resolve, reject) => {
          worker._callbacks[taskID] = {
            resolve,
            reject
          };
          worker.postMessage({
            type: 'decode',
            id: taskID,
            taskConfig,
            buffer
          }, [buffer]); // this.debug();
        });
      }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.
      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)


      geometryPending.catch(() => true).then(() => {
        if (worker && taskID) {
          this._releaseTask(worker, taskID); // this.debug();

        }
      }); // Cache the task result.

      _taskCache.set(buffer, {
        key: taskKey,
        promise: geometryPending
      });

      return geometryPending;
    }

    _createGeometry(geometryData) {
      var geometry = new BufferGeometry();

      if (geometryData.index) {
        geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
      }

      for (var i = 0; i < geometryData.attributes.length; i++) {
        var attribute = geometryData.attributes[i];
        var name = attribute.name;
        var array = attribute.array;
        var itemSize = attribute.itemSize;
        geometry.setAttribute(name, new BufferAttribute(array, itemSize));
      }

      return geometry;
    }

    _loadLibrary(url, responseType) {
      var loader = new FileLoader(this.manager);
      loader.setPath(this.decoderPath);
      loader.setResponseType(responseType);
      loader.setWithCredentials(this.withCredentials);
      return new Promise((resolve, reject) => {
        loader.load(url, resolve, undefined, reject);
      });
    }

    preload() {
      this._initDecoder();

      return this;
    }

    _initDecoder() {
      if (this.decoderPending) return this.decoderPending;
      var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
      var librariesPending = [];

      if (useJS) {
        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));
      } else {
        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));
        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));
      }

      this.decoderPending = Promise.all(librariesPending).then(libraries => {
        var jsContent = libraries[0];

        if (!useJS) {
          this.decoderConfig.wasmBinary = libraries[1];
        }

        var fn = DRACOWorker.toString();
        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\n');
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
      });
      return this.decoderPending;
    }

    _getWorker(taskID, taskCost) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          var _worker2 = new Worker(this.workerSourceURL);

          _worker2._callbacks = {};
          _worker2._taskCosts = {};
          _worker2._taskLoad = 0;

          _worker2.postMessage({
            type: 'init',
            decoderConfig: this.decoderConfig
          });

          _worker2.onmessage = function (e) {
            var message = e.data;

            switch (message.type) {
              case 'decode':
                _worker2._callbacks[message.id].resolve(message);

                break;

              case 'error':
                _worker2._callbacks[message.id].reject(message);

                break;

              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
            }
          };

          this.workerPool.push(_worker2);
        } else {
          this.workerPool.sort(function (a, b) {
            return a._taskLoad > b._taskLoad ? -1 : 1;
          });
        }

        var worker = this.workerPool[this.workerPool.length - 1];
        worker._taskCosts[taskID] = taskCost;
        worker._taskLoad += taskCost;
        return worker;
      });
    }

    _releaseTask(worker, taskID) {
      worker._taskLoad -= worker._taskCosts[taskID];
      delete worker._callbacks[taskID];
      delete worker._taskCosts[taskID];
    }

    debug() {
      console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));
    }

    dispose() {
      for (var i = 0; i < this.workerPool.length; ++i) {
        this.workerPool[i].terminate();
      }

      this.workerPool.length = 0;
      return this;
    }

  }
  /* WEB WORKER */


  function DRACOWorker() {
    var decoderConfig;
    var decoderPending;

    onmessage = function (e) {
      var message = e.data;

      switch (message.type) {
        case 'init':
          decoderConfig = message.decoderConfig;
          decoderPending = new Promise(function (resolve
          /*, reject*/
          ) {
            decoderConfig.onModuleLoaded = function (draco) {
              // Module is Promise-like. Wrap before resolving to avoid loop.
              resolve({
                draco: draco
              });
            };

            DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef
          });
          break;

        case 'decode':
          var buffer = message.buffer;
          var taskConfig = message.taskConfig;
          decoderPending.then(module => {
            var draco = module.draco;
            var decoder = new draco.Decoder();
            var decoderBuffer = new draco.DecoderBuffer();
            decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);

            try {
              var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
              var buffers = geometry.attributes.map(attr => attr.array.buffer);
              if (geometry.index) buffers.push(geometry.index.array.buffer);
              self.postMessage({
                type: 'decode',
                id: message.id,
                geometry
              }, buffers);
            } catch (error) {
              console.error(error);
              self.postMessage({
                type: 'error',
                id: message.id,
                error: error.message
              });
            } finally {
              draco.destroy(decoderBuffer);
              draco.destroy(decoder);
            }
          });
          break;
      }
    };

    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
      var attributeIDs = taskConfig.attributeIDs;
      var attributeTypes = taskConfig.attributeTypes;
      var dracoGeometry;
      var decodingStatus;
      var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);

      if (geometryType === draco.TRIANGULAR_MESH) {
        dracoGeometry = new draco.Mesh();
        decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
      } else if (geometryType === draco.POINT_CLOUD) {
        dracoGeometry = new draco.PointCloud();
        decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
      } else {
        throw new Error('THREE.DRACOLoader: Unexpected geometry type.');
      }

      if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
        throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());
      }

      var geometry = {
        index: null,
        attributes: []
      }; // Gather all vertex attributes.

      for (var attributeName in attributeIDs) {
        var attributeType = self[attributeTypes[attributeName]];
        var attribute = void 0;
        var attributeID = void 0; // A Draco file may be created with default vertex attributes, whose attribute IDs
        // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
        // a Draco file may contain a custom set of attributes, identified by known unique
        // IDs. glTF files always do the latter, and `.drc` files typically do the former.

        if (taskConfig.useUniqueIDs) {
          attributeID = attributeIDs[attributeName];
          attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
        } else {
          attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
          if (attributeID === -1) continue;
          attribute = decoder.GetAttribute(dracoGeometry, attributeID);
        }

        geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
      } // Add index.


      if (geometryType === draco.TRIANGULAR_MESH) {
        geometry.index = decodeIndex(draco, decoder, dracoGeometry);
      }

      draco.destroy(dracoGeometry);
      return geometry;
    }

    function decodeIndex(draco, decoder, dracoGeometry) {
      var numFaces = dracoGeometry.num_faces();
      var numIndices = numFaces * 3;
      var byteLength = numIndices * 4;

      var ptr = draco._malloc(byteLength);

      decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();

      draco._free(ptr);

      return {
        array: index,
        itemSize: 1
      };
    }

    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
      var numComponents = attribute.num_components();
      var numPoints = dracoGeometry.num_points();
      var numValues = numPoints * numComponents;
      var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
      var dataType = getDracoDataType(draco, attributeType);

      var ptr = draco._malloc(byteLength);

      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
      var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();

      draco._free(ptr);

      return {
        name: attributeName,
        array: array,
        itemSize: numComponents
      };
    }

    function getDracoDataType(draco, attributeType) {
      switch (attributeType) {
        case Float32Array:
          return draco.DT_FLOAT32;

        case Int8Array:
          return draco.DT_INT8;

        case Int16Array:
          return draco.DT_INT16;

        case Int32Array:
          return draco.DT_INT32;

        case Uint8Array:
          return draco.DT_UINT8;

        case Uint16Array:
          return draco.DT_UINT16;

        case Uint32Array:
          return draco.DT_UINT32;
      }
    }
  }

  /**
   * @author Deepkolos / https://github.com/deepkolos
   */
  class WorkerPool {
    constructor() {
      var pool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
      this.pool = pool;
      this.queue = [];
      this.workers = [];
      this.workersResolve = [];
      this.workerStatus = 0;
    }

    _initWorker(workerId) {
      if (!this.workers[workerId]) {
        var worker = this.workerCreator();
        worker.addEventListener('message', this._onMessage.bind(this, workerId));
        this.workers[workerId] = worker;
      }
    }

    _getIdleWorker() {
      for (var i = 0; i < this.pool; i++) {
        if (!(this.workerStatus & 1 << i)) return i;
      }

      return -1;
    }

    _onMessage(workerId, msg) {
      var resolve = this.workersResolve[workerId];
      resolve && resolve(msg);

      if (this.queue.length) {
        var {
          resolve: _resolve,
          msg: _msg,
          transfer
        } = this.queue.shift();
        this.workersResolve[workerId] = _resolve;
        this.workers[workerId].postMessage(_msg, transfer);
      } else {
        this.workerStatus ^= 1 << workerId;
      }
    }

    setWorkerCreator(workerCreator) {
      this.workerCreator = workerCreator;
    }

    setWorkerLimit(pool) {
      this.pool = pool;
    }

    postMessage(msg, transfer) {
      return new Promise(resolve => {
        var workerId = this._getIdleWorker();

        if (workerId !== -1) {
          this._initWorker(workerId);

          this.workerStatus |= 1 << workerId;
          this.workersResolve[workerId] = resolve;
          this.workers[workerId].postMessage(msg, transfer);
        } else {
          this.queue.push({
            resolve,
            msg,
            transfer
          });
        }
      });
    }

    dispose() {
      this.workers.forEach(worker => worker.terminate());
      this.workersResolve.length = 0;
      this.workers.length = 0;
      this.queue.length = 0;
      this.workerStatus = 0;
    }

  }

  /**
   * Loader for KTX 2.0 GPU Texture containers.
   *
   * KTX 2.0 is a container format for various GPU texture formats. The loader
   * supports Basis Universal GPU textures, which can be quickly transcoded to
   * a wide variety of GPU texture compression formats. While KTX 2.0 also allows
   * other hardware-specific formats, this loader does not yet parse them.
   *
   * References:
   * - KTX: http://github.khronos.org/KTX-Specification/
   * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor
   */
  var KTX2TransferSRGB = 2;
  var KTX2_ALPHA_PREMULTIPLIED = 1;

  var _taskCache$1 = new WeakMap();

  var _activeLoaders = 0;

  class KTX2Loader extends Loader {
    constructor(manager) {
      super(manager);
      this.transcoderPath = '';
      this.transcoderBinary = null;
      this.transcoderPending = null;
      this.workerPool = new WorkerPool();
      this.workerSourceURL = '';
      this.workerConfig = null;

      if (typeof MSC_TRANSCODER !== 'undefined') {
        console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder".' + ' "msc_basis_transcoder" is no longer supported in three.js r125+.');
      }
    }

    setTranscoderPath(path) {
      this.transcoderPath = path;
      return this;
    }

    setWorkerLimit(num) {
      this.workerPool.setWorkerLimit(num);
      return this;
    }

    detectSupport(renderer) {
      this.workerConfig = {
        astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),
        etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),
        etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),
        dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),
        bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),
        pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')
      };
      return this;
    }

    dispose() {
      this.workerPool.dispose();
      if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);
      return this;
    }

    init() {
      if (!this.transcoderPending) {
        // Load transcoder wrapper.
        var jsLoader = new FileLoader(this.manager);
        jsLoader.setPath(this.transcoderPath);
        jsLoader.setWithCredentials(this.withCredentials);
        var jsContent = jsLoader.loadAsync('basis_transcoder.js'); // Load transcoder WASM binary.

        var binaryLoader = new FileLoader(this.manager);
        binaryLoader.setPath(this.transcoderPath);
        binaryLoader.setResponseType('arraybuffer');
        binaryLoader.setWithCredentials(this.withCredentials);
        var binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm');
        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(_ref => {
          var [jsContent, binaryContent] = _ref;
          var fn = KTX2Loader.BasisWorker.toString();
          var body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\n');
          this.workerSourceURL = URL.createObjectURL(new Blob([body]));
          this.transcoderBinary = binaryContent;
          this.workerPool.setWorkerCreator(() => {
            var worker = new Worker(this.workerSourceURL);
            var transcoderBinary = this.transcoderBinary.slice(0);
            worker.postMessage({
              type: 'init',
              config: this.workerConfig,
              transcoderBinary
            }, [transcoderBinary]);
            return worker;
          });
        });

        if (_activeLoaders > 0) {
          // Each instance loads a transcoder and allocates workers, increasing network and memory cost.
          console.warn('THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' + ' Use a single KTX2Loader instance, or call .dispose() on old instances.');
        }

        _activeLoaders++;
      }

      return this.transcoderPending;
    }

    load(url, onLoad, onProgress, onError) {
      if (this.workerConfig === null) {
        throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.');
      }

      var loader = new FileLoader(this.manager);
      loader.setResponseType('arraybuffer');
      loader.setWithCredentials(this.withCredentials);
      var texture = new CompressedTexture();
      loader.load(url, buffer => {
        // Check for an existing task using this buffer. A transferred buffer cannot be transferred
        // again from this thread.
        if (_taskCache$1.has(buffer)) {
          var cachedTask = _taskCache$1.get(buffer);

          return cachedTask.promise.then(onLoad).catch(onError);
        }

        this._createTexture([buffer]).then(function (_texture) {
          texture.copy(_texture);
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }).catch(onError);
      }, onProgress, onError);
      return texture;
    }

    _createTextureFrom(transcodeResult) {
      var {
        mipmaps,
        width,
        height,
        format,
        type,
        error,
        dfdTransferFn,
        dfdFlags
      } = transcodeResult;
      if (type === 'error') return Promise.reject(error);
      var texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
      texture.encoding = dfdTransferFn === KTX2TransferSRGB ? sRGBEncoding : LinearEncoding;
      texture.premultiplyAlpha = !!(dfdFlags & KTX2_ALPHA_PREMULTIPLIED);
      return texture;
    }
    /**
     * @param {ArrayBuffer[]} buffers
     * @param {object?} config
     * @return {Promise<CompressedTexture>}
     */


    _createTexture(buffers) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var taskConfig = config;
      var texturePending = this.init().then(() => {
        return this.workerPool.postMessage({
          type: 'transcode',
          buffers,
          taskConfig: taskConfig
        }, buffers);
      }).then(e => this._createTextureFrom(e.data)); // Cache the task result.

      _taskCache$1.set(buffers[0], {
        promise: texturePending
      });

      return texturePending;
    }

    dispose() {
      URL.revokeObjectURL(this.workerSourceURL);
      this.workerPool.dispose();
      _activeLoaders--;
      return this;
    }

  }
  /* CONSTANTS */


  KTX2Loader.BasisFormat = {
    ETC1S: 0,
    UASTC_4x4: 1
  };
  KTX2Loader.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16
  };
  KTX2Loader.EngineFormat = {
    RGBAFormat: RGBAFormat,
    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
    RGBA_BPTC_Format: RGBA_BPTC_Format,
    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
    RGB_ETC1_Format: RGB_ETC1_Format,
    RGB_ETC2_Format: RGB_ETC2_Format,
    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format
  };
  /* WEB WORKER */

  KTX2Loader.BasisWorker = function () {
    var config;
    var transcoderPending;
    var BasisModule;
    var EngineFormat = _EngineFormat; // eslint-disable-line no-undef

    var TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef

    var BasisFormat = _BasisFormat; // eslint-disable-line no-undef

    self.addEventListener('message', function (e) {
      var message = e.data;

      switch (message.type) {
        case 'init':
          config = message.config;
          init(message.transcoderBinary);
          break;

        case 'transcode':
          transcoderPending.then(() => {
            try {
              var {
                width,
                height,
                hasAlpha,
                mipmaps,
                format,
                dfdTransferFn,
                dfdFlags
              } = transcode(message.buffers[0]);
              var buffers = [];

              for (var i = 0; i < mipmaps.length; ++i) {
                buffers.push(mipmaps[i].data.buffer);
              }

              self.postMessage({
                type: 'transcode',
                id: message.id,
                width,
                height,
                hasAlpha,
                mipmaps,
                format,
                dfdTransferFn,
                dfdFlags
              }, buffers);
            } catch (error) {
              console.error(error);
              self.postMessage({
                type: 'error',
                id: message.id,
                error: error.message
              });
            }
          });
          break;
      }
    });

    function init(wasmBinary) {
      transcoderPending = new Promise(resolve => {
        BasisModule = {
          wasmBinary,
          onRuntimeInitialized: resolve
        };
        BASIS(BasisModule); // eslint-disable-line no-undef
      }).then(() => {
        BasisModule.initializeBasis();

        if (BasisModule.KTX2File === undefined) {
          console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.');
        }
      });
    }

    function transcode(buffer) {
      var ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));

      function cleanup() {
        ktx2File.close();
        ktx2File.delete();
      }

      if (!ktx2File.isValid()) {
        cleanup();
        throw new Error('THREE.KTX2Loader:	Invalid or unsupported .ktx2 file');
      }

      var basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
      var width = ktx2File.getWidth();
      var height = ktx2File.getHeight();
      var levels = ktx2File.getLevels();
      var hasAlpha = ktx2File.getHasAlpha();
      var dfdTransferFn = ktx2File.getDFDTransferFunc();
      var dfdFlags = ktx2File.getDFDFlags();
      var {
        transcoderFormat,
        engineFormat
      } = getTranscoderFormat(basisFormat, width, height, hasAlpha);

      if (!width || !height || !levels) {
        cleanup();
        throw new Error('THREE.KTX2Loader:	Invalid texture');
      }

      if (!ktx2File.startTranscoding()) {
        cleanup();
        throw new Error('THREE.KTX2Loader: .startTranscoding failed');
      }

      var mipmaps = [];

      for (var mip = 0; mip < levels; mip++) {
        var levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
        var mipWidth = levelInfo.origWidth;
        var mipHeight = levelInfo.origHeight;
        var dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
        var status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);

        if (!status) {
          cleanup();
          throw new Error('THREE.KTX2Loader: .transcodeImage failed.');
        }

        mipmaps.push({
          data: dst,
          width: mipWidth,
          height: mipHeight
        });
      }

      cleanup();
      return {
        width,
        height,
        hasAlpha,
        mipmaps,
        format: engineFormat,
        dfdTransferFn,
        dfdFlags
      };
    } //
    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),
    // device capabilities, and texture dimensions. The list below ranks the formats separately
    // for ETC1S and UASTC.
    //
    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at
    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently
    // chooses RGBA32 only as a last resort and does not expose that option to the caller.


    var FORMAT_OPTIONS = [{
      if: 'astcSupported',
      basisFormat: [BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    }, {
      if: 'bptcSupported',
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    }, {
      if: 'dxtSupported',
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    }, {
      if: 'etc2Supported',
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    }, {
      if: 'etc1Supported',
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    }, {
      if: 'pvrtcSupported',
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    }];
    var ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {
      return a.priorityETC1S - b.priorityETC1S;
    });
    var UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {
      return a.priorityUASTC - b.priorityUASTC;
    });

    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
      var transcoderFormat;
      var engineFormat;
      var options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;

      for (var i = 0; i < options.length; i++) {
        var opt = options[i];
        if (!config[opt.if]) continue;
        if (!opt.basisFormat.includes(basisFormat)) continue;
        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;
        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
        return {
          transcoderFormat,
          engineFormat
        };
      }

      console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.');
      transcoderFormat = TranscoderFormat.RGBA32;
      engineFormat = EngineFormat.RGBAFormat;
      return {
        transcoderFormat,
        engineFormat
      };
    }

    function isPowerOfTwo(value) {
      if (value <= 2) return true;
      return (value & value - 1) === 0 && value !== 0;
    }
  };

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  /**
   * Data class for loaded 3d model
   */

  class Model {
    /**
     * Create new Model instance
     */
    constructor({
      src,
      scenes,
      animations = [],
      json = {},
      fixSkinnedBbox = false,
      castShadow = true,
      receiveShadow = false
    }) {
      this._src = src; // This guarantees model's root has identity matrix at creation

      this._scene = new Group();

      this._scene.add(...scenes);

      this._animations = animations;
      this._json = json;
      this._bbox = this._getInitialBbox(fixSkinnedBbox); // Move to position where bbox.min.y = 0

      const offset = this._bbox.min.y;

      this._scene.translateY(-offset);

      this._bbox.translate(new Vector3(0, -offset, 0));

      this.castShadow = castShadow;
      this.receiveShadow = receiveShadow;
    }
    /**
     * Source URL of this model
     * @type {string}
     * @readonly
     */


    get src() {
      return this._src;
    }
    /**
     * Scene of the model, see {@link https://threejs.org/docs/#api/en/objects/Group THREE.Group}
     * @readonly
     */


    get scene() {
      return this._scene;
    }
    /**
     * {@link https://threejs.org/docs/#api/en/animation/AnimationClip THREE.AnimationClip}s inside model
     * @readonly
     */


    get animations() {
      return this._animations;
    }
    /**
     * JSON data of original glTF file
     * @readonly
     */


    get json() {
      return this._json;
    }
    /**
     * {@link https://threejs.org/docs/#api/en/objects/Mesh THREE.Mesh}es inside model if there's any.
     * @readonly
     */


    get meshes() {
      return this._getAllMeshes();
    }
    /**
     * Get a copy of model's current bounding box
     * @type THREE#Box3
     * @readonly
     * @see https://threejs.org/docs/#api/en/math/Box3
     */


    get bbox() {
      return this._bbox;
    }
    /**
     * Whether the model's meshes gets rendered into shadow map
     * @type boolean
     * @example
     * ```ts
     * model.castShadow = true;
     * ```
     */


    set castShadow(val) {
      const meshes = this.meshes;
      meshes.forEach(mesh => mesh.castShadow = val);
    }
    /**
     * Whether the model's mesh materials receive shadows
     * @type boolean
     * @example
     * ```ts
     * model.receiveShadow = true;
     * ```
     */


    set receiveShadow(val) {
      const meshes = this.meshes;
      meshes.forEach(mesh => mesh.receiveShadow = val);
    }

    reduceVertices(callbackfn, initialVal) {
      const meshes = this.meshes;
      let result = initialVal;
      meshes.forEach(mesh => {
        const {
          position
        } = mesh.geometry.attributes;
        if (!position) return;
        mesh.updateMatrixWorld();

        for (let idx = 0; idx < position.count; idx++) {
          const vertex = new Vector3().fromBufferAttribute(position, idx);
          vertex.applyMatrix4(mesh.matrixWorld);
          result = callbackfn(result, vertex);
        }
      });
      return result;
    }

    _getInitialBbox(fixSkinnedBbox) {
      this._scene.updateMatrixWorld();

      if (fixSkinnedBbox && this._hasSkinnedMesh()) {
        return this._getSkeletonBbox();
      } else {
        return new Box3().setFromObject(this._scene);
      }
    }

    _getSkeletonBbox() {
      const bbox = new Box3();
      this.meshes.forEach(mesh => {
        if (!mesh.isSkinnedMesh) {
          bbox.expandByObject(mesh);
          return;
        }

        const geometry = mesh.geometry;
        const positions = geometry.attributes.position;
        const skinIndicies = geometry.attributes.skinIndex;
        const skinWeights = geometry.attributes.skinWeight;
        const skeleton = mesh.skeleton;
        skeleton.update();
        const boneMatricies = skeleton.boneMatrices;
        const finalMatrix = new Matrix4();

        for (let posIdx = 0; posIdx < positions.count; posIdx++) {
          finalMatrix.identity();
          const skinned = new Vector4();
          skinned.set(0, 0, 0, 0);
          const skinVertex = new Vector4();
          skinVertex.set(positions.getX(posIdx), positions.getY(posIdx), positions.getZ(posIdx), 1).applyMatrix4(mesh.bindMatrix);
          const weights = [skinWeights.getX(posIdx), skinWeights.getY(posIdx), skinWeights.getZ(posIdx), skinWeights.getW(posIdx)];
          const indicies = [skinIndicies.getX(posIdx), skinIndicies.getY(posIdx), skinIndicies.getZ(posIdx), skinIndicies.getW(posIdx)];
          weights.forEach((weight, index) => {
            const boneMatrix = new Matrix4().fromArray(boneMatricies, indicies[index] * 16);
            skinned.add(skinVertex.clone().applyMatrix4(boneMatrix).multiplyScalar(weight));
          });
          const transformed = new Vector3().fromArray(skinned.applyMatrix4(mesh.bindMatrixInverse).toArray());
          transformed.applyMatrix4(mesh.matrixWorld); // if (Math.abs(transformed.x) > 10000) {
          //   console.log(transformed, mesh.bindMatrixInverse, skinned);
          // }

          bbox.expandByPoint(transformed);
        }
      });
      return bbox;
    }
    /**
     * Get all {@link https://threejs.org/docs/#api/en/objects/Mesh THREE.Mesh}es inside model if there's any.
     * @private
     * @returns Meshes found at model's scene
     */


    _getAllMeshes() {
      const meshes = [];

      this._scene.traverse(obj => {
        if (obj.isMesh) {
          meshes.push(obj);
        }
      });

      return meshes;
    }

    _hasSkinnedMesh() {
      return this._getAllMeshes().some(mesh => mesh.isSkinnedMesh);
    }

  }

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  const dracoLoader = new DRACOLoader();
  const ktx2Loader = new KTX2Loader();
  /**
   * GLTFLoader
   */

  class GLTFLoader$1 {
    /**
     * Create a new instance of GLTFLoader
     */
    constructor(view3D) {
      this._view3D = view3D;
      this._loader = new GLTFLoader();
      const loader = this._loader;
      loader.setCrossOrigin("anonymous");
      loader.setDRACOLoader(dracoLoader);
      loader.setKTX2Loader(ktx2Loader.detectSupport(view3D.renderer.threeRenderer));
    }

    static setMeshoptDecoder(meshoptPath) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          const scriptTag = document.createElement("script");
          scriptTag.addEventListener("load", () => __awaiter(this, void 0, void 0, function* () {
            yield window.MeshoptDecoder.ready;
            GLTFLoader$1.meshoptDecoder = window.MeshoptDecoder;
            document.body.removeChild(scriptTag);
            resolve();
          }));
          scriptTag.addEventListener("error", () => {
            document.body.removeChild(scriptTag);
            reject();
          });
          scriptTag.src = new URL(meshoptPath, location.href).href;
          document.body.appendChild(scriptTag);
        });
      });
    }
    /**
     * Load new GLTF model from the given url
     * @param {string} url URL to fetch glTF/glb file
     * @returns Promise that resolves {@link Model}
     */


    load(url) {
      const view3D = this._view3D;
      const loader = this._loader;
      dracoLoader.setDecoderPath(view3D.dracoPath);
      ktx2Loader.setTranscoderPath(view3D.ktxPath);

      if (GLTFLoader$1.meshoptDecoder) {
        loader.setMeshoptDecoder(GLTFLoader$1.meshoptDecoder);
      }

      loader.manager = DefaultLoadingManager;
      return new Promise((resolve, reject) => {
        try {
          loader.load(url, gltf => {
            const model = this._parseToModel(gltf, url);

            resolve(model);
          }, evt => {
            view3D.trigger(EVENTS.PROGRESS, {
              type: EVENTS.PROGRESS,
              target: view3D,
              lengthComputable: evt.lengthComputable,
              loaded: evt.loaded,
              total: evt.total
            });
          }, err => {
            reject(err);
          });
        } catch (err) {
          reject(err);
        }
      });
    }
    /**
     * Load new GLTF model from the given files
     * @param files Files that has glTF/glb and all its associated resources like textures and .bin data files
     * @returns Promise that resolves {@link Model}
     */


    loadFromFiles(files) {
      const view3D = this._view3D;
      const loader = this._loader;
      const objectURLs = [];

      const revokeURLs = () => {
        objectURLs.forEach(url => {
          URL.revokeObjectURL(url);
        });
      };

      dracoLoader.setDecoderPath(view3D.dracoPath);
      ktx2Loader.setTranscoderPath(view3D.ktxPath);

      if (GLTFLoader$1.meshoptDecoder) {
        loader.setMeshoptDecoder(GLTFLoader$1.meshoptDecoder);
      }

      return new Promise((resolve, reject) => {
        if (files.length <= 0) {
          reject(new Error("No files found"));
          return;
        }

        const gltfFile = files.find(file => /\.(gltf|glb)$/i.test(file.name));

        if (!gltfFile) {
          reject(new Error("No glTF file found"));
          return;
        }

        const filesMap = new Map();
        files.forEach(file => {
          filesMap.set(file.name, file);
        });
        const gltfURL = URL.createObjectURL(gltfFile);
        objectURLs.push(gltfURL);
        const manager = new LoadingManager();
        manager.setURLModifier(fileURL => {
          if (/^data:.*,.*$/i.test(fileURL)) return fileURL;
          const fileNameResult = /[^\/|\\]+$/.exec(fileURL);
          const fileName = fileNameResult && fileNameResult[0] || "";

          if (filesMap.has(fileName)) {
            const blob = filesMap.get(fileName);
            const blobURL = URL.createObjectURL(blob);
            objectURLs.push(blobURL);
            return blobURL;
          }

          return fileURL;
        });
        loader.manager = manager;
        loader.load(gltfURL, gltf => {
          const model = this._parseToModel(gltf, gltfFile.name);

          resolve(model);
          revokeURLs();
        }, undefined, err => {
          reject(err);
          revokeURLs();
        });
      });
    }

    _parseToModel(gltf, src) {
      const view3D = this._view3D;
      const fixSkinnedBbox = view3D.fixSkinnedBbox;
      gltf.scenes.forEach(scene => {
        scene.traverse(obj => {
          obj.frustumCulled = false;
        });
      });
      const extensionsUsed = gltf.parser.json.extensionsUsed;

      if (extensionsUsed && extensionsUsed.some(extension => extension === CUSTOM_TEXTURE_LOD_EXTENSION)) {
        const maxTextureSize = view3D.renderer.threeRenderer.capabilities.maxTextureSize;
        const meshes = [];
        gltf.scenes.forEach(scene => {
          scene.traverse(obj => {
            if (obj.isMesh) {
              meshes.push(obj);
            }
          });
        });
        const materials = meshes.reduce((allMaterials, mesh) => {
          return [...allMaterials, ...(Array.isArray(mesh.material) ? mesh.material : [mesh.material])];
        }, []);
        const textures = materials.reduce((allTextures, material) => {
          return [...allTextures, ...STANDARD_MAPS.filter(map => material[map]).map(mapName => material[mapName])];
        }, []);
        const associations = gltf.parser.associations;
        const gltfJSON = gltf.parser.json;
        const gltfTextures = textures.filter(texture => associations.has(texture)).map(texture => {
          return gltfJSON.textures[associations.get(texture).textures];
        });
        const texturesByLevel = gltfTextures.reduce((levels, texture, texIdx) => {
          if (!texture.extensions[CUSTOM_TEXTURE_LOD_EXTENSION]) return levels;
          const currentTexture = textures[texIdx];
          const lodLevels = texture.extensions[CUSTOM_TEXTURE_LOD_EXTENSION].levels;
          lodLevels.forEach(({
            index,
            size
          }, level) => {
            if (size > maxTextureSize) return;

            if (!levels[level]) {
              levels[level] = [];
            }

            levels[level].push({
              index,
              texture: currentTexture
            });
          });
          return levels;
        }, []);
        const loaded = texturesByLevel.map(() => false);
        texturesByLevel.forEach((levelTextures, level) => __awaiter(this, void 0, void 0, function* () {
          // Change textures when all texture of the level loaded
          const texturesLoaded = yield Promise.all(levelTextures.map(({
            index
          }) => gltf.parser.getDependency("texture", index)));
          const higherLevelLoaded = loaded.slice(level + 1).some(val => !!val);
          loaded[level] = true;
          if (higherLevelLoaded) return;
          texturesLoaded.forEach((texture, index) => {
            const origTexture = levelTextures[index].texture;
            origTexture.image = texture.image;
            origTexture.needsUpdate = true;
          });
        }));
      }

      const model = new Model({
        src,
        scenes: gltf.scenes,
        json: gltf.parser.json,
        animations: gltf.animations,
        fixSkinnedBbox
      });
      return model;
    }

  }

  /**
   * @extends Component
   * @see https://naver.github.io/egjs-component/
   */

  class View3D extends Component {
    /**
     * Creates new View3D instance.
     * @param root A root element or selector of it to initialize View3D
     * @param {View3DOptions} [options={}] An options object for View3D
     * @throws {View3DError}
     * |code|condition|
     * |---|---|
     * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|
     * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|
     * |{@link ERROR_CODE ELEMENT_NOT_CANVAS}|When the element given is not a \<canvas\> element|
     * |{@link ERROR_CODE WEBGL_NOT_SUPPORTED}|When the browser does not support WebGL|
     */
    constructor(root, {
      src = null,
      iosSrc = null,
      dracoPath = DRACO_DECODER_URL,
      ktxPath = KTX_TRANSCODER_URL,
      meshoptPath = null,
      fixSkinnedBbox = false,
      fov = AUTO,
      center = AUTO,
      yaw = 0,
      pitch = 0,
      rotate = true,
      translate = true,
      zoom = true,
      autoplay = false,
      scrollable = true,
      wheelScrollable = false,
      useGrabCursor = true,
      skybox = null,
      envmap = null,
      background = null,
      exposure = 1,
      shadow = true,
      skyboxBlur = false,
      webAR = true,
      sceneViewer = true,
      quickLook = true,
      arPriority = AR_PRIORITY,
      poster = null,
      canvasSelector = "canvas",
      autoInit = true,
      autoResize = true,
      useResizeObserver = true,
      on = {},
      plugins = []
    } = {}) {
      super();
      this._rootEl = getElement(root); // Bind options

      this._src = src;
      this._iosSrc = iosSrc;
      this._dracoPath = dracoPath;
      this._ktxPath = ktxPath;
      this._meshoptPath = meshoptPath;
      this._fixSkinnedBbox = fixSkinnedBbox;
      this._fov = fov;
      this._center = center;
      this._yaw = yaw;
      this._pitch = pitch;
      this._rotate = rotate;
      this._translate = translate;
      this._zoom = zoom;
      this._autoplay = autoplay;
      this._scrollable = scrollable;
      this._wheelScrollable = wheelScrollable;
      this._useGrabCursor = useGrabCursor;
      this._skybox = skybox;
      this._envmap = envmap;
      this._background = background;
      this._exposure = exposure;
      this._shadow = shadow;
      this._skyboxBlur = skyboxBlur;
      this._webAR = webAR;
      this._sceneViewer = sceneViewer;
      this._quickLook = quickLook;
      this._arPriority = arPriority;
      this._poster = poster;
      this._canvasSelector = canvasSelector;
      this._autoInit = autoInit;
      this._autoResize = autoResize;
      this._useResizeObserver = useResizeObserver; // Create internal components

      this._renderer = new Renderer(this);
      this._camera = new Camera$1(this);
      this._control = new OrbitControl(this);
      this._scene = new Scene$1(this);
      this._animator = new ModelAnimator(this);
      this._autoPlayer = new AutoPlayer(this, getObjectOption(autoplay));
      this._autoResizer = new AutoResizer(this);
      this._arManager = new ARManager(this);
      this._model = null;
      this._initialized = false;
      this._plugins = plugins;

      this._addEventHandlers(on);

      this._addPosterImage();

      void this._initPlugins(plugins).then(() => {
        if (src && autoInit) {
          void this.init();
        }
      });
    } // Internal Components Getter

    /**
     * {@link Renderer} instance of the View3D
     * @type {Renderer}
     * @readonly
     */


    get renderer() {
      return this._renderer;
    }
    /**
     * {@link Scene} instance of the View3D
     * @type {Scene}
     * @readonly
     */


    get scene() {
      return this._scene;
    }
    /**
     * {@link Camera} instance of the View3D
     * @type {Camera}
     * @readonly
     */


    get camera() {
      return this._camera;
    }
    /**
     * {@link OrbitControl} instance of the View3D
     * @type {OrbitControl}
     * @readonly
     */


    get control() {
      return this._control;
    }
    /**
     * {@link AutoPlayer} instance of the View3D
     * @type {AutoPlayer}
     * @readonly
     */


    get autoPlayer() {
      return this._autoPlayer;
    }
    /**
     * Current {@link Model} displaying. `null` if nothing is displayed on the canvas.
     * @type {Model | null}
     * @readonly
     */


    get model() {
      return this._model;
    }
    /**
     * {@link ModelAnimator} instance of the View3D
     * @type {ModelAnimator}
     * @readonly
     */


    get animator() {
      return this._animator;
    }
    /**
     * {@link ARManager} instance of the View3D
     * @type {ARManager}
     * @readonly
     */


    get ar() {
      return this._arManager;
    } // Internal State Getter

    /**
     * Root(Wrapper) element of View3D that given in the constructor
     * @type {HTMLElement}
     * @readonly
     */


    get rootEl() {
      return this._rootEl;
    }
    /**
     * Whether the View3D is initialized. This is set to `true` just before triggering "ready" event.
     * @type {boolean}
     * @readonly
     */


    get initialized() {
      return this._initialized;
    }
    /**
     * Active plugins of view3D
     * @type {View3DPlugin[]}
     * @readonly
     */


    get plugins() {
      return this._plugins;
    } // Options Getter

    /**
     * Source URL to fetch 3D model. `glb` / `glTF` models are supported.
     * @type {string | null}
     * @default null
     */


    get src() {
      return this._src;
    }
    /**
     * Source URL to fetch 3D model in iOS AR Quick Look. `usdz` models are supported.
     * @type {string | null}
     * @default null
     */


    get iosSrc() {
      return this._iosSrc;
    }
    /**
     * URL to {@link https://github.com/google/draco Draco} decoder location.
     * @type {string}
     * @default https://www.gstatic.com/draco/versioned/decoders/1.4.1/
     */


    get dracoPath() {
      return this._dracoPath;
    }
    /**
     * URL to {@link http://github.khronos.org/KTX-Specification/#basisu_gd KTX2 texture} transcoder location.
     * @type {string}
     * @default https://unpkg.com/three@0.134.0/examples/js/libs/basis/
     */


    get ktxPath() {
      return this._ktxPath;
    }
    /**
     * URL to {@link https://github.com/zeux/meshoptimizer Meshoptimizer} decoder js path.
     * @type {string | null}
     * @default null
     */


    get meshoptPath() {
      return this._meshoptPath;
    }
    /**
     * Sometimes, some rigged model has the wrong bounding box that when displaying on three.js (usually converted glTF model from Sketchfab)
     * Enabling this option can resolve that issue by recalculating bounding box size with the influence of the skeleton weight.
     * @type {boolean}
     * @default false
     */


    get fixSkinnedBbox() {
      return this._fixSkinnedBbox;
    }
    /**
     * A vertical FOV(Field of View) value of the camera frustum, in degrees.
     * If `"auto"` is used, View3D will try to find the appropriate FOV value that model is not clipped at any angle.
     * @type {"auto" | number}
     * @default "auto"
     */


    get fov() {
      return this._fov;
    }
    /**
     * Center of the camera rotation.
     * If `"auto"` is given, it will use the center of the model's bounding box as the pivot.
     * Else, you can use any world position as the pivot.
     * @type {"auto" | number[]}
     * @default "auto"
     */


    get center() {
      return this._center;
    }
    /**
     * Initial Y-axis rotation of the camera, in degrees.
     * @type {number}
     * @default 0
     */


    get yaw() {
      return this._yaw;
    }
    /**
     * Initial X-axis rotation of the camera, in degrees.
     * Should be a value from -90 to 90.
     * @type {number}
     * @default 0
     */


    get pitch() {
      return this._pitch;
    }
    /**
     * Options for the {@link RotateControl}.
     * If `false` is given, it will disable the rotate control.
     * @type {boolean | RotateControlOptions}
     * @default true
     */


    get rotate() {
      return this._rotate;
    }
    /**
     * Options for the {@link TranslateControl}.
     * If `false` is given, it will disable the translate control.
     * @type {boolean | TranslateControlOptions}
     * @default true
     */


    get translate() {
      return this._translate;
    }
    /**
     * Options for the {@link ZoomControl}.
     * If `false` is given, it will disable the zoom control.
     * @type {boolean | ZoomControlOptions}
     * @default true
     */


    get zoom() {
      return this._zoom;
    }
    /**
     * Enable Y-axis rotation autoplay.
     * If `true` is given, it will enable autoplay with default values.
     * @type {boolean | AutoplayOptions}
     * @default true
     */


    get autoplay() {
      return this._autoplay;
    }
    /**
     * Enable browser scrolling with touch on the canvas area.
     * This will block the rotate(pitch) control if the user is currently scrolling.
     * @type {boolean}
     * @default true
     */


    get scrollable() {
      return this._scrollable;
    }
    /**
     * Enable browser scrolling with mouse wheel on the canvas area.
     * This will block the zoom control with mouse wheel.
     * @type {boolean}
     * @default false
     */


    get wheelScrollable() {
      return this._wheelScrollable;
    }
    /**
     * Enable CSS `cursor: grab` on the canvas element.
     * `cursor: grabbing` will be used on mouse click.
     * @type {boolean}
     * @default true
     */


    get useGrabCursor() {
      return this._useGrabCursor;
    }
    /**
     * Source to the HDR texture image (RGBE), which will used as the scene environment map & background.
     * `envmap` will be ignored if this value is not `null`.
     * @type {string | null}
     * @default null
     */


    get skybox() {
      return this._skybox;
    }
    /**
     * Source to the HDR texture image (RGBE), which will used as the scene environment map.
     * @type {string | null}
     * @default null
     */


    get envmap() {
      return this._envmap;
    }
    /**
     * Color code / URL to a image to use as the background.
     * For transparent background, use `null`. (default value)
     * Can be enabled only when the `skybox` is `null`.
     * @type {number | string | null}
     * @default null
     */


    get background() {
      return this._background;
    }
    /**
     * Exposure value of the HDR envmap/skybox image.
     * @type {number}
     * @default 1
     */


    get exposure() {
      return this._exposure;
    }
    /**
     * Enable shadow below the model.
     * If `true` is given, it will enable shadow with the default options.
     * If `false` is given, it will disable the shadow.
     * @type {boolean | ShadowOptions}
     * @default true
     */


    get shadow() {
      return this._shadow;
    }
    /**
     * Apply blur to the current skybox image.
     * @type {boolean}
     * @default false
     */


    get skyboxBlur() {
      return this._skyboxBlur;
    }
    /**
     * Options for the WebXR-based AR session.
     * If `false` is given, it will disable WebXR-based AR session.
     * @type {boolean | WebARSessionOptions}
     * @default true
     */


    get webAR() {
      return this._webAR;
    }
    /**
     * Options for the {@link https://developers.google.com/ar/develop/java/scene-viewer Google SceneViewer} based AR session.
     * If `false` is given, it will disable SceneViewer based AR session.
     * See {@link https://developers.google.com/ar/develop/java/scene-viewer#supported_intent_parameters Official Page} for the parameter details.
     * @type {boolean | SceneViewerSessionOptions}
     * @default true
     */


    get sceneViewer() {
      return this._sceneViewer;
    }
    /**
     * Options for the {@link https://developer.apple.com/augmented-reality/quick-look/ Apple AR Quick Look} based AR session.
     * If `false` is given, it will disable AR Quick Look based AR session.
     * @type {boolean | QuickLookSessionOptions}
     * @default true
     */


    get quickLook() {
      return this._quickLook;
    }
    /**
     * Priority array for the AR sessions.
     * If the two sessions are available in one environment, the session listed earlier will be used first.
     * If the session name is not included in this priority array, that session will be ignored.
     * See {@link AR_SESSION_TYPE}
     * @type {string[]}
     * @default ["webAR", "sceneViewer", "quickLook"]
     */


    get arPriority() {
      return this._arPriority;
    }
    /**
     * A URL to the image that will be displayed before the 3D model is loaded.
     * @type {string | null}
     * @default null
     */


    get poster() {
      return this._poster;
    }
    /**
     * CSS Selector for the canvas element.
     * @type {string}
     * @default "canvas"
     */


    get canvasSelector() {
      return this._canvasSelector;
    }
    /**
     * Call {@link View3D#init init()} automatically when creating View3D's instance
     * This option won't work if `src` is not given
     * @type {boolean}
     * @default true
     * @readonly
     */


    get autoInit() {
      return this._autoInit;
    }
    /**
     * Whether to automatically call {@link View3D#resize resize()} when the canvas element's size is changed
     * @type {boolean}
     * @default true
     */


    get autoResize() {
      return this._autoResize;
    }
    /**
     * Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option
     * @type {boolean}
     * @default true
     */


    get useResizeObserver() {
      return this._useResizeObserver;
    }

    set skybox(val) {
      void this._scene.setSkybox(val);
      this._skybox = val;
    }

    set envmap(val) {
      void this._scene.setEnvMap(val);
      this._envmap = val;
    }

    set exposure(val) {
      this._renderer.threeRenderer.toneMappingExposure = val;
      this._exposure = val;
    }

    set skyboxBlur(val) {
      this._skyboxBlur = val;
      const scene = this._scene;
      const origEnvmapTexture = scene.root.environment;

      if (origEnvmapTexture && !!scene.skybox) {
        if (val) {
          scene.skybox.useBlurredHDR(origEnvmapTexture);
        } else {
          scene.skybox.useTexture(origEnvmapTexture);
        }
      }
    }

    set useGrabCursor(val) {
      this._useGrabCursor = val;

      this._control.updateCursor();
    }
    /**
     * Destroy View3D instance and remove all events attached to it
     * @returns {void}
     */


    destroy() {
      this._scene.reset();

      this._renderer.stopAnimationLoop();

      this._control.destroy();

      this._autoResizer.disable();

      this._animator.reset();

      this._plugins.forEach(plugin => plugin.teardown(this));

      this._plugins = [];
    }
    /**
     * Initialize View3d & load 3D model
     * @fires View3D#load
     * @returns {Promise<void>}
     */


    init() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this._src) {
          throw new View3DError(ERROR.MESSAGES.PROVIDE_SRC_FIRST, ERROR.CODES.PROVIDE_SRC_FIRST);
        }

        if (this._autoResize) {
          this._autoResizer.enable();
        }

        const scene = this._scene;
        const renderer = this._renderer;
        const skybox = this._skybox;
        const envmap = this._envmap;
        const background = this._background;
        const meshoptPath = this._meshoptPath;

        if (meshoptPath && !GLTFLoader$1.meshoptDecoder) {
          yield GLTFLoader$1.setMeshoptDecoder(meshoptPath);
        } // Load & set skybox / envmap before displaying model


        const hasEnvmap = skybox || envmap;

        if (hasEnvmap) {
          const tempLight = new AmbientLight();
          scene.add(tempLight, false);
          const loadEnv = skybox ? scene.setSkybox(skybox) : scene.setEnvMap(envmap);
          void loadEnv.then(() => {
            scene.remove(tempLight);
          });
        }

        if (!skybox && background) {
          void scene.setBackground(background);
        }

        yield this._loadModel(this._src); // Start rendering

        renderer.stopAnimationLoop();
        renderer.setAnimationLoop(renderer.defaultRenderLoop);

        this._control.enable();

        if (this._autoplay) {
          this._autoPlayer.enable();
        }

        this._initialized = true;
        this.trigger(EVENTS.READY, {
          type: EVENTS.READY,
          target: this
        });
      });
    }
    /**
     * Resize View3D instance to fit current canvas size
     * @returns {void}
     */


    resize() {
      const renderer = this._renderer;
      renderer.resize();
      const newSize = renderer.size;

      this._camera.resize(newSize);

      this._control.resize(newSize);

      if (!renderer.threeRenderer.xr.isPresenting) {
        // Prevent flickering on resize
        renderer.defaultRenderLoop(0);
      }

      this.trigger(EVENTS.RESIZE, Object.assign(Object.assign({}, newSize), {
        type: EVENTS.RESIZE,
        target: this
      }));
    }
    /**
     * Load a new 3D model and replace it with the current one
     * @param {string | string[]} src Source URL to fetch 3D model from
     */


    load(src) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._initialized) {
          yield this._loadModel(src); // Change the src later as an error can occur while loading the model

          this._src = src;
        } else {
          this._src = src;
          yield this.init();
        }
      });
    }
    /**
     * Display the given model in the canvas
     * @param {Model} model A model to display
     * @param {object} options Options for displaying model
     * @param {boolean} [options.resetCamera=true] Reset camera to default pose
     */


    display(model, {
      resetCamera = true
    } = {}) {
      const renderer = this._renderer;
      const scene = this._scene;
      const camera = this._camera;
      const animator = this._animator;
      const inXR = renderer.threeRenderer.xr.isPresenting;
      scene.reset();
      scene.add(model.scene);
      scene.shadowPlane.update(model);

      if (resetCamera) {
        camera.fit(model, this._center);
        void camera.reset(0);
      }

      animator.reset();
      animator.setClips(model.animations);

      if (model.animations.length > 0) {
        animator.play(0);
      }

      this._model = model;

      if (inXR) {
        const activeSession = this._arManager.activeSession;

        if (activeSession) {
          activeSession.control.syncTargetModel(model);
        }
      }

      this.trigger(EVENTS.MODEL_CHANGE, {
        type: EVENTS.MODEL_CHANGE,
        target: this,
        model
      });
    }
    /**
     * Add new plugins to View3D
     * @param {View3DPlugin[]} plugins Plugins to add
     * @returns {Promise<void>} A promise that resolves when all plugins are initialized
     */


    loadPlugins(...plugins) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this._initPlugins(plugins);

        this._plugins.push(...plugins);
      });
    }
    /**
     * Remove plugins from View3D
     * @param {View3DPlugin[]} plugins Plugins to remove
     * @returns {Promise<void>} A promise that resolves when all plugins are removed
     */


    removePlugins(...plugins) {
      return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(plugins.map(plugin => plugin.teardown(this)));
        plugins.forEach(plugin => {
          const pluginIdx = this._plugins.indexOf(plugin);

          if (pluginIdx < 0) return;

          this._plugins.splice(pluginIdx, 1);
        });
      });
    }
    /**
     * Take a screenshot of current rendered canvas image and download it
     */


    screenshot(fileName = "screenshot") {
      const canvas = this._renderer.canvas;
      const imgURL = canvas.toDataURL("png");
      const anchorEl = document.createElement("a");
      anchorEl.href = imgURL;
      anchorEl.download = fileName;
      anchorEl.click();
    }

    _loadModel(src) {
      return __awaiter(this, void 0, void 0, function* () {
        const loader = new GLTFLoader$1(this);

        if (Array.isArray(src)) {
          const loaded = src.map(() => false);
          const loadModels = src.map((srcLevel, level) => __awaiter(this, void 0, void 0, function* () {
            this.trigger(EVENTS.LOAD_START, {
              type: EVENTS.LOAD_START,
              target: this,
              src: srcLevel,
              level
            });
            const model = yield loader.load(srcLevel);
            const higherLevelLoaded = loaded.slice(level + 1).some(val => !!val);
            const modelLoadedBefore = loaded.some(val => !!val);
            this.trigger(EVENTS.LOAD, {
              type: EVENTS.LOAD,
              target: this,
              model,
              level
            });
            loaded[level] = true;
            if (higherLevelLoaded) return;
            this.display(model, {
              resetCamera: !modelLoadedBefore
            });
          }));
          yield Promise.race(loadModels);
        } else {
          this.trigger(EVENTS.LOAD_START, {
            type: EVENTS.LOAD_START,
            target: this,
            src,
            level: 0
          });
          const model = yield loader.load(src);
          this.trigger(EVENTS.LOAD, {
            type: EVENTS.LOAD,
            target: this,
            model,
            level: 0
          });
          this.display(model);
        }
      });
    }

    _addEventHandlers(events) {
      Object.keys(events).forEach(evtName => {
        this.on(evtName, events[evtName]);
      });
    }

    _addPosterImage() {
      const poster = this._poster;
      const rootEl = this._rootEl;
      if (!poster) return;
      const imgEl = document.createElement("img");
      imgEl.className = DEFAULT_CLASS.POSTER;
      imgEl.src = poster;
      rootEl.appendChild(imgEl);
      this.once(EVENTS.READY, () => {
        if (imgEl.parentElement !== rootEl) return;
        rootEl.removeChild(imgEl);
      });
    }

    _initPlugins(plugins) {
      return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(plugins.map(plugin => plugin.init(this)));
      });
    }

  }
  /**
   * Current version of the View3D
   * @type {string}
   * @readonly
   */


  View3D.VERSION = "2.1.0";

  /*
   * "View In Ar" Icon from [Google Material Design Icons](https://github.com/google/material-design-icons)
   * Licensed under [Apache Lincese Version 2.0](https://github.com/google/material-design-icons/blob/master/LICENSE)
   */
  // eslint-disable-next-line quotes
  var ARIcon = '<svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" viewBox="0 0 24 24" width="32px" height="32px"><g><rect fill="none" height="24" width="24" x="0" y="0"/></g><g><g><path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.34,1,1,2.34,1,4v2h2V4z"/><path d="M3,20v-2H1v2c0,1.66,1.34,3,3,3h2v-2H4C3.45,21,3,20.55,3,20z"/><path d="M20,1h-2v2h2c0.55,0,1,0.45,1,1v2h2V4C23,2.34,21.66,1,20,1z"/><path d="M21,20c0,0.55-0.45,1-1,1h-2v2h2c1.66,0,3-1.34,3-3v-2h-2V20z"/><path d="M19,14.87V9.13c0-0.72-0.38-1.38-1-1.73l-5-2.88c-0.31-0.18-0.65-0.27-1-0.27s-0.69,0.09-1,0.27L6,7.39 C5.38,7.75,5,8.41,5,9.13v5.74c0,0.72,0.38,1.38,1,1.73l5,2.88c0.31,0.18,0.65,0.27,1,0.27s0.69-0.09,1-0.27l5-2.88 C18.62,16.25,19,15.59,19,14.87z M11,17.17l-4-2.3v-4.63l4,2.33V17.17z M12,10.84L8.04,8.53L12,6.25l3.96,2.28L12,10.84z M17,14.87l-4,2.3v-4.6l4-2.33V14.87z"/></g></g></svg>';

  /**
   * A button that will be shown on the right-bottom side with the AR icon.
   * It will be disabled automatically when it's not available to enter AR sessions.
   * User can enter AR sessions by clicking this.
   */

  class ARButton {
    /**
     * Create new instance of ARButton
     * @param {object} [options={}] Options for the ARButton
     * @param {string} [options.availableText="View in AR"] A text that will be shown on mouse hover when it's available to enter the AR session.
     * @param {string} [options.unavailableText="AR is not available in this browser"] A text that will be shown on mouse hover when it's not available to enter the AR session.
     */
    constructor(options = {}) {
      this._options = options;
      this._button = null;
    }

    init(view3D) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this._addButton(view3D);
      });
    }

    teardown(view3D) {
      const button = this._button;
      if (!button) return;

      if (button.parentElement === view3D.rootEl) {
        view3D.rootEl.removeChild(button);
      }

      this._button = null;
    }

    _addButton(view3D) {
      return __awaiter(this, void 0, void 0, function* () {
        const {
          availableText = "View in AR",
          unavailableText = "AR is not available in this browser",
          buttonClass = "view3d-ar-button",
          tooltipClass = "view3d-tooltip"
        } = this._options;
        const arAvailable = yield view3D.ar.isAvailable();
        const button = document.createElement("button");
        const tooltip = document.createElement("div");
        const tooltipText = document.createTextNode(arAvailable ? availableText : unavailableText);
        button.classList.add(buttonClass);
        tooltip.classList.add(tooltipClass);
        button.disabled = true;
        button.innerHTML = ARIcon;
        button.appendChild(tooltip);
        tooltip.appendChild(tooltipText);
        view3D.rootEl.appendChild(button);
        this._button = button;

        if (view3D.initialized) {
          yield this._setAvailable(view3D, button, arAvailable);
        } else {
          view3D.once(EVENTS.MODEL_CHANGE, () => {
            void this._setAvailable(view3D, button, arAvailable);
          });
        }
      });
    }

    _setAvailable(view3D, button, arAvailable) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!arAvailable) {
          button.disabled = true;
        } else {
          button.disabled = false;
          button.addEventListener("click", () => {
            void view3D.ar.enter();
          });
        }
      });
    }

  }

  /*
   * "Close" Icon from [Google Material Design Icons](https://github.com/google/material-design-icons)
   * Licensed under [Apache Lincese Version 2.0](https://github.com/google/material-design-icons/blob/master/LICENSE)
   */
  // eslint-disable-next-line quotes
  var CloseIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="48px" height="48px" fill="#FFFFFF"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>';

  /**
   * An UI that will be displayed on top of {@link WebARSession}.
   * This will be automatically added on the overlayRoot of the {@link WebARSession}.
   */

  class AROverlay {
    /**
     * Create new instance of AROverlay
     * @param {object} [options={}] Options for the AROverlay
     */
    constructor(options = {}) {
      this._options = options;
    }

    init(view3D) {
      return __awaiter(this, void 0, void 0, function* () {
        view3D.on(EVENTS.AR_START, ({
          session
        }) => {
          const overlayRoot = session.domOverlay.root;
          if (!overlayRoot) return;

          if (this._cachedElements) {
            Object.values(this._cachedElements).map(el => {
              if (!overlayRoot.contains(el)) {
                overlayRoot.appendChild(el);
              }
            });
          } else {
            const closeButton = document.createElement("div");
            closeButton.innerHTML = CloseIcon;
            closeButton.classList.add("view3d-ar-close");
            overlayRoot.appendChild(closeButton);
            this._cachedElements = {
              closeButton
            };
          }

          const {
            closeButton
          } = this._cachedElements;

          const closeButtonHandler = () => {
            void session.exit();
          };

          closeButton.addEventListener("click", closeButtonHandler);
          view3D.once(EVENTS.AR_END, () => {
            if (closeButton.parentElement) {
              closeButton.parentElement.removeChild(closeButton);
            }

            closeButton.removeEventListener("click", closeButtonHandler);
          });
        });
      });
    }

    teardown() {// DO NOTHING
    }

  }

  /**
   * A plugin that displays loading bar while
   */

  class LoadingBar {
    /**
     * Create new instance of Spinner
     * @param {LoadingBarOptions} [options={}] Options for the Spinner
     */
    constructor(options = {}) {
      this._startLoading = ({
        target: view3D
      }) => {
        const {
          type = "default",
          loadingLabel = "Loading 3D Model...",
          parsingLabel = "Parsing 3D Model...",
          labelColor = "#ffffff",
          barHeight = "10px",
          barBackground = "#bbbbbb",
          barForeground = "#3e8ed0",
          overlayBackground = "rgba(0, 0, 0, 0.3)"
        } = this._options;
        const loadingOverlay = document.createElement("div");
        const loadingWrapper = document.createElement("div");
        const loadingLabelEl = document.createElement("div");
        const loadingBar = document.createElement("div");
        const loadingFiller = document.createElement("div");
        loadingOverlay.classList.add("view3d-lb-overlay");
        loadingWrapper.classList.add("view3d-lb-wrapper");
        loadingBar.classList.add("view3d-lb-base");
        loadingLabelEl.classList.add("view3d-lb-label");
        loadingFiller.classList.add("view3d-lb-filler");
        loadingBar.style.height = barHeight;
        loadingOverlay.style.backgroundColor = overlayBackground;

        if (type !== LoadingBar.TYPE.SPINNER) {
          loadingBar.style.backgroundColor = barBackground;
          loadingFiller.style.backgroundColor = barForeground;
        } else {
          loadingBar.classList.add("type-spinner");
        }

        if (type === LoadingBar.TYPE.TOP) {
          loadingOverlay.classList.add("type-top");
        }

        loadingLabelEl.style.color = labelColor;
        loadingLabelEl.innerText = loadingLabel;
        loadingBar.appendChild(loadingFiller);
        loadingWrapper.appendChild(loadingBar);
        loadingWrapper.appendChild(loadingLabelEl);
        loadingOverlay.appendChild(loadingWrapper);
        view3D.rootEl.appendChild(loadingOverlay);

        if (type !== LoadingBar.TYPE.SPINNER) {
          const onProgress = evt => {
            const percentage = 100 * (evt.loaded / evt.total);
            loadingFiller.style.width = `${percentage.toFixed(2)}%`;

            if (evt.loaded === evt.total) {
              loadingLabelEl.innerText = parsingLabel;
            }
          };

          view3D.on(EVENTS.PROGRESS, onProgress);
          view3D.once(EVENTS.LOAD, () => {
            view3D.off(EVENTS.PROGRESS, onProgress);
          });
        }

        view3D.once(EVENTS.LOAD, () => {
          this._removeOverlay(view3D);
        });
        this._overlay = loadingOverlay;
      };

      this._options = options;
    }

    init(view3D) {
      return __awaiter(this, void 0, void 0, function* () {
        view3D.on(EVENTS.LOAD_START, this._startLoading);
      });
    }

    teardown(view3D) {
      view3D.off(EVENTS.LOAD_START, this._startLoading);

      this._removeOverlay(view3D);
    }

    _removeOverlay(view3D) {
      const overlay = this._overlay;
      if (!overlay) return;

      if (overlay.parentElement === view3D.rootEl) {
        view3D.rootEl.removeChild(overlay);
      }

      this._overlay = null;
    }

  }
  /**
   * Available styles of loading bar
   */


  LoadingBar.TYPE = {
    DEFAULT: "default",
    TOP: "top",
    SPINNER: "spinner"
  };

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  // Collection of util functions that is individual to View3D

  /**
   * Check whether View3D can be initialized without any issues.
   * View3D supports browsers with es6+ support.
   * @param {object} [features={}] Features to test
   * @returns {boolean} A boolean value indicating whether View3D is avilable
   */
  const isAvailable = ({
    webGL = true,
    fetch = true,
    stream = true,
    wasm = true
  } = {}) => {
    if (webGL) {
      const webglAvailable = checkWebGLAvailability();
      if (!webglAvailable) return false;
    }

    if (fetch) {
      const fetchAvailable = window && window.fetch;
      if (!fetchAvailable) return false;
    }

    if (stream) {
      const streamAvailable = window && window.ReadableStream;
      if (!streamAvailable) return false;
    }

    if (wasm) {
      const wasmAvailable = checkWASMAvailability();
      if (!wasmAvailable) return false;
    }

    return true;
  };

  const checkWebGLAvailability = () => {
    try {
      const canvas = document.createElement("canvas");
      return !!window.WebGLRenderingContext && !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
    } catch (e) {
      return false;
    }
  };

  const checkWASMAvailability = () => {
    try {
      if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
        const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
        if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
      }
    } catch (e) {
      return false;
    }
  };

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */

  var modules = {
    __proto__: null,
    'default': View3D,
    Animation: Animation,
    ARManager: ARManager,
    AutoPlayer: AutoPlayer,
    AutoResizer: AutoResizer,
    Camera: Camera$1,
    Model: Model,
    ModelAnimator: ModelAnimator,
    Motion: Motion,
    Pose: Pose,
    Renderer: Renderer,
    Scene: Scene$1,
    ShadowPlane: ShadowPlane,
    Skybox: Skybox,
    View3DError: View3DError,
    AnimationControl: AnimationControl,
    OrbitControl: OrbitControl,
    RotateControl: RotateControl,
    TranslateControl: TranslateControl,
    ZoomControl: ZoomControl,
    GLTFLoader: GLTFLoader$1,
    TextureLoader: TextureLoader$1,
    ARButton: ARButton,
    AROverlay: AROverlay,
    LoadingBar: LoadingBar,
    AUTO: AUTO,
    EVENTS: EVENTS,
    EASING: EASING,
    DEFAULT_CLASS: DEFAULT_CLASS,
    AR_SESSION_TYPE: AR_SESSION_TYPE,
    SCENE_VIEWER_MODE: SCENE_VIEWER_MODE,
    QUICK_LOOK_APPLE_PAY_BUTTON_TYPE: QUICK_LOOK_APPLE_PAY_BUTTON_TYPE,
    QUICK_LOOK_CUSTOM_BANNER_SIZE: QUICK_LOOK_CUSTOM_BANNER_SIZE,
    ERROR_CODES: ERROR_CODES,
    isAvailable: isAvailable
  };

  /*
   * Copyright (c) 2020 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  merge(View3D, modules);

  return View3D;

})));
